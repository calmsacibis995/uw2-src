#pragma ident	"%W%"

/***								-*- C -*-
 ***
 ***	Warning!  Target file, do not modify.
 ***	
 ***	Generated from: s3_opt.gen
 ***
 ***	Generated by: (genoptions 1.0.0).
 ***
 ***/

PUBLIC

#include "stdenv.h"
#include "global.h"


enum s3_options_si_interface_version
{
	S3_OPTIONS_SI_INTERFACE_VERSION_1_0,
	S3_OPTIONS_SI_INTERFACE_VERSION_1_1,
	S3_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	s3_options_si_interface_version_end_enumeration
};

enum s3_options_cursor_type
{
	S3_OPTIONS_CURSOR_TYPE_HARDWARE_CURSOR,
	S3_OPTIONS_CURSOR_TYPE_SOFTWARE_CURSOR,
	s3_options_cursor_type_end_enumeration
};

enum s3_options_monitor_sync_type
{
	S3_OPTIONS_MONITOR_SYNC_TYPE_COMPOSITE_SYNC,
	S3_OPTIONS_MONITOR_SYNC_TYPE_SYNC_ON_GREEN,
	S3_OPTIONS_MONITOR_SYNC_TYPE_SEPARATE_SYNC,
	s3_options_monitor_sync_type_end_enumeration
};

enum s3_options_vsync_polarity
{
	S3_OPTIONS_VSYNC_POLARITY_POSITIVE,
	S3_OPTIONS_VSYNC_POLARITY_NEGATIVE,
	S3_OPTIONS_VSYNC_POLARITY_DEFAULT,
	s3_options_vsync_polarity_end_enumeration
};

enum s3_options_hsync_polarity
{
	S3_OPTIONS_HSYNC_POLARITY_POSITIVE,
	S3_OPTIONS_HSYNC_POLARITY_NEGATIVE,
	S3_OPTIONS_HSYNC_POLARITY_DEFAULT,
	s3_options_hsync_polarity_end_enumeration
};

enum s3_options_wait_state_control
{
	S3_OPTIONS_WAIT_STATE_CONTROL_YES,
	S3_OPTIONS_WAIT_STATE_CONTROL_NO,
	s3_options_wait_state_control_end_enumeration
};

enum s3_options_enable_write_posting
{
	S3_OPTIONS_ENABLE_WRITE_POSTING_YES,
	S3_OPTIONS_ENABLE_WRITE_POSTING_NO,
	s3_options_enable_write_posting_end_enumeration
};

enum s3_options_enable_eprom_write
{
	S3_OPTIONS_ENABLE_EPROM_WRITE_YES,
	S3_OPTIONS_ENABLE_EPROM_WRITE_NO,
	s3_options_enable_eprom_write_end_enumeration
};

enum s3_options_enable_split_transfers
{
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_YES,
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_NO,
	s3_options_enable_split_transfers_end_enumeration
};

enum s3_options_enable_nibble_swap
{
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_YES,
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_NO,
	s3_options_enable_nibble_swap_end_enumeration
};

enum s3_options_enable_nibble_write_control
{
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_YES,
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_NO,
	s3_options_enable_nibble_write_control_end_enumeration
};

enum s3_options_vram_addressing_mode
{
	S3_OPTIONS_VRAM_ADDRESSING_MODE_PARALLEL,
	S3_OPTIONS_VRAM_ADDRESSING_MODE_SERIAL,
	s3_options_vram_addressing_mode_end_enumeration
};

enum s3_options_limit_write_posting
{
	S3_OPTIONS_LIMIT_WRITE_POSTING_YES,
	S3_OPTIONS_LIMIT_WRITE_POSTING_NO,
	s3_options_limit_write_posting_end_enumeration
};

enum s3_options_enable_read_ahead_cache
{
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_YES,
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_NO,
	s3_options_enable_read_ahead_cache_end_enumeration
};

enum s3_options_latch_isa_addr
{
	S3_OPTIONS_LATCH_ISA_ADDR_YES,
	S3_OPTIONS_LATCH_ISA_ADDR_NO,
	s3_options_latch_isa_addr_end_enumeration
};

enum s3_options_serial_access_mode_control
{
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_512,
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_256,
	s3_options_serial_access_mode_control_end_enumeration
};

enum s3_options_ras_m_clk
{
	S3_OPTIONS_RAS_M_CLK_7,
	S3_OPTIONS_RAS_M_CLK_6,
	s3_options_ras_m_clk_end_enumeration
};

enum s3_options_use_save_unders
{
	S3_OPTIONS_USE_SAVE_UNDERS_NO,
	S3_OPTIONS_USE_SAVE_UNDERS_YES,
	s3_options_use_save_unders_end_enumeration
};

enum s3_options_chipset_name
{
	S3_OPTIONS_CHIPSET_NAME_86C801,
	S3_OPTIONS_CHIPSET_NAME_86C911,
	S3_OPTIONS_CHIPSET_NAME_86C924,
	S3_OPTIONS_CHIPSET_NAME_86C928,
	S3_OPTIONS_CHIPSET_NAME_86C928_PCI,
	S3_OPTIONS_CHIPSET_NAME_AUTO_DETECT,
	s3_options_chipset_name_end_enumeration
};

enum s3_options_stepping_number
{
	S3_OPTIONS_STEPPING_NUMBER_A_STEP,
	S3_OPTIONS_STEPPING_NUMBER_B_STEP,
	S3_OPTIONS_STEPPING_NUMBER_C_STEP,
	S3_OPTIONS_STEPPING_NUMBER_D_STEP,
	S3_OPTIONS_STEPPING_NUMBER_E_STEP,
	S3_OPTIONS_STEPPING_NUMBER_G_STEP,
	S3_OPTIONS_STEPPING_NUMBER_AUTO_DETECT,
	s3_options_stepping_number_end_enumeration
};

enum s3_options_clock_chip_name
{
	S3_OPTIONS_CLOCK_CHIP_NAME_APPROXIMATE_VALUES,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9204B,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9204C,
	S3_OPTIONS_CLOCK_CHIP_NAME_ICD_2061,
	S3_OPTIONS_CLOCK_CHIP_NAME_ICD_2061A,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_56,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_07,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_11,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9294G,
	S3_OPTIONS_CLOCK_CHIP_NAME_TI_3025,
	S3_OPTIONS_CLOCK_CHIP_NAME_UNKNOWN,
	s3_options_clock_chip_name_end_enumeration
};

enum s3_options_s3_bus_width
{
	S3_OPTIONS_S3_BUS_WIDTH_16_BIT,
	S3_OPTIONS_S3_BUS_WIDTH_8_BIT,
	s3_options_s3_bus_width_end_enumeration
};

enum s3_options_fast_rmw
{
	S3_OPTIONS_FAST_RMW_YES,
	S3_OPTIONS_FAST_RMW_NO,
	s3_options_fast_rmw_end_enumeration
};

enum s3_options_enable_alternate_ioport_address
{
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_YES,
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_NO,
	s3_options_enable_alternate_ioport_address_end_enumeration
};

enum s3_options_dac_name
{
	S3_OPTIONS_DAC_NAME_ATT20C491,
	S3_OPTIONS_DAC_NAME_SC15025,
	S3_OPTIONS_DAC_NAME_SC11481_6_2_3,
	S3_OPTIONS_DAC_NAME_SC11485_7,
	S3_OPTIONS_DAC_NAME_SC11484_8,
	S3_OPTIONS_DAC_NAME_SC11489,
	S3_OPTIONS_DAC_NAME_SC11471_6,
	S3_OPTIONS_DAC_NAME_SC11478,
	S3_OPTIONS_DAC_NAME_IMSG171,
	S3_OPTIONS_DAC_NAME_IMSG176,
	S3_OPTIONS_DAC_NAME_IMSG178,
	S3_OPTIONS_DAC_NAME_BT471_6,
	S3_OPTIONS_DAC_NAME_BT478,
	S3_OPTIONS_DAC_NAME_BT485KPJ110,
	S3_OPTIONS_DAC_NAME_BT485KPJ135,
	S3_OPTIONS_DAC_NAME_W82C478,
	S3_OPTIONS_DAC_NAME_W82C476,
	S3_OPTIONS_DAC_NAME_W82C490,
	S3_OPTIONS_DAC_NAME_TR9C1710,
	S3_OPTIONS_DAC_NAME_ATT20C490,
	S3_OPTIONS_DAC_NAME_SS2410,
	S3_OPTIONS_DAC_NAME_TI3020,
	S3_OPTIONS_DAC_NAME_TI3025,
	S3_OPTIONS_DAC_NAME_UNKNOWN_DAC,
	s3_options_dac_name_end_enumeration
};

enum s3_options_use_clock_doubler
{
	S3_OPTIONS_USE_CLOCK_DOUBLER_NO,
	S3_OPTIONS_USE_CLOCK_DOUBLER_AUTO_CONFIGURE,
	s3_options_use_clock_doubler_end_enumeration
};

enum s3_options_use_dac_external_sid_mode
{
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_NO,
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_AUTO_CONFIGURE,
	s3_options_use_dac_external_sid_mode_end_enumeration
};

enum s3_options_dac_rgb_width
{
	S3_OPTIONS_DAC_RGB_WIDTH_6,
	S3_OPTIONS_DAC_RGB_WIDTH_8,
	S3_OPTIONS_DAC_RGB_WIDTH_DEFAULT,
	s3_options_dac_rgb_width_end_enumeration
};

enum s3_options_dac_24_bit_color_mode
{
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_ABGR,
	s3_options_dac_24_bit_color_mode_end_enumeration
};

enum s3_options_dac_16_bit_color_mode
{
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_565,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_655,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_664,
	s3_options_dac_16_bit_color_mode_end_enumeration
};

enum s3_options_override_ss_stippling
{
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_YES,
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_NO,
	s3_options_override_ss_stippling_end_enumeration
};


#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_IO_ACCESS	1
#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_READ_ENHANCED_REGS	2
#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_WRITE_ENHANCED_REGS	4
#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_READ_PIXTRANS	8
#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_WRITE_PIXTRANS	16
#define	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_LFB_ACCESS	32


#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_STATIC_GRAY	1
#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_GRAY_SCALE	2
#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_STATIC_COLOR	4
#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_PSEUDO_COLOR	8
#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_TRUE_COLOR	16
#define	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_DIRECT_COLOR	32


#define	S3_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT	1
#define	S3_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT	2
#define	S3_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT	4
#define	S3_OPTIONS_RECTFILL_OPTIONS_USE_GE_PATFILL	8
#define	S3_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY	16
#define	S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_STIPPLES	32
#define	S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_TILES	64
#define	S3_OPTIONS_RECTFILL_OPTIONS_NONE	128


#define	S3_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT	1
#define	S3_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT	2
#define	S3_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT	4
#define	S3_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT	8
#define	S3_OPTIONS_BITBLT_OPTIONS_NONE	16


#define	S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW	1
#define	S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES	2
#define	S3_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW	4
#define	S3_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINE	8
#define	S3_OPTIONS_LINEDRAW_OPTIONS_NONE	16


#define	S3_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL	1
#define	S3_OPTIONS_SPANSFILL_OPTIONS_USE_STIPPLE_FILL	2
#define	S3_OPTIONS_SPANSFILL_OPTIONS_USE_TILE_FILL	4
#define	S3_OPTIONS_SPANSFILL_OPTIONS_USE_GE_PATFILL	8
#define	S3_OPTIONS_SPANSFILL_OPTIONS_USE_OFFSCREEN_MEMORY	16
#define	S3_OPTIONS_SPANSFILL_OPTIONS_NONE	32


#define	S3_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT	1
#define	S3_OPTIONS_POINTDRAW_OPTIONS_NONE	2


#define	S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_NON_TERMINAL_FONTS	1
#define	S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_TERMINAL_FONTS	2
#define	S3_OPTIONS_FONTDRAW_OPTIONS_USE_OFFSCREEN_MEMORY	4
#define	S3_OPTIONS_FONTDRAW_OPTIONS_ASSEMBLE_GLYPHS	8
#define	S3_OPTIONS_FONTDRAW_OPTIONS_NONE	16


#define	S3_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS	1




struct s3_options_structure
{
	int arc_cache_size;
	unsigned int arcdraw_options;
	unsigned int bitblt_options;
	int bitmap_reduction_threshold;
	enum s3_options_chipset_name chipset_name;
	enum s3_options_clock_chip_name clock_chip_name;
	int clock_doubler_threshold;
	char *crtc_parameters;
	int crtc_start_offset;
	int crtc_sync_timeout_count;
	char *cursor_max_size;
	enum s3_options_cursor_type cursor_type;
	enum s3_options_dac_16_bit_color_mode dac_16_bit_color_mode;
	enum s3_options_dac_24_bit_color_mode dac_24_bit_color_mode;
	int dac_access_delay_count;
	int dac_external_sid_threshold;
	int dac_max_frequency;
	enum s3_options_dac_name dac_name;
	enum s3_options_dac_rgb_width dac_rgb_width;
	int decode_wait_control;
	int display_skew;
	enum s3_options_enable_alternate_ioport_address enable_alternate_ioport_address;
	enum s3_options_enable_eprom_write enable_eprom_write;
	enum s3_options_enable_nibble_swap enable_nibble_swap;
	enum s3_options_enable_nibble_write_control enable_nibble_write_control;
	enum s3_options_enable_read_ahead_cache enable_read_ahead_cache;
	enum s3_options_enable_split_transfers enable_split_transfers;
	enum s3_options_enable_write_posting enable_write_posting;
	enum s3_options_fast_rmw fast_rmw;
	unsigned int fontdraw_options;
	char *glyph_cache_size;
	int graphics_engine_fifo_blocking_factor;
	int graphics_engine_loop_timeout_count;
	int graphics_engine_micro_delay_count;
	int horizontal_skew;
	enum s3_options_hsync_polarity hsync_polarity;
	enum s3_options_latch_isa_addr latch_isa_addr;
	enum s3_options_limit_write_posting limit_write_posting;
	int linear_frame_buffer_size;
	unsigned int linedraw_options;
	int max_fully_cacheable_font_size;
	int max_number_of_glyphs_in_downloadable_font;
	int maximum_offscreen_downloadable_bitmap_height;
	int maximum_offscreen_downloadable_bitmap_width;
	unsigned int memory_and_register_access_mode;
	char *modedb_string;
	enum s3_options_monitor_sync_type monitor_sync_type;
	int number_of_downloadable_cursors;
	int number_of_downloadable_fonts;
	int number_of_graphics_states;
	int offscreen_stipple_padded_height;
	int offscreen_stipple_padded_width;
	int offscreen_tile_padded_height;
	int offscreen_tile_padded_width;
	int omm_full_coalesce_watermark;
	int omm_hash_list_size;
	int omm_horizontal_constraint;
	char *omm_named_allocation_list;
	int omm_neighbour_list_increment;
	int omm_vertical_constraint;
	enum s3_options_override_ss_stippling override_ss_stippling;
	unsigned int pointdraw_options;
	int rac_extra_prefetch;
	enum s3_options_ras_m_clk ras_m_clk;
	int read_wait_control;
	unsigned int rectfill_options;
	char *register_values_string;
	enum s3_options_s3_bus_width s3_bus_width;
	unsigned int screen_8_4_bit_visual_list;
	enum s3_options_serial_access_mode_control serial_access_mode_control;
	enum s3_options_si_interface_version si_interface_version;
	unsigned int spansfill_options;
	char *static_colormap_description_file;
	enum s3_options_stepping_number stepping_number;
	char *stipple_best_size;
	char *tile_best_size;
	enum s3_options_use_clock_doubler use_clock_doubler;
	enum s3_options_use_dac_external_sid_mode use_dac_external_sid_mode;
	enum s3_options_use_save_unders use_save_unders;
	int verbose_startup;
	enum s3_options_vram_addressing_mode vram_addressing_mode;
	enum s3_options_vsync_polarity vsync_polarity;
	int vt_switch_save_lines;
	enum s3_options_wait_state_control wait_state_control;

};

/*
 * Names of the option defaults
 */

#define S3_OPTIONS_ARC_CACHE_SIZE_DEFAULT\
	16
#define S3_OPTIONS_ARCDRAW_OPTIONS_DEFAULT\
	( S3_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS )
#define S3_OPTIONS_BITBLT_OPTIONS_DEFAULT\
	( S3_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT )
#define S3_OPTIONS_BITMAP_REDUCTION_THRESHOLD_DEFAULT\
	32
#define S3_OPTIONS_CHIPSET_NAME_DEFAULT\
	S3_OPTIONS_CHIPSET_NAME_AUTO_DETECT
#define S3_OPTIONS_CLOCK_CHIP_NAME_DEFAULT\
	S3_OPTIONS_CLOCK_CHIP_NAME_UNKNOWN
#define S3_OPTIONS_CLOCK_DOUBLER_THRESHOLD_DEFAULT\
	0
#define S3_OPTIONS_CRTC_PARAMETERS_DEFAULT 0
#define S3_OPTIONS_CRTC_START_OFFSET_DEFAULT\
	0
#define S3_OPTIONS_CRTC_SYNC_TIMEOUT_COUNT_DEFAULT\
	100000
#define S3_OPTIONS_CURSOR_MAX_SIZE_DEFAULT 0
#define S3_OPTIONS_CURSOR_TYPE_DEFAULT\
	S3_OPTIONS_CURSOR_TYPE_HARDWARE_CURSOR
#define S3_OPTIONS_DAC_16_BIT_COLOR_MODE_DEFAULT\
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_555
#define S3_OPTIONS_DAC_24_BIT_COLOR_MODE_DEFAULT\
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA
#define S3_OPTIONS_DAC_ACCESS_DELAY_COUNT_DEFAULT\
	1000
#define S3_OPTIONS_DAC_EXTERNAL_SID_THRESHOLD_DEFAULT\
	0
#define S3_OPTIONS_DAC_MAX_FREQUENCY_DEFAULT\
	0
#define S3_OPTIONS_DAC_NAME_DEFAULT\
	S3_OPTIONS_DAC_NAME_UNKNOWN_DAC
#define S3_OPTIONS_DAC_RGB_WIDTH_DEFAULT\
	S3_OPTIONS_DAC_RGB_WIDTH_6
#define S3_OPTIONS_DECODE_WAIT_CONTROL_DEFAULT\
	3
#define S3_OPTIONS_DISPLAY_SKEW_DEFAULT\
	0
#define S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_DEFAULT\
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_NO
#define S3_OPTIONS_ENABLE_EPROM_WRITE_DEFAULT\
	S3_OPTIONS_ENABLE_EPROM_WRITE_NO
#define S3_OPTIONS_ENABLE_NIBBLE_SWAP_DEFAULT\
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_NO
#define S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_DEFAULT\
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_NO
#define S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_DEFAULT\
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_NO
#define S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_DEFAULT\
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_YES
#define S3_OPTIONS_ENABLE_WRITE_POSTING_DEFAULT\
	S3_OPTIONS_ENABLE_WRITE_POSTING_NO
#define S3_OPTIONS_FAST_RMW_DEFAULT\
	S3_OPTIONS_FAST_RMW_NO
#define S3_OPTIONS_FONTDRAW_OPTIONS_DEFAULT\
	( S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_NON_TERMINAL_FONTS |S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_TERMINAL_FONTS |S3_OPTIONS_FONTDRAW_OPTIONS_USE_OFFSCREEN_MEMORY |S3_OPTIONS_FONTDRAW_OPTIONS_ASSEMBLE_GLYPHS )
#define S3_OPTIONS_GLYPH_CACHE_SIZE_DEFAULT\
	"64X64"
#define S3_OPTIONS_GRAPHICS_ENGINE_FIFO_BLOCKING_FACTOR_DEFAULT\
	8
#define S3_OPTIONS_GRAPHICS_ENGINE_LOOP_TIMEOUT_COUNT_DEFAULT\
	200000
#define S3_OPTIONS_GRAPHICS_ENGINE_MICRO_DELAY_COUNT_DEFAULT\
	40
#define S3_OPTIONS_HORIZONTAL_SKEW_DEFAULT\
	0
#define S3_OPTIONS_HSYNC_POLARITY_DEFAULT\
	S3_OPTIONS_HSYNC_POLARITY_DEFAULT
#define S3_OPTIONS_LATCH_ISA_ADDR_DEFAULT\
	S3_OPTIONS_LATCH_ISA_ADDR_NO
#define S3_OPTIONS_LIMIT_WRITE_POSTING_DEFAULT\
	S3_OPTIONS_LIMIT_WRITE_POSTING_NO
#define S3_OPTIONS_LINEAR_FRAME_BUFFER_SIZE_DEFAULT\
	0
#define S3_OPTIONS_LINEDRAW_OPTIONS_DEFAULT\
	( S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW |S3_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW |S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES |S3_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINE )
#define S3_OPTIONS_MAX_FULLY_CACHEABLE_FONT_SIZE_DEFAULT\
	1
#define S3_OPTIONS_MAX_NUMBER_OF_GLYPHS_IN_DOWNLOADABLE_FONT_DEFAULT\
	256
#define S3_OPTIONS_MAXIMUM_OFFSCREEN_DOWNLOADABLE_BITMAP_HEIGHT_DEFAULT\
	256
#define S3_OPTIONS_MAXIMUM_OFFSCREEN_DOWNLOADABLE_BITMAP_WIDTH_DEFAULT\
	256
#define S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_DEFAULT\
	( S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_IO_ACCESS )
#define S3_OPTIONS_MODEDB_STRING_DEFAULT 0
#define S3_OPTIONS_MONITOR_SYNC_TYPE_DEFAULT\
	S3_OPTIONS_MONITOR_SYNC_TYPE_COMPOSITE_SYNC
#define S3_OPTIONS_NUMBER_OF_DOWNLOADABLE_CURSORS_DEFAULT\
	1
#define S3_OPTIONS_NUMBER_OF_DOWNLOADABLE_FONTS_DEFAULT\
	17
#define S3_OPTIONS_NUMBER_OF_GRAPHICS_STATES_DEFAULT\
	4
#define S3_OPTIONS_OFFSCREEN_STIPPLE_PADDED_HEIGHT_DEFAULT\
	32
#define S3_OPTIONS_OFFSCREEN_STIPPLE_PADDED_WIDTH_DEFAULT\
	128
#define S3_OPTIONS_OFFSCREEN_TILE_PADDED_HEIGHT_DEFAULT\
	32
#define S3_OPTIONS_OFFSCREEN_TILE_PADDED_WIDTH_DEFAULT\
	128
#define S3_OPTIONS_OMM_FULL_COALESCE_WATERMARK_DEFAULT\
	2
#define S3_OPTIONS_OMM_HASH_LIST_SIZE_DEFAULT\
	0
#define S3_OPTIONS_OMM_HORIZONTAL_CONSTRAINT_DEFAULT\
	0
#define S3_OPTIONS_OMM_NAMED_ALLOCATION_LIST_DEFAULT\
	""
#define S3_OPTIONS_OMM_NEIGHBOUR_LIST_INCREMENT_DEFAULT\
	0
#define S3_OPTIONS_OMM_VERTICAL_CONSTRAINT_DEFAULT\
	0
#define S3_OPTIONS_OVERRIDE_SS_STIPPLING_DEFAULT\
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_YES
#define S3_OPTIONS_POINTDRAW_OPTIONS_DEFAULT\
	( S3_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT )
#define S3_OPTIONS_RAC_EXTRA_PREFETCH_DEFAULT\
	0
#define S3_OPTIONS_RAS_M_CLK_DEFAULT\
	S3_OPTIONS_RAS_M_CLK_7
#define S3_OPTIONS_READ_WAIT_CONTROL_DEFAULT\
	3
#define S3_OPTIONS_RECTFILL_OPTIONS_DEFAULT\
	( S3_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_GE_PATFILL |S3_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY |S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_STIPPLES |S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_TILES )
#define S3_OPTIONS_REGISTER_VALUES_STRING_DEFAULT\
	""
#define S3_OPTIONS_S3_BUS_WIDTH_DEFAULT\
	S3_OPTIONS_S3_BUS_WIDTH_16_BIT
#define S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_DEFAULT 0
#define S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_DEFAULT\
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_512
#define S3_OPTIONS_SI_INTERFACE_VERSION_DEFAULT\
	S3_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE
#define S3_OPTIONS_SPANSFILL_OPTIONS_DEFAULT\
	( S3_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL |S3_OPTIONS_SPANSFILL_OPTIONS_USE_TILE_FILL |S3_OPTIONS_SPANSFILL_OPTIONS_USE_STIPPLE_FILL )
#define S3_OPTIONS_STATIC_COLORMAP_DESCRIPTION_FILE_DEFAULT 0
#define S3_OPTIONS_STEPPING_NUMBER_DEFAULT\
	S3_OPTIONS_STEPPING_NUMBER_AUTO_DETECT
#define S3_OPTIONS_STIPPLE_BEST_SIZE_DEFAULT\
	"64X64"
#define S3_OPTIONS_TILE_BEST_SIZE_DEFAULT\
	"64X64"
#define S3_OPTIONS_USE_CLOCK_DOUBLER_DEFAULT\
	S3_OPTIONS_USE_CLOCK_DOUBLER_AUTO_CONFIGURE
#define S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_DEFAULT\
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_AUTO_CONFIGURE
#define S3_OPTIONS_USE_SAVE_UNDERS_DEFAULT\
	S3_OPTIONS_USE_SAVE_UNDERS_NO
#define S3_OPTIONS_VERBOSE_STARTUP_DEFAULT\
	0
#define S3_OPTIONS_VRAM_ADDRESSING_MODE_DEFAULT\
	S3_OPTIONS_VRAM_ADDRESSING_MODE_SERIAL
#define S3_OPTIONS_VSYNC_POLARITY_DEFAULT\
	S3_OPTIONS_VSYNC_POLARITY_DEFAULT
#define S3_OPTIONS_VT_SWITCH_SAVE_LINES_DEFAULT\
	4096
#define S3_OPTIONS_WAIT_STATE_CONTROL_DEFAULT\
	S3_OPTIONS_WAIT_STATE_CONTROL_YES


#if (defined(__DEBUG__))
export boolean	s3_options_debug = FALSE;
#endif


PRIVATE
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <limits.h>

/*
 * The types of options.
 */

enum s3_options_kind
{
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_OPTION_ENVIRONMENT,
	S3_OPTIONS_OPTION_FILE,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,

	s3_options_end_option_types
};

#if (defined(__DEBUG__))

static const char *const option_type_dump[] = 
{
	"multiple-enumeration",
	"numeric",
	"option-environment",
	"option-file",
	"string",
	"unique-enumeration",

	0
};

#endif

/*
 * The default options.
 */
static struct s3_options_structure s3_options_default =
{
	16,
	( S3_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS ),
	( S3_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT |S3_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT ),
	32,
	S3_OPTIONS_CHIPSET_NAME_AUTO_DETECT,
	S3_OPTIONS_CLOCK_CHIP_NAME_UNKNOWN,
	0,
	0,
	0,
	100000,
	0,
	S3_OPTIONS_CURSOR_TYPE_HARDWARE_CURSOR,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	1000,
	0,
	0,
	S3_OPTIONS_DAC_NAME_UNKNOWN_DAC,
	S3_OPTIONS_DAC_RGB_WIDTH_6,
	3,
	0,
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_NO,
	S3_OPTIONS_ENABLE_EPROM_WRITE_NO,
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_NO,
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_NO,
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_NO,
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_YES,
	S3_OPTIONS_ENABLE_WRITE_POSTING_NO,
	S3_OPTIONS_FAST_RMW_NO,
	( S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_NON_TERMINAL_FONTS |S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_TERMINAL_FONTS |S3_OPTIONS_FONTDRAW_OPTIONS_USE_OFFSCREEN_MEMORY |S3_OPTIONS_FONTDRAW_OPTIONS_ASSEMBLE_GLYPHS ),
	"64x64",
	8,
	200000,
	40,
	0,
	S3_OPTIONS_HSYNC_POLARITY_DEFAULT,
	S3_OPTIONS_LATCH_ISA_ADDR_NO,
	S3_OPTIONS_LIMIT_WRITE_POSTING_NO,
	0,
	( S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW |S3_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW |S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES |S3_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINE ),
	1,
	256,
	256,
	256,
	( S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_IO_ACCESS ),
	0,
	S3_OPTIONS_MONITOR_SYNC_TYPE_COMPOSITE_SYNC,
	1,
	17,
	4,
	32,
	128,
	32,
	128,
	2,
	0,
	0,
	"",
	0,
	0,
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_YES,
	( S3_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT ),
	0,
	S3_OPTIONS_RAS_M_CLK_7,
	3,
	( S3_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT |S3_OPTIONS_RECTFILL_OPTIONS_USE_GE_PATFILL |S3_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY |S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_STIPPLES |S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_TILES ),
	"",
	S3_OPTIONS_S3_BUS_WIDTH_16_BIT,
	0,
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_512,
	S3_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	( S3_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL |S3_OPTIONS_SPANSFILL_OPTIONS_USE_TILE_FILL |S3_OPTIONS_SPANSFILL_OPTIONS_USE_STIPPLE_FILL ),
	0,
	S3_OPTIONS_STEPPING_NUMBER_AUTO_DETECT,
	"64x64",
	"64x64",
	S3_OPTIONS_USE_CLOCK_DOUBLER_AUTO_CONFIGURE,
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_AUTO_CONFIGURE,
	S3_OPTIONS_USE_SAVE_UNDERS_NO,
	0,
	S3_OPTIONS_VRAM_ADDRESSING_MODE_SERIAL,
	S3_OPTIONS_VSYNC_POLARITY_DEFAULT,
	4096,
	S3_OPTIONS_WAIT_STATE_CONTROL_YES,

};

/*
 * The list of option keywords.
 */

static const char *const s3_options_keywords[] = 
{
	"arc-cache-size",
	"arcdraw-options",
	"bitblt-options",
	"bitmap-reduction-threshold",
	"chipset-name",
	"clock-chip-name",
	"clock-doubler-threshold",
	"crtc-parameters",
	"crtc-start-offset",
	"crtc-sync-timeout-count",
	"cursor-max-size",
	"cursor-type",
	"dac-16-bit-color-mode",
	"dac-24-bit-color-mode",
	"dac-access-delay-count",
	"dac-external-sid-threshold",
	"dac-max-frequency",
	"dac-name",
	"dac-rgb-width",
	"decode-wait-control",
	"display-skew",
	"enable-alternate-ioport-address",
	"enable-eprom-write",
	"enable-nibble-swap",
	"enable-nibble-write-control",
	"enable-read-ahead-cache",
	"enable-split-transfers",
	"enable-write-posting",
	"fast-rmw",
	"fontdraw-options",
	"glyph-cache-size",
	"graphics-engine-fifo-blocking-factor",
	"graphics-engine-loop-timeout-count",
	"graphics-engine-micro-delay-count",
	"horizontal-skew",
	"hsync-polarity",
	"latch-isa-addr",
	"limit-write-posting",
	"linear-frame-buffer-size",
	"linedraw-options",
	"max-fully-cacheable-font-size",
	"max-number-of-glyphs-in-downloadable-font",
	"maximum-offscreen-downloadable-bitmap-height",
	"maximum-offscreen-downloadable-bitmap-width",
	"memory-and-register-access-mode",
	"modedb-string",
	"monitor-sync-type",
	"number-of-downloadable-cursors",
	"number-of-downloadable-fonts",
	"number-of-graphics-states",
	"offscreen-stipple-padded-height",
	"offscreen-stipple-padded-width",
	"offscreen-tile-padded-height",
	"offscreen-tile-padded-width",
	"omm-full-coalesce-watermark",
	"omm-hash-list-size",
	"omm-horizontal-constraint",
	"omm-named-allocation-list",
	"omm-neighbour-list-increment",
	"omm-vertical-constraint",
	"options-file",
	"options-variable",
	"override-ss-stippling",
	"pointdraw-options",
	"rac-extra-prefetch",
	"ras-m-clk",
	"read-wait-control",
	"rectfill-options",
	"register-values-string",
	"s3-bus-width",
	"screen-8-4-bit-visual-list",
	"serial-access-mode-control",
	"si-interface-version",
	"spansfill-options",
	"static-colormap-description-file",
	"stepping-number",
	"stipple-best-size",
	"tile-best-size",
	"use-clock-doubler",
	"use-dac-external-sid-mode",
	"use-save-unders",
	"verbose-startup",
	"vram-addressing-mode",
	"vsync-polarity",
	"vt-switch-save-lines",
	"wait-state-control",

	0
};
/*
 * This array maps the option index to the option kind.
 */
static enum s3_options_kind option_index_to_option_kind[] =
{
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_STRING,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_STRING,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_STRING,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_OPTION_FILE,
	S3_OPTIONS_OPTION_ENVIRONMENT,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_MULTIPLE_ENUMERATION,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_STRING,
	S3_OPTIONS_STRING,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_UNIQUE_ENUMERATION,
	S3_OPTIONS_NUMERIC,
	S3_OPTIONS_UNIQUE_ENUMERATION,

	s3_options_end_option_types
};



/*
 * List of enumeration keywords.
 */

static const char *const s3_options_si_interface_version_keywords[] =
{
	"1-0",
	"1-1",
	"auto-configure",
	0
};
static const enum s3_options_si_interface_version s3_options_si_interface_version_index_to_value[] =
{
	S3_OPTIONS_SI_INTERFACE_VERSION_1_0,
	S3_OPTIONS_SI_INTERFACE_VERSION_1_1,
	S3_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	s3_options_si_interface_version_end_enumeration
};
static const char *const s3_options_cursor_type_keywords[] =
{
	"hardware-cursor",
	"software-cursor",
	0
};
static const enum s3_options_cursor_type s3_options_cursor_type_index_to_value[] =
{
	S3_OPTIONS_CURSOR_TYPE_HARDWARE_CURSOR,
	S3_OPTIONS_CURSOR_TYPE_SOFTWARE_CURSOR,
	s3_options_cursor_type_end_enumeration
};
static const char *const s3_options_monitor_sync_type_keywords[] =
{
	"composite-sync",
	"sync-on-green",
	"separate-sync",
	0
};
static const enum s3_options_monitor_sync_type s3_options_monitor_sync_type_index_to_value[] =
{
	S3_OPTIONS_MONITOR_SYNC_TYPE_COMPOSITE_SYNC,
	S3_OPTIONS_MONITOR_SYNC_TYPE_SYNC_ON_GREEN,
	S3_OPTIONS_MONITOR_SYNC_TYPE_SEPARATE_SYNC,
	s3_options_monitor_sync_type_end_enumeration
};
static const char *const s3_options_vsync_polarity_keywords[] =
{
	"positive",
	"negative",
	"default",
	0
};
static const enum s3_options_vsync_polarity s3_options_vsync_polarity_index_to_value[] =
{
	S3_OPTIONS_VSYNC_POLARITY_POSITIVE,
	S3_OPTIONS_VSYNC_POLARITY_NEGATIVE,
	S3_OPTIONS_VSYNC_POLARITY_DEFAULT,
	s3_options_vsync_polarity_end_enumeration
};
static const char *const s3_options_hsync_polarity_keywords[] =
{
	"positive",
	"negative",
	"default",
	0
};
static const enum s3_options_hsync_polarity s3_options_hsync_polarity_index_to_value[] =
{
	S3_OPTIONS_HSYNC_POLARITY_POSITIVE,
	S3_OPTIONS_HSYNC_POLARITY_NEGATIVE,
	S3_OPTIONS_HSYNC_POLARITY_DEFAULT,
	s3_options_hsync_polarity_end_enumeration
};
static const char *const s3_options_wait_state_control_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_wait_state_control s3_options_wait_state_control_index_to_value[] =
{
	S3_OPTIONS_WAIT_STATE_CONTROL_YES,
	S3_OPTIONS_WAIT_STATE_CONTROL_NO,
	s3_options_wait_state_control_end_enumeration
};
static const char *const s3_options_enable_write_posting_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_write_posting s3_options_enable_write_posting_index_to_value[] =
{
	S3_OPTIONS_ENABLE_WRITE_POSTING_YES,
	S3_OPTIONS_ENABLE_WRITE_POSTING_NO,
	s3_options_enable_write_posting_end_enumeration
};
static const char *const s3_options_enable_eprom_write_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_eprom_write s3_options_enable_eprom_write_index_to_value[] =
{
	S3_OPTIONS_ENABLE_EPROM_WRITE_YES,
	S3_OPTIONS_ENABLE_EPROM_WRITE_NO,
	s3_options_enable_eprom_write_end_enumeration
};
static const char *const s3_options_enable_split_transfers_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_split_transfers s3_options_enable_split_transfers_index_to_value[] =
{
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_YES,
	S3_OPTIONS_ENABLE_SPLIT_TRANSFERS_NO,
	s3_options_enable_split_transfers_end_enumeration
};
static const char *const s3_options_enable_nibble_swap_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_nibble_swap s3_options_enable_nibble_swap_index_to_value[] =
{
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_YES,
	S3_OPTIONS_ENABLE_NIBBLE_SWAP_NO,
	s3_options_enable_nibble_swap_end_enumeration
};
static const char *const s3_options_enable_nibble_write_control_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_nibble_write_control s3_options_enable_nibble_write_control_index_to_value[] =
{
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_YES,
	S3_OPTIONS_ENABLE_NIBBLE_WRITE_CONTROL_NO,
	s3_options_enable_nibble_write_control_end_enumeration
};
static const char *const s3_options_vram_addressing_mode_keywords[] =
{
	"parallel",
	"serial",
	0
};
static const enum s3_options_vram_addressing_mode s3_options_vram_addressing_mode_index_to_value[] =
{
	S3_OPTIONS_VRAM_ADDRESSING_MODE_PARALLEL,
	S3_OPTIONS_VRAM_ADDRESSING_MODE_SERIAL,
	s3_options_vram_addressing_mode_end_enumeration
};
static const char *const s3_options_limit_write_posting_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_limit_write_posting s3_options_limit_write_posting_index_to_value[] =
{
	S3_OPTIONS_LIMIT_WRITE_POSTING_YES,
	S3_OPTIONS_LIMIT_WRITE_POSTING_NO,
	s3_options_limit_write_posting_end_enumeration
};
static const char *const s3_options_enable_read_ahead_cache_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_read_ahead_cache s3_options_enable_read_ahead_cache_index_to_value[] =
{
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_YES,
	S3_OPTIONS_ENABLE_READ_AHEAD_CACHE_NO,
	s3_options_enable_read_ahead_cache_end_enumeration
};
static const char *const s3_options_latch_isa_addr_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_latch_isa_addr s3_options_latch_isa_addr_index_to_value[] =
{
	S3_OPTIONS_LATCH_ISA_ADDR_YES,
	S3_OPTIONS_LATCH_ISA_ADDR_NO,
	s3_options_latch_isa_addr_end_enumeration
};
static const char *const s3_options_serial_access_mode_control_keywords[] =
{
	"512",
	"256",
	0
};
static const enum s3_options_serial_access_mode_control s3_options_serial_access_mode_control_index_to_value[] =
{
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_512,
	S3_OPTIONS_SERIAL_ACCESS_MODE_CONTROL_256,
	s3_options_serial_access_mode_control_end_enumeration
};
static const char *const s3_options_ras_m_clk_keywords[] =
{
	"7",
	"6",
	0
};
static const enum s3_options_ras_m_clk s3_options_ras_m_clk_index_to_value[] =
{
	S3_OPTIONS_RAS_M_CLK_7,
	S3_OPTIONS_RAS_M_CLK_6,
	s3_options_ras_m_clk_end_enumeration
};
static const char *const s3_options_memory_and_register_access_mode_keywords[] =
{
	"io-access",
	"mmio-read-enhanced-regs",
	"mmio-write-enhanced-regs",
	"mmio-read-pixtrans",
	"mmio-write-pixtrans",
	"lfb-access",
	0
};
static const int s3_options_memory_and_register_access_mode_index_to_value[] =
{
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_IO_ACCESS,
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_READ_ENHANCED_REGS,
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_WRITE_ENHANCED_REGS,
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_READ_PIXTRANS,
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_MMIO_WRITE_PIXTRANS,
	S3_OPTIONS_MEMORY_AND_REGISTER_ACCESS_MODE_LFB_ACCESS,
	-1
};
static const char *const s3_options_use_save_unders_keywords[] =
{
	"no",
	"yes",
	0
};
static const enum s3_options_use_save_unders s3_options_use_save_unders_index_to_value[] =
{
	S3_OPTIONS_USE_SAVE_UNDERS_NO,
	S3_OPTIONS_USE_SAVE_UNDERS_YES,
	s3_options_use_save_unders_end_enumeration
};
static const char *const s3_options_chipset_name_keywords[] =
{
	"86C801",
	"86C911",
	"86C924",
	"86C928",
	"86C928-PCI",
	"auto-detect",
	0
};
static const enum s3_options_chipset_name s3_options_chipset_name_index_to_value[] =
{
	S3_OPTIONS_CHIPSET_NAME_86C801,
	S3_OPTIONS_CHIPSET_NAME_86C911,
	S3_OPTIONS_CHIPSET_NAME_86C924,
	S3_OPTIONS_CHIPSET_NAME_86C928,
	S3_OPTIONS_CHIPSET_NAME_86C928_PCI,
	S3_OPTIONS_CHIPSET_NAME_AUTO_DETECT,
	s3_options_chipset_name_end_enumeration
};
static const char *const s3_options_stepping_number_keywords[] =
{
	"a-step",
	"b-step",
	"c-step",
	"d-step",
	"e-step",
	"g-step",
	"auto-detect",
	0
};
static const enum s3_options_stepping_number s3_options_stepping_number_index_to_value[] =
{
	S3_OPTIONS_STEPPING_NUMBER_A_STEP,
	S3_OPTIONS_STEPPING_NUMBER_B_STEP,
	S3_OPTIONS_STEPPING_NUMBER_C_STEP,
	S3_OPTIONS_STEPPING_NUMBER_D_STEP,
	S3_OPTIONS_STEPPING_NUMBER_E_STEP,
	S3_OPTIONS_STEPPING_NUMBER_G_STEP,
	S3_OPTIONS_STEPPING_NUMBER_AUTO_DETECT,
	s3_options_stepping_number_end_enumeration
};
static const char *const s3_options_clock_chip_name_keywords[] =
{
	"approximate-values",
	"chrontel-ch9204b",
	"chrontel-ch9204c",
	"icd-2061",
	"icd-2061a",
	"av9194-56",
	"av9194-07",
	"av9194-11",
	"chrontel-ch9294g",
	"ti-3025",
	"unknown",
	0
};
static const enum s3_options_clock_chip_name s3_options_clock_chip_name_index_to_value[] =
{
	S3_OPTIONS_CLOCK_CHIP_NAME_APPROXIMATE_VALUES,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9204B,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9204C,
	S3_OPTIONS_CLOCK_CHIP_NAME_ICD_2061,
	S3_OPTIONS_CLOCK_CHIP_NAME_ICD_2061A,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_56,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_07,
	S3_OPTIONS_CLOCK_CHIP_NAME_AV9194_11,
	S3_OPTIONS_CLOCK_CHIP_NAME_CHRONTEL_CH9294G,
	S3_OPTIONS_CLOCK_CHIP_NAME_TI_3025,
	S3_OPTIONS_CLOCK_CHIP_NAME_UNKNOWN,
	s3_options_clock_chip_name_end_enumeration
};
static const char *const s3_options_s3_bus_width_keywords[] =
{
	"16-bit",
	"8-bit",
	0
};
static const enum s3_options_s3_bus_width s3_options_s3_bus_width_index_to_value[] =
{
	S3_OPTIONS_S3_BUS_WIDTH_16_BIT,
	S3_OPTIONS_S3_BUS_WIDTH_8_BIT,
	s3_options_s3_bus_width_end_enumeration
};
static const char *const s3_options_fast_rmw_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_fast_rmw s3_options_fast_rmw_index_to_value[] =
{
	S3_OPTIONS_FAST_RMW_YES,
	S3_OPTIONS_FAST_RMW_NO,
	s3_options_fast_rmw_end_enumeration
};
static const char *const s3_options_enable_alternate_ioport_address_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_enable_alternate_ioport_address s3_options_enable_alternate_ioport_address_index_to_value[] =
{
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_YES,
	S3_OPTIONS_ENABLE_ALTERNATE_IOPORT_ADDRESS_NO,
	s3_options_enable_alternate_ioport_address_end_enumeration
};
static const char *const s3_options_dac_name_keywords[] =
{
	"att20c491",
	"sc15025",
	"sc11481-6-2-3",
	"sc11485-7",
	"sc11484-8",
	"sc11489",
	"sc11471-6",
	"sc11478",
	"imsg171",
	"imsg176",
	"imsg178",
	"bt471-6",
	"bt478",
	"Bt485KPJ110",
	"Bt485KPJ135",
	"w82c478",
	"w82c476",
	"w82c490",
	"tr9c1710",
	"att20c490",
	"ss2410",
	"ti3020",
	"ti3025",
	"unknown-dac",
	0
};
static const enum s3_options_dac_name s3_options_dac_name_index_to_value[] =
{
	S3_OPTIONS_DAC_NAME_ATT20C491,
	S3_OPTIONS_DAC_NAME_SC15025,
	S3_OPTIONS_DAC_NAME_SC11481_6_2_3,
	S3_OPTIONS_DAC_NAME_SC11485_7,
	S3_OPTIONS_DAC_NAME_SC11484_8,
	S3_OPTIONS_DAC_NAME_SC11489,
	S3_OPTIONS_DAC_NAME_SC11471_6,
	S3_OPTIONS_DAC_NAME_SC11478,
	S3_OPTIONS_DAC_NAME_IMSG171,
	S3_OPTIONS_DAC_NAME_IMSG176,
	S3_OPTIONS_DAC_NAME_IMSG178,
	S3_OPTIONS_DAC_NAME_BT471_6,
	S3_OPTIONS_DAC_NAME_BT478,
	S3_OPTIONS_DAC_NAME_BT485KPJ110,
	S3_OPTIONS_DAC_NAME_BT485KPJ135,
	S3_OPTIONS_DAC_NAME_W82C478,
	S3_OPTIONS_DAC_NAME_W82C476,
	S3_OPTIONS_DAC_NAME_W82C490,
	S3_OPTIONS_DAC_NAME_TR9C1710,
	S3_OPTIONS_DAC_NAME_ATT20C490,
	S3_OPTIONS_DAC_NAME_SS2410,
	S3_OPTIONS_DAC_NAME_TI3020,
	S3_OPTIONS_DAC_NAME_TI3025,
	S3_OPTIONS_DAC_NAME_UNKNOWN_DAC,
	s3_options_dac_name_end_enumeration
};
static const char *const s3_options_use_clock_doubler_keywords[] =
{
	"no",
	"auto-configure",
	0
};
static const enum s3_options_use_clock_doubler s3_options_use_clock_doubler_index_to_value[] =
{
	S3_OPTIONS_USE_CLOCK_DOUBLER_NO,
	S3_OPTIONS_USE_CLOCK_DOUBLER_AUTO_CONFIGURE,
	s3_options_use_clock_doubler_end_enumeration
};
static const char *const s3_options_use_dac_external_sid_mode_keywords[] =
{
	"no",
	"auto-configure",
	0
};
static const enum s3_options_use_dac_external_sid_mode s3_options_use_dac_external_sid_mode_index_to_value[] =
{
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_NO,
	S3_OPTIONS_USE_DAC_EXTERNAL_SID_MODE_AUTO_CONFIGURE,
	s3_options_use_dac_external_sid_mode_end_enumeration
};
static const char *const s3_options_dac_rgb_width_keywords[] =
{
	"6",
	"8",
	"default",
	0
};
static const enum s3_options_dac_rgb_width s3_options_dac_rgb_width_index_to_value[] =
{
	S3_OPTIONS_DAC_RGB_WIDTH_6,
	S3_OPTIONS_DAC_RGB_WIDTH_8,
	S3_OPTIONS_DAC_RGB_WIDTH_DEFAULT,
	s3_options_dac_rgb_width_end_enumeration
};
static const char *const s3_options_dac_24_bit_color_mode_keywords[] =
{
	"rgba",
	"abgr",
	0
};
static const enum s3_options_dac_24_bit_color_mode s3_options_dac_24_bit_color_mode_index_to_value[] =
{
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	S3_OPTIONS_DAC_24_BIT_COLOR_MODE_ABGR,
	s3_options_dac_24_bit_color_mode_end_enumeration
};
static const char *const s3_options_dac_16_bit_color_mode_keywords[] =
{
	"555",
	"565",
	"655",
	"664",
	0
};
static const enum s3_options_dac_16_bit_color_mode s3_options_dac_16_bit_color_mode_index_to_value[] =
{
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_565,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_655,
	S3_OPTIONS_DAC_16_BIT_COLOR_MODE_664,
	s3_options_dac_16_bit_color_mode_end_enumeration
};
static const char *const s3_options_screen_8_4_bit_visual_list_keywords[] =
{
	"static-gray",
	"gray-scale",
	"static-color",
	"pseudo-color",
	"true-color",
	"direct-color",
	0
};
static const int s3_options_screen_8_4_bit_visual_list_index_to_value[] =
{
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_STATIC_GRAY,
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_GRAY_SCALE,
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_STATIC_COLOR,
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_PSEUDO_COLOR,
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_TRUE_COLOR,
	S3_OPTIONS_SCREEN_8_4_BIT_VISUAL_LIST_DIRECT_COLOR,
	-1
};
static const char *const s3_options_rectfill_options_keywords[] =
{
	"use-solid-fill-rect",
	"use-tile-fill-rect",
	"use-stipple-fill-rect",
	"use-ge-patfill",
	"use-offscreen-memory",
	"reduce-stipples",
	"reduce-tiles",
	"none",
	0
};
static const int s3_options_rectfill_options_index_to_value[] =
{
	S3_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT,
	S3_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT,
	S3_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT,
	S3_OPTIONS_RECTFILL_OPTIONS_USE_GE_PATFILL,
	S3_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY,
	S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_STIPPLES,
	S3_OPTIONS_RECTFILL_OPTIONS_REDUCE_TILES,
	S3_OPTIONS_RECTFILL_OPTIONS_NONE,
	-1
};
static const char *const s3_options_bitblt_options_keywords[] =
{
	"use-ss-bitblt",
	"use-ms-bitblt",
	"use-sm-bitblt",
	"use-ms-stplblt",
	"none",
	0
};
static const int s3_options_bitblt_options_index_to_value[] =
{
	S3_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT,
	S3_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT,
	S3_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT,
	S3_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT,
	S3_OPTIONS_BITBLT_OPTIONS_NONE,
	-1
};
static const char *const s3_options_linedraw_options_keywords[] =
{
	"use-line-draw",
	"use-line-rectangles",
	"use-segment-draw",
	"use-dashed-line",
	"none",
	0
};
static const int s3_options_linedraw_options_index_to_value[] =
{
	S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW,
	S3_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES,
	S3_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW,
	S3_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINE,
	S3_OPTIONS_LINEDRAW_OPTIONS_NONE,
	-1
};
static const char *const s3_options_spansfill_options_keywords[] =
{
	"use-solid-fill",
	"use-stipple-fill",
	"use-tile-fill",
	"use-ge-patfill",
	"use-offscreen-memory",
	"none",
	0
};
static const int s3_options_spansfill_options_index_to_value[] =
{
	S3_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL,
	S3_OPTIONS_SPANSFILL_OPTIONS_USE_STIPPLE_FILL,
	S3_OPTIONS_SPANSFILL_OPTIONS_USE_TILE_FILL,
	S3_OPTIONS_SPANSFILL_OPTIONS_USE_GE_PATFILL,
	S3_OPTIONS_SPANSFILL_OPTIONS_USE_OFFSCREEN_MEMORY,
	S3_OPTIONS_SPANSFILL_OPTIONS_NONE,
	-1
};
static const char *const s3_options_pointdraw_options_keywords[] =
{
	"use-plot-point",
	"none",
	0
};
static const int s3_options_pointdraw_options_index_to_value[] =
{
	S3_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT,
	S3_OPTIONS_POINTDRAW_OPTIONS_NONE,
	-1
};
static const char *const s3_options_fontdraw_options_keywords[] =
{
	"draw-non-terminal-fonts",
	"draw-terminal-fonts",
	"use-offscreen-memory",
	"assemble-glyphs",
	"none",
	0
};
static const int s3_options_fontdraw_options_index_to_value[] =
{
	S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_NON_TERMINAL_FONTS,
	S3_OPTIONS_FONTDRAW_OPTIONS_DRAW_TERMINAL_FONTS,
	S3_OPTIONS_FONTDRAW_OPTIONS_USE_OFFSCREEN_MEMORY,
	S3_OPTIONS_FONTDRAW_OPTIONS_ASSEMBLE_GLYPHS,
	S3_OPTIONS_FONTDRAW_OPTIONS_NONE,
	-1
};
static const char *const s3_options_override_ss_stippling_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum s3_options_override_ss_stippling s3_options_override_ss_stippling_index_to_value[] =
{
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_YES,
	S3_OPTIONS_OVERRIDE_SS_STIPPLING_NO,
	s3_options_override_ss_stippling_end_enumeration
};
static const char *const s3_options_arcdraw_options_keywords[] =
{
	"draw-one-bit-arcs",
	0
};
static const int s3_options_arcdraw_options_index_to_value[] =
{
	S3_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS,
	-1
};


/*
 * Help message.
 */
static const char *const s3_options_description = 
"si-interface-version\tThe version number that the SDD returns to the SI server.\n"
"verbose-startup\tPrint messages about chipset configuration if set to 1.\n"
"cursor-type\tCursor implementation types.\n"
"cursor-max-size\tMaximum size of a cursor in WxH.\n"
"number-of-downloadable-cursors\tNumber of downloaded hardware cursors.  `0' means use internal default.\n"
"number-of-downloadable-fonts\tNumber of downloaded fonts.  `0' means to turn off font handling in the SDD.\n"
"max-number-of-glyphs-in-downloadable-font\tThe maximum number of glyphs in a font suitable for downloading.  0 means ignore this criterion.\n"
"max-fully-cacheable-font-size\tIf the total size of the font's glyphs is below this value, we will download all its glyphs into offscreen memory at font download time.  If the size exceeds this value, caching of glyphs will occur as and when the glyph is first used, provided there is sufficient offscreen space.\n"
"vt-switch-save-lines\tNumber of lines of screen to save.  Exact values would save the total memory occupied by the x server.\n"
"number-of-graphics-states\tNumber of SDD graphics states.  `0' means use internal default.\n"
"tile-best-size\tBest tile size as seen by the Si code\n"
"stipple-best-size\tBest stipple size as seen by si code.\n"
"offscreen-tile-padded-width\tPad small tiles to this value in offscreen memory.  Should be a power of two.\n"
"offscreen-tile-padded-height\tPad small tiles to this value in offscreen memory.  Should be a power of two.\n"
"offscreen-stipple-padded-width\tPad small stipples to this value in offscreen memory.  Should be a power of two.\n"
"offscreen-stipple-padded-height\tPad small stipples to this value in offscreen memory.\n"
"maximum-offscreen-downloadable-bitmap-width\tDo not download tiles/stipples of more than this width into offscreen memory\n"
"maximum-offscreen-downloadable-bitmap-height\tDo not download tiles/stipples of more than this height into offscreen memory\n"
"bitmap-reduction-threshold\tStipples/tiles with width/height more then this value will not be considered for reduction to 8x8\n"
"glyph-cache-size\tCache glyphs smaller than this size in offscreen memory\n"
"arc-cache-size\tThe number of arcs to cache in the display library\n"
"crtc-start-offset\tOffset of start of display memory.\n"
"crtc-parameters\tCRTC parameters in hexadecimal : h-total h-disp-end h-blank-start h-blank-end h-sync-start h-sync-end v-total v-retrace-start v-retrace-end v-display-end v-blank-start v-blank-end preset-row-scan max-scan-line logical-screen-offset clock-frequency interlace_retrace_start crtc_mode-control line-compare num-screen-pages physical_width physical_height\n"
"modedb-string\tModeDB entry in the following format: \"Clock HorizontalTiming VerticalTiming Flags\".  Clock is in MHz.  The Timing field consists of Display, SyncStart, SyncEnd and Total timings in that order.  Flags field may or may not be present.  The two options modedb-string and crtc-parameters are mutually exclusive.  However, if both are present, this option takes higher priority.  Depths of 4bpp and 8bpp only are supported.  Supported video memory sizes are 1, 2, 3 and 4MB.\n"
"display-skew\tAmount of display enable skew.  Bits 5,6 in CR3\n"
"horizontal-skew\tAmount of horizontal skew.  Bits 5,6 in CR5\n"
"monitor-sync-type\tThe monitor's SYNC type.\n"
"vsync-polarity\tThe polarity of the v-sync pulse.  Actually monitor dependent.  But most monitors could handle either case.\n"
"hsync-polarity\tThe polarity of the h-sync pulse.  Actually monitor dependent.  But most monitors could handle either case.\n"
"omm-named-allocation-list\tNamed allocation requests for the offscreen memory manager.\n"
"omm-horizontal-constraint\tThe widths of all offscreen memory requests are rounded up to this value.  O means use an internal heuristic.\n"
"omm-vertical-constraint\tThe heights of all offscreen memory requests are rounded up to this value.  0 implies internal default.\n"
"omm-neighbour-list-increment\tNumber of neighbour list nodes allocated at one time.  Neighbour lists are managed during every allocate and free operation.  0 implies an internal default.\n"
"omm-full-coalesce-watermark\tIf the number of currently allocated blocks falls below this value the omm will attempt a full coalesion operation.  Remember that coalesion is an expensive operation.\n"
"omm-hash-list-size\tSize of the hash table of omm free blocks.  0 implies an internal default.\n"
"register-values-string\tThis option provides a general way of programming crtc registers of the chipset.  Format of the string is as follows \"index mask value rbits, index mask value rbits , ...\" Each 4-tuple is comma seperated.  No range value checking is done.  The meanings of index,mask,value,rbits are : index - register index to program ( like crtc registers) mask,value - value bits corresponding to a 1 in the mask will be programmed.  rbits - bit positions with a 1 in rbits are treated as reserved bits.  ( a 0 will be written).\n"
"wait-state-control\tWait state Control.  yes = 1 waitstate, no = no waitstate\n"
"enable-write-posting\tEnable fast write buffer, write posting into the fifo.\n"
"decode-wait-control\tDecode Wait Control for 386/486 Local buses.\n"
"read-wait-control\tThis option on a 386/486 local bus denotes read wait control.  On an ISA bus controls enabling of the NOWS-bar signal.  Any value other than 0 on an isa bus will disable nows-bar signal.\n"
"enable-eprom-write\tEnable/diable flash memory write control to the BIOS ROM address.\n"
"enable-split-transfers\tSplit transfers enabled/disabled\n"
"enable-nibble-swap\tSwap nibbles in each byte of a linear memory address read or write operation.\n"
"enable-nibble-write-control\tenable nibble write control for the graphics engine.\n"
"vram-addressing-mode\tParallel or serial vram addressing mode.\n"
"rac-extra-prefetch\tRead ahead cache extra prefetch control.Only meaningful values are 1 3 and 7.\n"
"limit-write-posting\tspecifies if write-post entry depth will be limited to avoid isa bus time out due to wait cycle limit.  Choosing no denotes normal write-post entry control (9)\n"
"enable-read-ahead-cache\twhether to enable or disable the read ahead cache\n"
"latch-isa-addr\twhether to latch the isa address on every cycle , choosing no specifies unlatch isa address on every cycle.\n"
"serial-access-mode-control\tSerial Access Mode 256 words control.\n"
"ras-m-clk\tRAS MCLK cycles for random read/write cycle time\n"
"memory-and-register-access-mode\tSpecification for the type of memory and register access on the S3 card.  Recemmended not mix mmio and lfb.  mmio-read- options are not supported by the 801/928 till the E steps.\n"
"linear-frame-buffer-size\tSize in MB of linear frame buffer aperture.\n"
"use-save-unders\tImplement save-unders in the SDD if `yes'.\n"
"chipset-name\tThe type of accelarator.\n"
"stepping-number\tThe stepping number on the chipset.\n"
"clock-chip-name\tThe type of clock chip on the video board.  approximate values refer to the list given in the programmers guide.\n"
"s3-bus-width\tThe bus width as seen by the s3 chipset.(memory/system)\n"
"fast-rmw\twhether or not to permit a fast read modify write cycle.\n"
"enable-alternate-ioport-address\tThis option enables the user to choose the extended io ports to be mapped at x2e8 ^ 3a0 instead of x2e8h.  This would help in overcoming ioaddress space clashes.\n"
"graphics-engine-loop-timeout-count\tNumber of cycles to wait before signalling an error.\n"
"graphics-engine-micro-delay-count\tNumber of cycles spin-wait between register accesses.\n"
"crtc-sync-timeout-count\tNumber of cycles to wait for sync pulse to occour\n"
"dac-name\tThe type of DAC on board.\n"
"dac-max-frequency\tEvery dac has a maximum frequency to which it can operate without damaging itself/card/monitor.  This option allows overriding of the builtin default value for the dac.  A value of 0 (default) will use the builtin defaults.  UTMOST CAUTION SHOULD BE TAKEN WHILE CHANGING THIS OPTION.  Wrong use can damage your system.  The value is in Hz.\n"
"dac-external-sid-threshold\tFor dacs that have support for external serial input like the BT485 this specifies the threshold for enabling this mode as opposed to the standard mode.  A value of 0 (default) will use the builtin defaults.\n"
"clock-doubler-threshold\tThis option provides a way of specifying the threshold greater than which the clock doubler will be enabled for dacs that have an internal clock doubler.  A value of 0 indicates that builtin default threshold values have to be used.\n"
"use-clock-doubler\tControls whether to use the clock doubler, if any.  If a clock doubler is present and the clock frequency is more than the thereshold specified, the clock doubler will be used by default.\n"
"use-dac-external-sid-mode\tControls whether to use the dac's external sid mode capability, if any.  If the dac has this capability and the clock frequency used exceeds the thereshold specified, this capability will be used by default.\n"
"dac-access-delay-count\tNumber of cycles to wait between dac accesses.\n"
"dac-rgb-width\tNumber of significant bits per R/G/B output.  `default' will use the industry standard of 6.\n"
"dac-24-bit-color-mode\tOrder of R/G/B pixels in a 32 bit word.\n"
"dac-16-bit-color-mode\tBits for R/G/B in 16 bit mode.\n"
"screen-8-4-bit-visual-list\tSupported display visuals in addition to the screen default visual specified in the server config file.  Caveat : the core server does not seem to handle multiple visuals per screen yet ...\n"
"graphics-engine-fifo-blocking-factor\tNumber of fifo entries to wait for by default.\n"
"rectfill-options\tControlling fill functionality.\n"
"bitblt-options\tControlling fill functionality.\n"
"linedraw-options\tControlling line draw functionality.\n"
"spansfill-options\tControlling spans fill functionality.\n"
"pointdraw-options\tControlling plot point functionality.\n"
"fontdraw-options\tControlling the kinds of fonts the display library should handle, and whether we should attempt to download fonts into offscreen memory.\n"
"override-ss-stippling\tSome 928 cards seem to have some problems with screen to screen stippling with the rop set to GXinvert or Gxclear/set.  This option enables this functionality to be overridden with s/w methods ( though slow).\n"
"arcdraw-options\tControls the drawing operation for arcs.\n"
;

/*
 * Lookup a name in a table.
 */
static int
s3_options_lookup_name(const char *name_p, const char *const *name_list_p)
{
	int name_index = 0;
	
	while (*name_list_p)
	{
		if (strcmp(*name_list_p, name_p))
		{
			name_index ++;
			name_list_p ++;
		}
		else
		{

#if (defined(__DEBUG__))
			if(s3_options_debug)
			{
				(void) fprintf(debug_stream_p,
						"(s3_options_ lookup) \"%s\" "
						"index = %d.\n", name_p, name_index);
					
			}
#endif
			return name_index;
			
		}
	}
	return -1;
	
}

/*
 * Get the next token.
 */

static char * 
s3_options_parse_get_next_token(char *character_p)
{
	/* CONSTANTCONDITION */
	while (1)
	{
		/*
		 * Skip leading WS.
		 */
		while( (*character_p != EOS) && isspace(*character_p))
		{
			character_p ++;
		}
		if (*character_p == EOS)
		{
			break;
		}
		else if(*character_p == '#')
		{
			/*
			 * Comment.  Skip till new line.
			 */
			while ((*character_p != EOS) && (*character_p != '\n'))
			{
				character_p ++;
			}
		}
		else if (*character_p == '\\')
		{
			*character_p ++ = ' ';	/* replace '\' */
			*character_p = (*character_p == '\n') ? ' ' : *character_p;
		}
		else
		{
			return character_p;
		}
	}
	return (char *) 0;
}		

/*
 * s3_options_parse : parse options.
 */
function struct s3_options_structure *
s3_options_parse (struct s3_options_structure *option_struct_p,
			   const char *option_string_p)
{
	char * character_p;
	char * option_check_integer_p; /* return value of strtol() */
	struct stat stat_buf;
	
	char *option_list_p;		/* modifiable copy of option list */
	int option_name_index;		/* option keyword index */
	int option_enum_index;		/* enumeration value index */
	int option_enum_is_inverted; /* for !<value> parsing */
	
	char *tmp_p;				/* temporary */
	char *option_name_p, *option_value_p; /* for separating name=value */
	FILE *option_file_p;
	
	
	if (!option_struct_p)
	{
		option_struct_p = allocate_memory(sizeof (struct
												  s3_options_structure));
		if (!option_struct_p)
		{
			perror(DEFAULT_OPTION_CANNOT_ALLOCATE_MEMORY_MESSAGE);
			goto error;
			
		}
		
		/*
		 * Copy the defaults.
		 */
		*option_struct_p = s3_options_default;
		
	}

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) "
				"option_string = \"%s\"\n", option_string_p);
	}
#endif

	/*
	 * Save the option string as we are going to munge it.
	 */
	option_list_p = strdup(option_string_p);
	
	character_p =
		s3_options_parse_get_next_token(option_list_p);
	
	while(character_p)
	{
		/*
		 * parse the token, looking for name'='value pairs.
		 */
		option_name_p = character_p;
		while ((*character_p != EOS) && 
			   (*character_p != '='))
		{
			character_p ++;
		}
		if (*character_p != '=')
		{
			/*
			 * Error encountered.
			 */
			(void) fprintf(stderr, 
						   DEFAULT_OPTION_MALFORMED_OPTION_STRING_MESSAGE,
						   option_name_p);
			
			free_memory(option_list_p);
			return (struct s3_options_structure *) 0;
			
		}
		else
		{
			*character_p++ = EOS;
			if (*character_p == EOS)
			{
				/*
				 * Error encountered.
				 */
				(void) fprintf(stderr, 
							   DEFAULT_OPTION_MALFORMED_OPTION_STRING_MESSAGE,
							   option_name_p);
			
				free_memory(option_list_p);
				return (struct s3_options_structure *) 0;
				
			}
			/*
			 * Look for terminating white-space.
			 */
			if (*character_p == '\"')
			{
				/*
				 * Terminated by a '\"'.
				 */
				*character_p ++ = EOS;
				option_value_p = character_p;
				
				while ((*character_p != EOS) && 
					   (*character_p != '\"'))
				{
					character_p ++;
				}
				if (*character_p == EOS)
				{
					(void) fprintf(stderr,
						DEFAULT_OPTION_UNTERMINATED_STRING_CONSTANT_MESSAGE,
								   option_name_p);
					free_memory (option_list_p);
					return (struct s3_options_structure *) 0;
				}
				else
				{
					*character_p ++ = EOS;
				}
			}
			else
			{
				/*
				 * White space terminated.
				 */
				option_value_p = character_p;

				/* CONSTANTCONDITION */
				while (1)
				{
					
					while ( (*character_p != EOS) && ! isspace(*character_p))
					{
						character_p ++;
					}
			
					if (*character_p != EOS)
					{

						if (*character_p == '\n' && *(character_p-1) == '\\')
						{
							/*
							 * Skip backslashed newline.
							 */
							character_p ++;
						}
						else
						{
							*character_p++ = EOS;
							break;
						}
					}
					else
					{
						break;
					}

				}			
			}
		}

		/*
		 * Analyze the option name and option value extracted.
		 */
		option_name_index =
			s3_options_lookup_name(option_name_p, &(s3_options_keywords[0]));
				
		if (option_name_index == -1)
		{
			(void) fprintf(stderr,
					DEFAULT_OPTION_UNRECOGNIZED_OPTION_MESSAGE,
					option_name_p);
			free_memory (option_list_p);
			return (struct s3_options_structure *) 0;
		}
#if (defined(__DEBUG__))
		else
		{
			if (s3_options_debug)
			{
				(void) fprintf(debug_stream_p,
						"(s3_options_parse) recognized "
						"\"%s\" of type \"%s\", value "
						"\"%s\".\n", 
						option_name_p,
						option_type_dump[option_index_to_option_kind[option_name_index]],
						option_value_p);
				
			}
		}
#endif
	
		/*
		 * Depending on the kind of code, take action.
		 */
		switch (option_name_index)
		{

			

case 0 :	/* arc-cache-size */
	option_struct_p->arc_cache_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->arc_cache_size == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"arc-cache-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	arc-cache-size = %d\n",
				option_struct_p->arc_cache_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->arc_cache_size >= 0) && (option_struct_p->arc_cache_size <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"arc-cache-size");
		goto error;
	}

	break;

case 1 :	/* arcdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_arcdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "arcdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->arcdraw_options &= 
				(~s3_options_arcdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->arcdraw_options |= 
				(s3_options_arcdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum arcdraw-options value %d.\n",
			option_struct_p->arcdraw_options);
	}
#endif

	break;

case 2 :	/* bitblt-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_bitblt_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "bitblt-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->bitblt_options &= 
				(~s3_options_bitblt_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->bitblt_options |= 
				(s3_options_bitblt_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum bitblt-options value %d.\n",
			option_struct_p->bitblt_options);
	}
#endif

	break;


case 3 :	/* bitmap-reduction-threshold */
	option_struct_p->bitmap_reduction_threshold = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->bitmap_reduction_threshold == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"bitmap-reduction-threshold");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	bitmap-reduction-threshold = %d\n",
				option_struct_p->bitmap_reduction_threshold);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->bitmap_reduction_threshold >= 1) && (option_struct_p->bitmap_reduction_threshold <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"bitmap-reduction-threshold");
		goto error;
	}

	break;

case 4 :	/* chipset-name */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_chipset_name_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "chipset-name");
		goto error;
	}
	option_struct_p->chipset_name = s3_options_chipset_name_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum chipset-name value '%s'\n",
			s3_options_chipset_name_keywords[option_enum_index]);
	}
#endif
	break;

case 5 :	/* clock-chip-name */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_clock_chip_name_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "clock-chip-name");
		goto error;
	}
	option_struct_p->clock_chip_name = s3_options_clock_chip_name_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum clock-chip-name value '%s'\n",
			s3_options_clock_chip_name_keywords[option_enum_index]);
	}
#endif
	break;


case 6 :	/* clock-doubler-threshold */
	option_struct_p->clock_doubler_threshold = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->clock_doubler_threshold == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"clock-doubler-threshold");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	clock-doubler-threshold = %d\n",
				option_struct_p->clock_doubler_threshold);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->clock_doubler_threshold >= 0) && (option_struct_p->clock_doubler_threshold <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"clock-doubler-threshold");
		goto error;
	}

	break;

case 7 :	/* crtc-parameters */
	option_struct_p->crtc_parameters = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	crtc-parameters = \"%s\"\n",
			option_struct_p->crtc_parameters);
	}
#endif

	break;


case 8 :	/* crtc-start-offset */
	option_struct_p->crtc_start_offset = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->crtc_start_offset == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"crtc-start-offset");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	crtc-start-offset = %d\n",
				option_struct_p->crtc_start_offset);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->crtc_start_offset >= 0) && (option_struct_p->crtc_start_offset <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"crtc-start-offset");
		goto error;
	}

	break;


case 9 :	/* crtc-sync-timeout-count */
	option_struct_p->crtc_sync_timeout_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->crtc_sync_timeout_count == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"crtc-sync-timeout-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	crtc-sync-timeout-count = %d\n",
				option_struct_p->crtc_sync_timeout_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->crtc_sync_timeout_count >= 1) && (option_struct_p->crtc_sync_timeout_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"crtc-sync-timeout-count");
		goto error;
	}

	break;

case 10 :	/* cursor-max-size */
	option_struct_p->cursor_max_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	cursor-max-size = \"%s\"\n",
			option_struct_p->cursor_max_size);
	}
#endif

	break;

case 11 :	/* cursor-type */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_cursor_type_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "cursor-type");
		goto error;
	}
	option_struct_p->cursor_type = s3_options_cursor_type_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum cursor-type value '%s'\n",
			s3_options_cursor_type_keywords[option_enum_index]);
	}
#endif
	break;

case 12 :	/* dac-16-bit-color-mode */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_dac_16_bit_color_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "dac-16-bit-color-mode");
		goto error;
	}
	option_struct_p->dac_16_bit_color_mode = s3_options_dac_16_bit_color_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum dac-16-bit-color-mode value '%s'\n",
			s3_options_dac_16_bit_color_mode_keywords[option_enum_index]);
	}
#endif
	break;

case 13 :	/* dac-24-bit-color-mode */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_dac_24_bit_color_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "dac-24-bit-color-mode");
		goto error;
	}
	option_struct_p->dac_24_bit_color_mode = s3_options_dac_24_bit_color_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum dac-24-bit-color-mode value '%s'\n",
			s3_options_dac_24_bit_color_mode_keywords[option_enum_index]);
	}
#endif
	break;


case 14 :	/* dac-access-delay-count */
	option_struct_p->dac_access_delay_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dac_access_delay_count == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"dac-access-delay-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-access-delay-count = %d\n",
				option_struct_p->dac_access_delay_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dac_access_delay_count >= 1) && (option_struct_p->dac_access_delay_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"dac-access-delay-count");
		goto error;
	}

	break;


case 15 :	/* dac-external-sid-threshold */
	option_struct_p->dac_external_sid_threshold = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dac_external_sid_threshold == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"dac-external-sid-threshold");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-external-sid-threshold = %d\n",
				option_struct_p->dac_external_sid_threshold);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dac_external_sid_threshold >= 0) && (option_struct_p->dac_external_sid_threshold <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"dac-external-sid-threshold");
		goto error;
	}

	break;


case 16 :	/* dac-max-frequency */
	option_struct_p->dac_max_frequency = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dac_max_frequency == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"dac-max-frequency");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-max-frequency = %d\n",
				option_struct_p->dac_max_frequency);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dac_max_frequency >= 0) && (option_struct_p->dac_max_frequency <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"dac-max-frequency");
		goto error;
	}

	break;

case 17 :	/* dac-name */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_dac_name_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "dac-name");
		goto error;
	}
	option_struct_p->dac_name = s3_options_dac_name_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum dac-name value '%s'\n",
			s3_options_dac_name_keywords[option_enum_index]);
	}
#endif
	break;

case 18 :	/* dac-rgb-width */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_dac_rgb_width_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "dac-rgb-width");
		goto error;
	}
	option_struct_p->dac_rgb_width = s3_options_dac_rgb_width_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum dac-rgb-width value '%s'\n",
			s3_options_dac_rgb_width_keywords[option_enum_index]);
	}
#endif
	break;


case 19 :	/* decode-wait-control */
	option_struct_p->decode_wait_control = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->decode_wait_control == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"decode-wait-control");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	decode-wait-control = %d\n",
				option_struct_p->decode_wait_control);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->decode_wait_control >= 0) && (option_struct_p->decode_wait_control <= 3)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"decode-wait-control");
		goto error;
	}

	break;


case 20 :	/* display-skew */
	option_struct_p->display_skew = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->display_skew == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"display-skew");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	display-skew = %d\n",
				option_struct_p->display_skew);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->display_skew >= 0) && (option_struct_p->display_skew <= 3)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"display-skew");
		goto error;
	}

	break;

case 21 :	/* enable-alternate-ioport-address */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_alternate_ioport_address_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-alternate-ioport-address");
		goto error;
	}
	option_struct_p->enable_alternate_ioport_address = s3_options_enable_alternate_ioport_address_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-alternate-ioport-address value '%s'\n",
			s3_options_enable_alternate_ioport_address_keywords[option_enum_index]);
	}
#endif
	break;

case 22 :	/* enable-eprom-write */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_eprom_write_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-eprom-write");
		goto error;
	}
	option_struct_p->enable_eprom_write = s3_options_enable_eprom_write_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-eprom-write value '%s'\n",
			s3_options_enable_eprom_write_keywords[option_enum_index]);
	}
#endif
	break;

case 23 :	/* enable-nibble-swap */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_nibble_swap_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-nibble-swap");
		goto error;
	}
	option_struct_p->enable_nibble_swap = s3_options_enable_nibble_swap_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-nibble-swap value '%s'\n",
			s3_options_enable_nibble_swap_keywords[option_enum_index]);
	}
#endif
	break;

case 24 :	/* enable-nibble-write-control */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_nibble_write_control_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-nibble-write-control");
		goto error;
	}
	option_struct_p->enable_nibble_write_control = s3_options_enable_nibble_write_control_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-nibble-write-control value '%s'\n",
			s3_options_enable_nibble_write_control_keywords[option_enum_index]);
	}
#endif
	break;

case 25 :	/* enable-read-ahead-cache */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_read_ahead_cache_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-read-ahead-cache");
		goto error;
	}
	option_struct_p->enable_read_ahead_cache = s3_options_enable_read_ahead_cache_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-read-ahead-cache value '%s'\n",
			s3_options_enable_read_ahead_cache_keywords[option_enum_index]);
	}
#endif
	break;

case 26 :	/* enable-split-transfers */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_split_transfers_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-split-transfers");
		goto error;
	}
	option_struct_p->enable_split_transfers = s3_options_enable_split_transfers_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-split-transfers value '%s'\n",
			s3_options_enable_split_transfers_keywords[option_enum_index]);
	}
#endif
	break;

case 27 :	/* enable-write-posting */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_enable_write_posting_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "enable-write-posting");
		goto error;
	}
	option_struct_p->enable_write_posting = s3_options_enable_write_posting_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum enable-write-posting value '%s'\n",
			s3_options_enable_write_posting_keywords[option_enum_index]);
	}
#endif
	break;

case 28 :	/* fast-rmw */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_fast_rmw_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "fast-rmw");
		goto error;
	}
	option_struct_p->fast_rmw = s3_options_fast_rmw_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum fast-rmw value '%s'\n",
			s3_options_fast_rmw_keywords[option_enum_index]);
	}
#endif
	break;

case 29 :	/* fontdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_fontdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "fontdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->fontdraw_options &= 
				(~s3_options_fontdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->fontdraw_options |= 
				(s3_options_fontdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum fontdraw-options value %d.\n",
			option_struct_p->fontdraw_options);
	}
#endif

	break;

case 30 :	/* glyph-cache-size */
	option_struct_p->glyph_cache_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	glyph-cache-size = \"%s\"\n",
			option_struct_p->glyph_cache_size);
	}
#endif

	break;


case 31 :	/* graphics-engine-fifo-blocking-factor */
	option_struct_p->graphics_engine_fifo_blocking_factor = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->graphics_engine_fifo_blocking_factor == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"graphics-engine-fifo-blocking-factor");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	graphics-engine-fifo-blocking-factor = %d\n",
				option_struct_p->graphics_engine_fifo_blocking_factor);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->graphics_engine_fifo_blocking_factor >= 1) && (option_struct_p->graphics_engine_fifo_blocking_factor <= 8)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"graphics-engine-fifo-blocking-factor");
		goto error;
	}

	break;


case 32 :	/* graphics-engine-loop-timeout-count */
	option_struct_p->graphics_engine_loop_timeout_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->graphics_engine_loop_timeout_count == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"graphics-engine-loop-timeout-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	graphics-engine-loop-timeout-count = %d\n",
				option_struct_p->graphics_engine_loop_timeout_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->graphics_engine_loop_timeout_count >= 1) && (option_struct_p->graphics_engine_loop_timeout_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"graphics-engine-loop-timeout-count");
		goto error;
	}

	break;


case 33 :	/* graphics-engine-micro-delay-count */
	option_struct_p->graphics_engine_micro_delay_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->graphics_engine_micro_delay_count == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"graphics-engine-micro-delay-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	graphics-engine-micro-delay-count = %d\n",
				option_struct_p->graphics_engine_micro_delay_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->graphics_engine_micro_delay_count >= 1) && (option_struct_p->graphics_engine_micro_delay_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"graphics-engine-micro-delay-count");
		goto error;
	}

	break;


case 34 :	/* horizontal-skew */
	option_struct_p->horizontal_skew = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->horizontal_skew == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"horizontal-skew");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	horizontal-skew = %d\n",
				option_struct_p->horizontal_skew);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->horizontal_skew >= 0) && (option_struct_p->horizontal_skew <= 3)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"horizontal-skew");
		goto error;
	}

	break;

case 35 :	/* hsync-polarity */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_hsync_polarity_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "hsync-polarity");
		goto error;
	}
	option_struct_p->hsync_polarity = s3_options_hsync_polarity_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum hsync-polarity value '%s'\n",
			s3_options_hsync_polarity_keywords[option_enum_index]);
	}
#endif
	break;

case 36 :	/* latch-isa-addr */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_latch_isa_addr_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "latch-isa-addr");
		goto error;
	}
	option_struct_p->latch_isa_addr = s3_options_latch_isa_addr_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum latch-isa-addr value '%s'\n",
			s3_options_latch_isa_addr_keywords[option_enum_index]);
	}
#endif
	break;

case 37 :	/* limit-write-posting */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_limit_write_posting_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "limit-write-posting");
		goto error;
	}
	option_struct_p->limit_write_posting = s3_options_limit_write_posting_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum limit-write-posting value '%s'\n",
			s3_options_limit_write_posting_keywords[option_enum_index]);
	}
#endif
	break;


case 38 :	/* linear-frame-buffer-size */
	option_struct_p->linear_frame_buffer_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->linear_frame_buffer_size == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"linear-frame-buffer-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	linear-frame-buffer-size = %d\n",
				option_struct_p->linear_frame_buffer_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->linear_frame_buffer_size >= 0) && (option_struct_p->linear_frame_buffer_size <= 4)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"linear-frame-buffer-size");
		goto error;
	}

	break;

case 39 :	/* linedraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_linedraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "linedraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->linedraw_options &= 
				(~s3_options_linedraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->linedraw_options |= 
				(s3_options_linedraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum linedraw-options value %d.\n",
			option_struct_p->linedraw_options);
	}
#endif

	break;


case 40 :	/* max-fully-cacheable-font-size */
	option_struct_p->max_fully_cacheable_font_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->max_fully_cacheable_font_size == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"max-fully-cacheable-font-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	max-fully-cacheable-font-size = %d\n",
				option_struct_p->max_fully_cacheable_font_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->max_fully_cacheable_font_size >= 0) && (option_struct_p->max_fully_cacheable_font_size <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"max-fully-cacheable-font-size");
		goto error;
	}

	break;


case 41 :	/* max-number-of-glyphs-in-downloadable-font */
	option_struct_p->max_number_of_glyphs_in_downloadable_font = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->max_number_of_glyphs_in_downloadable_font == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"max-number-of-glyphs-in-downloadable-font");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	max-number-of-glyphs-in-downloadable-font = %d\n",
				option_struct_p->max_number_of_glyphs_in_downloadable_font);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->max_number_of_glyphs_in_downloadable_font >= 0) && (option_struct_p->max_number_of_glyphs_in_downloadable_font <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"max-number-of-glyphs-in-downloadable-font");
		goto error;
	}

	break;


case 42 :	/* maximum-offscreen-downloadable-bitmap-height */
	option_struct_p->maximum_offscreen_downloadable_bitmap_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->maximum_offscreen_downloadable_bitmap_height == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"maximum-offscreen-downloadable-bitmap-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	maximum-offscreen-downloadable-bitmap-height = %d\n",
				option_struct_p->maximum_offscreen_downloadable_bitmap_height);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->maximum_offscreen_downloadable_bitmap_height >= 1) && (option_struct_p->maximum_offscreen_downloadable_bitmap_height <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"maximum-offscreen-downloadable-bitmap-height");
		goto error;
	}

	break;


case 43 :	/* maximum-offscreen-downloadable-bitmap-width */
	option_struct_p->maximum_offscreen_downloadable_bitmap_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->maximum_offscreen_downloadable_bitmap_width == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"maximum-offscreen-downloadable-bitmap-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	maximum-offscreen-downloadable-bitmap-width = %d\n",
				option_struct_p->maximum_offscreen_downloadable_bitmap_width);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->maximum_offscreen_downloadable_bitmap_width >= 1) && (option_struct_p->maximum_offscreen_downloadable_bitmap_width <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"maximum-offscreen-downloadable-bitmap-width");
		goto error;
	}

	break;

case 44 :	/* memory-and-register-access-mode */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_memory_and_register_access_mode_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "memory-and-register-access-mode");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->memory_and_register_access_mode &= 
				(~s3_options_memory_and_register_access_mode_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->memory_and_register_access_mode |= 
				(s3_options_memory_and_register_access_mode_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum memory-and-register-access-mode value %d.\n",
			option_struct_p->memory_and_register_access_mode);
	}
#endif

	break;

case 45 :	/* modedb-string */
	option_struct_p->modedb_string = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	modedb-string = \"%s\"\n",
			option_struct_p->modedb_string);
	}
#endif

	break;

case 46 :	/* monitor-sync-type */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_monitor_sync_type_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "monitor-sync-type");
		goto error;
	}
	option_struct_p->monitor_sync_type = s3_options_monitor_sync_type_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum monitor-sync-type value '%s'\n",
			s3_options_monitor_sync_type_keywords[option_enum_index]);
	}
#endif
	break;


case 47 :	/* number-of-downloadable-cursors */
	option_struct_p->number_of_downloadable_cursors = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_downloadable_cursors == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"number-of-downloadable-cursors");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-downloadable-cursors = %d\n",
				option_struct_p->number_of_downloadable_cursors);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_downloadable_cursors >= 0) && (option_struct_p->number_of_downloadable_cursors <= 1)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"number-of-downloadable-cursors");
		goto error;
	}

	break;


case 48 :	/* number-of-downloadable-fonts */
	option_struct_p->number_of_downloadable_fonts = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_downloadable_fonts == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"number-of-downloadable-fonts");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-downloadable-fonts = %d\n",
				option_struct_p->number_of_downloadable_fonts);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_downloadable_fonts >= 0) && (option_struct_p->number_of_downloadable_fonts <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"number-of-downloadable-fonts");
		goto error;
	}

	break;


case 49 :	/* number-of-graphics-states */
	option_struct_p->number_of_graphics_states = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_graphics_states == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"number-of-graphics-states");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-graphics-states = %d\n",
				option_struct_p->number_of_graphics_states);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_graphics_states >= 0) && (option_struct_p->number_of_graphics_states <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"number-of-graphics-states");
		goto error;
	}

	break;


case 50 :	/* offscreen-stipple-padded-height */
	option_struct_p->offscreen_stipple_padded_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_stipple_padded_height == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"offscreen-stipple-padded-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-stipple-padded-height = %d\n",
				option_struct_p->offscreen_stipple_padded_height);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_stipple_padded_height >= 1) && (option_struct_p->offscreen_stipple_padded_height <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"offscreen-stipple-padded-height");
		goto error;
	}

	break;


case 51 :	/* offscreen-stipple-padded-width */
	option_struct_p->offscreen_stipple_padded_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_stipple_padded_width == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"offscreen-stipple-padded-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-stipple-padded-width = %d\n",
				option_struct_p->offscreen_stipple_padded_width);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_stipple_padded_width >= 1) && (option_struct_p->offscreen_stipple_padded_width <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"offscreen-stipple-padded-width");
		goto error;
	}

	break;


case 52 :	/* offscreen-tile-padded-height */
	option_struct_p->offscreen_tile_padded_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_tile_padded_height == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"offscreen-tile-padded-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-tile-padded-height = %d\n",
				option_struct_p->offscreen_tile_padded_height);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_tile_padded_height >= 1) && (option_struct_p->offscreen_tile_padded_height <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"offscreen-tile-padded-height");
		goto error;
	}

	break;


case 53 :	/* offscreen-tile-padded-width */
	option_struct_p->offscreen_tile_padded_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_tile_padded_width == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"offscreen-tile-padded-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-tile-padded-width = %d\n",
				option_struct_p->offscreen_tile_padded_width);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_tile_padded_width >= 1) && (option_struct_p->offscreen_tile_padded_width <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"offscreen-tile-padded-width");
		goto error;
	}

	break;


case 54 :	/* omm-full-coalesce-watermark */
	option_struct_p->omm_full_coalesce_watermark = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_full_coalesce_watermark == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"omm-full-coalesce-watermark");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-full-coalesce-watermark = %d\n",
				option_struct_p->omm_full_coalesce_watermark);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_full_coalesce_watermark >= 0) && (option_struct_p->omm_full_coalesce_watermark <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"omm-full-coalesce-watermark");
		goto error;
	}

	break;


case 55 :	/* omm-hash-list-size */
	option_struct_p->omm_hash_list_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_hash_list_size == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"omm-hash-list-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-hash-list-size = %d\n",
				option_struct_p->omm_hash_list_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_hash_list_size >= 0) && (option_struct_p->omm_hash_list_size <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"omm-hash-list-size");
		goto error;
	}

	break;


case 56 :	/* omm-horizontal-constraint */
	option_struct_p->omm_horizontal_constraint = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_horizontal_constraint == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"omm-horizontal-constraint");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-horizontal-constraint = %d\n",
				option_struct_p->omm_horizontal_constraint);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_horizontal_constraint >= 0) && (option_struct_p->omm_horizontal_constraint <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"omm-horizontal-constraint");
		goto error;
	}

	break;

case 57 :	/* omm-named-allocation-list */
	option_struct_p->omm_named_allocation_list = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-named-allocation-list = \"%s\"\n",
			option_struct_p->omm_named_allocation_list);
	}
#endif

	break;


case 58 :	/* omm-neighbour-list-increment */
	option_struct_p->omm_neighbour_list_increment = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_neighbour_list_increment == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"omm-neighbour-list-increment");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-neighbour-list-increment = %d\n",
				option_struct_p->omm_neighbour_list_increment);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_neighbour_list_increment >= 0) && (option_struct_p->omm_neighbour_list_increment <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"omm-neighbour-list-increment");
		goto error;
	}

	break;


case 59 :	/* omm-vertical-constraint */
	option_struct_p->omm_vertical_constraint = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_vertical_constraint == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"omm-vertical-constraint");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-vertical-constraint = %d\n",
				option_struct_p->omm_vertical_constraint);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_vertical_constraint >= 0) && (option_struct_p->omm_vertical_constraint <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"omm-vertical-constraint");
		goto error;
	}

	break;

case 60 :	/* options-file */
	/*
	 * look up the file.
	 */
	if (stat(option_value_p, &stat_buf) != 0)
	{
		/*
		 * Warn the user of missing files, and continue.
		 */
		(void) fprintf(stderr, 
					DEFAULT_OPTION_CANNOT_STAT_FILE_ARGUMENT_MESSAGE,
					option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		break;
	}

	if (stat_buf.st_size == 0)
	{
		/*
		 * Warn the user of zero length files, and continue.
		 */
		(void) fprintf(stderr,
					DEFAULT_OPTION_ZERO_LENGTH_FILE_ARGUMENT_MESSAGE,
					option_value_p, "options-file");
		break;
	}

	/* read the option file into a buffer */
	if (!(tmp_p = allocate_and_clear_memory(stat_buf.st_size+1)))
	{
		perror(DEFAULT_OPTION_CANNOT_ALLOCATE_MEMORY_MESSAGE);
		goto error;
	}

	if( (option_file_p = fopen(option_value_p, "r")) == NULL)
	{

		(void) fprintf(stderr, 
				DEFAULT_OPTION_CANNOT_OPEN_FILE_ARGUMENT_MESSAGE,
				option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		goto error;
	}
	if (fread(tmp_p, stat_buf.st_size, 1, option_file_p) != 1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_CANNOT_READ_FILE_ARGUMENT_MESSAGE,
				option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		goto error;
	}

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "\t\"%s\"\n", tmp_p);
	}
#endif
	/*
	 * Recursively invoke the interpreter.
	 */
	if (!s3_options_parse(option_struct_p, tmp_p))
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_CANNOT_PROCESS_FILE_ARGUMENT_MESSAGE,
				option_value_p, "options-file");
		free_memory(tmp_p);
		goto error;
	}
	free_memory(tmp_p);
	break;

case 61 :	/* options-variable */

	tmp_p = getenv(option_value_p);
	if (tmp_p)
	{

#if (defined(__DEBUG__))
		if (s3_options_debug)
		{
			(void) fprintf(debug_stream_p, "\t\"%s\"\n", tmp_p);
		}
#endif
		if (!s3_options_parse(option_struct_p, tmp_p))
		{
			(void) fprintf(stderr, 
					DEFAULT_OPTION_CANNOT_PROCESS_ENVIRONMENT_ARGUMENT_MESSAGE,
				option_value_p, "options-variable");
			goto error;
		}

	}
	break;

case 62 :	/* override-ss-stippling */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_override_ss_stippling_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "override-ss-stippling");
		goto error;
	}
	option_struct_p->override_ss_stippling = s3_options_override_ss_stippling_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum override-ss-stippling value '%s'\n",
			s3_options_override_ss_stippling_keywords[option_enum_index]);
	}
#endif
	break;

case 63 :	/* pointdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_pointdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "pointdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->pointdraw_options &= 
				(~s3_options_pointdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->pointdraw_options |= 
				(s3_options_pointdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum pointdraw-options value %d.\n",
			option_struct_p->pointdraw_options);
	}
#endif

	break;


case 64 :	/* rac-extra-prefetch */
	option_struct_p->rac_extra_prefetch = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->rac_extra_prefetch == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"rac-extra-prefetch");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	rac-extra-prefetch = %d\n",
				option_struct_p->rac_extra_prefetch);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->rac_extra_prefetch >= 1) && (option_struct_p->rac_extra_prefetch <= 7)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"rac-extra-prefetch");
		goto error;
	}

	break;

case 65 :	/* ras-m-clk */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_ras_m_clk_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "ras-m-clk");
		goto error;
	}
	option_struct_p->ras_m_clk = s3_options_ras_m_clk_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum ras-m-clk value '%s'\n",
			s3_options_ras_m_clk_keywords[option_enum_index]);
	}
#endif
	break;


case 66 :	/* read-wait-control */
	option_struct_p->read_wait_control = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->read_wait_control == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"read-wait-control");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	read-wait-control = %d\n",
				option_struct_p->read_wait_control);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->read_wait_control >= 0) && (option_struct_p->read_wait_control <= 3)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"read-wait-control");
		goto error;
	}

	break;

case 67 :	/* rectfill-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_rectfill_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "rectfill-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->rectfill_options &= 
				(~s3_options_rectfill_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->rectfill_options |= 
				(s3_options_rectfill_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum rectfill-options value %d.\n",
			option_struct_p->rectfill_options);
	}
#endif

	break;

case 68 :	/* register-values-string */
	option_struct_p->register_values_string = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	register-values-string = \"%s\"\n",
			option_struct_p->register_values_string);
	}
#endif

	break;

case 69 :	/* s3-bus-width */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_s3_bus_width_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "s3-bus-width");
		goto error;
	}
	option_struct_p->s3_bus_width = s3_options_s3_bus_width_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum s3-bus-width value '%s'\n",
			s3_options_s3_bus_width_keywords[option_enum_index]);
	}
#endif
	break;

case 70 :	/* screen-8-4-bit-visual-list */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_screen_8_4_bit_visual_list_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "screen-8-4-bit-visual-list");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->screen_8_4_bit_visual_list &= 
				(~s3_options_screen_8_4_bit_visual_list_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->screen_8_4_bit_visual_list |= 
				(s3_options_screen_8_4_bit_visual_list_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum screen-8-4-bit-visual-list value %d.\n",
			option_struct_p->screen_8_4_bit_visual_list);
	}
#endif

	break;

case 71 :	/* serial-access-mode-control */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_serial_access_mode_control_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "serial-access-mode-control");
		goto error;
	}
	option_struct_p->serial_access_mode_control = s3_options_serial_access_mode_control_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum serial-access-mode-control value '%s'\n",
			s3_options_serial_access_mode_control_keywords[option_enum_index]);
	}
#endif
	break;

case 72 :	/* si-interface-version */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_si_interface_version_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "si-interface-version");
		goto error;
	}
	option_struct_p->si_interface_version = s3_options_si_interface_version_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum si-interface-version value '%s'\n",
			s3_options_si_interface_version_keywords[option_enum_index]);
	}
#endif
	break;

case 73 :	/* spansfill-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			s3_options_lookup_name(option_value_p, &(s3_options_spansfill_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
				option_value_p, "spansfill-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->spansfill_options &= 
				(~s3_options_spansfill_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->spansfill_options |= 
				(s3_options_spansfill_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "(s3_options_parse) enum spansfill-options value %d.\n",
			option_struct_p->spansfill_options);
	}
#endif

	break;

case 74 :	/* static-colormap-description-file */
	option_struct_p->static_colormap_description_file = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	static-colormap-description-file = \"%s\"\n",
			option_struct_p->static_colormap_description_file);
	}
#endif

	break;

case 75 :	/* stepping-number */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_stepping_number_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "stepping-number");
		goto error;
	}
	option_struct_p->stepping_number = s3_options_stepping_number_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum stepping-number value '%s'\n",
			s3_options_stepping_number_keywords[option_enum_index]);
	}
#endif
	break;

case 76 :	/* stipple-best-size */
	option_struct_p->stipple_best_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	stipple-best-size = \"%s\"\n",
			option_struct_p->stipple_best_size);
	}
#endif

	break;

case 77 :	/* tile-best-size */
	option_struct_p->tile_best_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	tile-best-size = \"%s\"\n",
			option_struct_p->tile_best_size);
	}
#endif

	break;

case 78 :	/* use-clock-doubler */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_use_clock_doubler_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "use-clock-doubler");
		goto error;
	}
	option_struct_p->use_clock_doubler = s3_options_use_clock_doubler_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum use-clock-doubler value '%s'\n",
			s3_options_use_clock_doubler_keywords[option_enum_index]);
	}
#endif
	break;

case 79 :	/* use-dac-external-sid-mode */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_use_dac_external_sid_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "use-dac-external-sid-mode");
		goto error;
	}
	option_struct_p->use_dac_external_sid_mode = s3_options_use_dac_external_sid_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum use-dac-external-sid-mode value '%s'\n",
			s3_options_use_dac_external_sid_mode_keywords[option_enum_index]);
	}
#endif
	break;

case 80 :	/* use-save-unders */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_use_save_unders_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "use-save-unders");
		goto error;
	}
	option_struct_p->use_save_unders = s3_options_use_save_unders_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum use-save-unders value '%s'\n",
			s3_options_use_save_unders_keywords[option_enum_index]);
	}
#endif
	break;


case 81 :	/* verbose-startup */
	option_struct_p->verbose_startup = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->verbose_startup == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"verbose-startup");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	verbose-startup = %d\n",
				option_struct_p->verbose_startup);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->verbose_startup >= 0) && (option_struct_p->verbose_startup <= 1)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"verbose-startup");
		goto error;
	}

	break;

case 82 :	/* vram-addressing-mode */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_vram_addressing_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "vram-addressing-mode");
		goto error;
	}
	option_struct_p->vram_addressing_mode = s3_options_vram_addressing_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum vram-addressing-mode value '%s'\n",
			s3_options_vram_addressing_mode_keywords[option_enum_index]);
	}
#endif
	break;

case 83 :	/* vsync-polarity */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_vsync_polarity_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "vsync-polarity");
		goto error;
	}
	option_struct_p->vsync_polarity = s3_options_vsync_polarity_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum vsync-polarity value '%s'\n",
			s3_options_vsync_polarity_keywords[option_enum_index]);
	}
#endif
	break;


case 84 :	/* vt-switch-save-lines */
	option_struct_p->vt_switch_save_lines = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->vt_switch_save_lines == 0)
	{
		(void) fprintf(stderr, DEFAULT_OPTION_BAD_INTEGER_MESSAGE,
				"vt-switch-save-lines");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p, "	vt-switch-save-lines = %d\n",
				option_struct_p->vt_switch_save_lines);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->vt_switch_save_lines >= 0) && (option_struct_p->vt_switch_save_lines <= 4096)) ))
	{
		(void) fprintf(stderr, 
			DEFAULT_OPTION_INTEGER_OPTION_OUT_OF_BOUNDS_MESSAGE,
			"vt-switch-save-lines");
		goto error;
	}

	break;

case 85 :	/* wait-state-control */
	if ((option_enum_index = 
		s3_options_lookup_name(option_value_p, &(s3_options_wait_state_control_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				DEFAULT_OPTION_INCORRECT_ENUMERATION_VALUE_MESSAGE,
					option_value_p, "wait-state-control");
		goto error;
	}
	option_struct_p->wait_state_control = s3_options_wait_state_control_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (s3_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(s3_options_parse) enum wait-state-control value '%s'\n",
			s3_options_wait_state_control_keywords[option_enum_index]);
	}
#endif
	break;


			default :
				(void) fprintf(stderr,
						DEFAULT_OPTION_INTERNAL_ERROR_MESSAGE);
				free_memory(option_list_p);
				return (struct s3_options_structure *) 0;
			
		}
		
		/*
		 * while ...
		 */
		character_p = 
			s3_options_parse_get_next_token(character_p);
		
	}
	/*
	 * Free the space we allocated.
	 */
	free_memory(option_list_p);
	
	return option_struct_p;

  error:
	if (option_list_p)
	{
		free_memory(option_list_p);
	}
	
	return (struct s3_options_structure *) 0;
	
}

#if (defined(__TEST__))
int
main(int parameter_count, char ** parameter_pp)
{
	int i;
	int string_length = 0;
	char * options_p;

#if (defined(__DEBUG__))
	s3_options_debug = 
		getenv("s3_options_debug") ? TRUE :	FALSE;
	if (debug_stream_p == NULL && (debug_stream_p =
		    fopen(getenv("debug_stream"), "w")) == NULL)
	{
		debug_stream_p = stdout;
	}
#endif

	for(i = 1; i < parameter_count; i++)
	{
		string_length += strlen(*(parameter_pp + i));
	}
	options_p = allocate_memory(string_length + 1);
	*options_p = EOS;
	
	for(i = 1; i < parameter_count; i++)
	{
		strcat(options_p, *(parameter_pp +i));
	}

	s3_options_parse(0, options_p);

}

#endif
