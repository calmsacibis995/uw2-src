/*	Copyright (c) 1990, 1991, 1992, 1993, 1994 Novell, Inc. All Rights Reserved.	*/
/*	Copyright (c) 1993 Novell, Inc. All Rights Reserved.	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Novell Inc.	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/


/***								-*- C -*-
 ***
 ***	Warning!  Target file, do not modify.
 ***	
 ***	Generated from: p9k_opt.gen
 ***
 ***	Generated by: (genoptions 1.0.0).
 ***
 ***/

#ident	"@(#)p9k:p9k/p9k_opt.c	1.4"

PUBLIC

#include "stdenv.h"


enum p9000_options_si_interface_version
{
	P9000_OPTIONS_SI_INTERFACE_VERSION_1_0,
	P9000_OPTIONS_SI_INTERFACE_VERSION_1_1,
	P9000_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	p9000_options_si_interface_version_end_enumeration
};

enum p9000_options_verbose_startup
{
	P9000_OPTIONS_VERBOSE_STARTUP_YES,
	P9000_OPTIONS_VERBOSE_STARTUP_NO,
	p9000_options_verbose_startup_end_enumeration
};

enum p9000_options_clock_name
{
	P9000_OPTIONS_CLOCK_NAME_ICD2061A,
	p9000_options_clock_name_end_enumeration
};

enum p9000_options_dac_name
{
	P9000_OPTIONS_DAC_NAME_BT485KPJ135,
	P9000_OPTIONS_DAC_NAME_BT485KPJ110,
	p9000_options_dac_name_end_enumeration
};

enum p9000_options_memory_configuration
{
	P9000_OPTIONS_MEMORY_CONFIGURATION_1,
	P9000_OPTIONS_MEMORY_CONFIGURATION_2,
	P9000_OPTIONS_MEMORY_CONFIGURATION_3,
	P9000_OPTIONS_MEMORY_CONFIGURATION_4,
	P9000_OPTIONS_MEMORY_CONFIGURATION_5,
	p9000_options_memory_configuration_end_enumeration
};

enum p9000_options_cursor_type
{
	P9000_OPTIONS_CURSOR_TYPE_AUTO_CONFIGURE,
	P9000_OPTIONS_CURSOR_TYPE_DAC_CURSOR,
	P9000_OPTIONS_CURSOR_TYPE_SOFTWARE_CURSOR,
	p9000_options_cursor_type_end_enumeration
};

enum p9000_options_dac_rgb_width
{
	P9000_OPTIONS_DAC_RGB_WIDTH_6,
	P9000_OPTIONS_DAC_RGB_WIDTH_8,
	P9000_OPTIONS_DAC_RGB_WIDTH_DEFAULT,
	p9000_options_dac_rgb_width_end_enumeration
};

enum p9000_options_dac_24_bit_color_mode
{
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_ABGR,
	p9000_options_dac_24_bit_color_mode_end_enumeration
};

enum p9000_options_dac_16_bit_color_mode
{
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_565,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_655,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_664,
	p9000_options_dac_16_bit_color_mode_end_enumeration
};

enum p9000_options_allow_core_server_to_use_linear_frame_buffer
{
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_YES,
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_NO,
	p9000_options_allow_core_server_to_use_linear_frame_buffer_end_enumeration
};


#define	P9000_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT	1
#define	P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT	2
#define	P9000_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT	4
#define	P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT	8


#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT	1
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT	2
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT	4
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY	8
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_PATTERN_REGISTERS	16
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_TWO_COLOR_TILE_SPEEDUP	32
#define	P9000_OPTIONS_RECTFILL_OPTIONS_USE_REDUCED_STIPPLE_SPEEDUP	64


#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES	1
#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW	2
#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW	4
#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINES	8
#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_SEGMENTS	16
#define	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_PATTERN_REGISTERS	32


#define	P9000_OPTIONS_FONTDRAW_OPTIONS_USE_TERMINAL_FONTS	1
#define	P9000_OPTIONS_FONTDRAW_OPTIONS_USE_NON_TERMINAL_FONTS	2


#define	P9000_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS	1


#define	P9000_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT	1


#define	P9000_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL_SPANS	1




struct p9000_options_structure
{
	enum p9000_options_allow_core_server_to_use_linear_frame_buffer allow_core_server_to_use_linear_frame_buffer;
	unsigned int arcdraw_options;
	unsigned int bitblt_options;
	int bt485_clock_doubler_threshold;
	enum p9000_options_clock_name clock_name;
	char *cursor_max_size;
	enum p9000_options_cursor_type cursor_type;
	enum p9000_options_dac_16_bit_color_mode dac_16_bit_color_mode;
	enum p9000_options_dac_24_bit_color_mode dac_24_bit_color_mode;
	int dac_access_delay_count;
	char *dac_base_address;
	int dac_max_frequency;
	enum p9000_options_dac_name dac_name;
	enum p9000_options_dac_rgb_width dac_rgb_width;
	int dot_clock_divide;
	unsigned int fontdraw_options;
	int graphics_engine_loop_timeout_count;
	int linear_frame_buffer_size;
	unsigned int linedraw_options;
	char *max_font_glyph_size;
	int max_number_of_glyphs_in_downloadable_font;
	int maximum_offscreen_downloadable_tile_height;
	int maximum_offscreen_downloadable_tile_width;
	enum p9000_options_memory_configuration memory_configuration;
	char *modedb_string;
	int number_of_downloadable_cursors;
	int number_of_downloadable_fonts;
	int number_of_graphics_states;
	int offscreen_tile_padded_height;
	int offscreen_tile_padded_width;
	int omm_full_coalesce_watermark;
	int omm_hash_list_size;
	int omm_horizontal_constraint;
	char *omm_named_allocation_list;
	int omm_neighbour_list_increment;
	int omm_vertical_constraint;
	char *p9000_base_address;
	unsigned int pointdraw_options;
	unsigned int rectfill_options;
	enum p9000_options_si_interface_version si_interface_version;
	unsigned int spansfill_options;
	char *stipple_best_size;
	char *tile_best_size;
	int two_color_tile_maximum_height;
	int two_color_tile_maximum_width;
	enum p9000_options_verbose_startup verbose_startup;
	char *video_memory_dimensions;
	int vram_ras_low_maximum;
	int vram_refresh_period;
	int vt_switch_save_lines;

};

/*
 * Names of the option defaults
 */

#define P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_DEFAULT\
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_NO
#define P9000_OPTIONS_ARCDRAW_OPTIONS_DEFAULT\
	( P9000_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS )
#define P9000_OPTIONS_BITBLT_OPTIONS_DEFAULT\
	( P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT )
#define P9000_OPTIONS_BT485_CLOCK_DOUBLER_THRESHOLD_DEFAULT\
	80
#define P9000_OPTIONS_CLOCK_NAME_DEFAULT\
	P9000_OPTIONS_CLOCK_NAME_ICD2061A
#define P9000_OPTIONS_CURSOR_MAX_SIZE_DEFAULT 0
#define P9000_OPTIONS_CURSOR_TYPE_DEFAULT\
	P9000_OPTIONS_CURSOR_TYPE_AUTO_CONFIGURE
#define P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_DEFAULT\
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_555
#define P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_DEFAULT\
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA
#define P9000_OPTIONS_DAC_ACCESS_DELAY_COUNT_DEFAULT\
	1000
#define P9000_OPTIONS_DAC_BASE_ADDRESS_DEFAULT 0
#define P9000_OPTIONS_DAC_MAX_FREQUENCY_DEFAULT\
	0
#define P9000_OPTIONS_DAC_NAME_DEFAULT\
	P9000_OPTIONS_DAC_NAME_BT485KPJ110
#define P9000_OPTIONS_DAC_RGB_WIDTH_DEFAULT\
	P9000_OPTIONS_DAC_RGB_WIDTH_8
#define P9000_OPTIONS_DOT_CLOCK_DIVIDE_DEFAULT\
	4
#define P9000_OPTIONS_FONTDRAW_OPTIONS_DEFAULT\
	( P9000_OPTIONS_FONTDRAW_OPTIONS_USE_NON_TERMINAL_FONTS |P9000_OPTIONS_FONTDRAW_OPTIONS_USE_TERMINAL_FONTS )
#define P9000_OPTIONS_GRAPHICS_ENGINE_LOOP_TIMEOUT_COUNT_DEFAULT\
	200000
#define P9000_OPTIONS_LINEAR_FRAME_BUFFER_SIZE_DEFAULT\
	0
#define P9000_OPTIONS_LINEDRAW_OPTIONS_DEFAULT\
	( P9000_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINES |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_SEGMENTS |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_PATTERN_REGISTERS )
#define P9000_OPTIONS_MAX_FONT_GLYPH_SIZE_DEFAULT 0
#define P9000_OPTIONS_MAX_NUMBER_OF_GLYPHS_IN_DOWNLOADABLE_FONT_DEFAULT\
	256
#define P9000_OPTIONS_MAXIMUM_OFFSCREEN_DOWNLOADABLE_TILE_HEIGHT_DEFAULT\
	256
#define P9000_OPTIONS_MAXIMUM_OFFSCREEN_DOWNLOADABLE_TILE_WIDTH_DEFAULT\
	256
#define P9000_OPTIONS_MEMORY_CONFIGURATION_DEFAULT\
	P9000_OPTIONS_MEMORY_CONFIGURATION_3
#define P9000_OPTIONS_MODEDB_STRING_DEFAULT 0
#define P9000_OPTIONS_NUMBER_OF_DOWNLOADABLE_CURSORS_DEFAULT\
	1
#define P9000_OPTIONS_NUMBER_OF_DOWNLOADABLE_FONTS_DEFAULT\
	32
#define P9000_OPTIONS_NUMBER_OF_GRAPHICS_STATES_DEFAULT\
	8
#define P9000_OPTIONS_OFFSCREEN_TILE_PADDED_HEIGHT_DEFAULT\
	32
#define P9000_OPTIONS_OFFSCREEN_TILE_PADDED_WIDTH_DEFAULT\
	128
#define P9000_OPTIONS_OMM_FULL_COALESCE_WATERMARK_DEFAULT\
	2
#define P9000_OPTIONS_OMM_HASH_LIST_SIZE_DEFAULT\
	512
#define P9000_OPTIONS_OMM_HORIZONTAL_CONSTRAINT_DEFAULT\
	0
#define P9000_OPTIONS_OMM_NAMED_ALLOCATION_LIST_DEFAULT\
	""
#define P9000_OPTIONS_OMM_NEIGHBOUR_LIST_INCREMENT_DEFAULT\
	20
#define P9000_OPTIONS_OMM_VERTICAL_CONSTRAINT_DEFAULT\
	0
#define P9000_OPTIONS_P9000_BASE_ADDRESS_DEFAULT 0
#define P9000_OPTIONS_POINTDRAW_OPTIONS_DEFAULT\
	( P9000_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT )
#define P9000_OPTIONS_RECTFILL_OPTIONS_DEFAULT\
	( P9000_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY |P9000_OPTIONS_RECTFILL_OPTIONS_USE_PATTERN_REGISTERS |P9000_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_TWO_COLOR_TILE_SPEEDUP |P9000_OPTIONS_RECTFILL_OPTIONS_USE_REDUCED_STIPPLE_SPEEDUP )
#define P9000_OPTIONS_SI_INTERFACE_VERSION_DEFAULT\
	P9000_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE
#define P9000_OPTIONS_SPANSFILL_OPTIONS_DEFAULT\
	( P9000_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL_SPANS )
#define P9000_OPTIONS_STIPPLE_BEST_SIZE_DEFAULT 0
#define P9000_OPTIONS_TILE_BEST_SIZE_DEFAULT\
	"64X64"
#define P9000_OPTIONS_TWO_COLOR_TILE_MAXIMUM_HEIGHT_DEFAULT\
	128
#define P9000_OPTIONS_TWO_COLOR_TILE_MAXIMUM_WIDTH_DEFAULT\
	128
#define P9000_OPTIONS_VERBOSE_STARTUP_DEFAULT\
	P9000_OPTIONS_VERBOSE_STARTUP_NO
#define P9000_OPTIONS_VIDEO_MEMORY_DIMENSIONS_DEFAULT 0
#define P9000_OPTIONS_VRAM_RAS_LOW_MAXIMUM_DEFAULT\
	0
#define P9000_OPTIONS_VRAM_REFRESH_PERIOD_DEFAULT\
	0
#define P9000_OPTIONS_VT_SWITCH_SAVE_LINES_DEFAULT\
	2048


#if (defined(__DEBUG__))
export boolean	p9000_options_debug = FALSE;
#endif


PRIVATE
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <limits.h>

/*
 * The types of options.
 */

enum p9000_options_kind
{
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_OPTION_ENVIRONMENT,
	P9000_OPTIONS_OPTION_FILE,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_UNIQUE_ENUMERATION,

	p9000_options_end_option_types
};

#if (defined(__DEBUG__))

static const char *const option_type_dump[] = 
{
	"multiple-enumeration",
	"numeric",
	"option-environment",
	"option-file",
	"string",
	"unique-enumeration",

	0
};

#endif

/*
 * The default options.
 */
static struct p9000_options_structure p9000_options_default =
{
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_NO,
	( P9000_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS ),
	( P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT |P9000_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT ),
	80,
	P9000_OPTIONS_CLOCK_NAME_ICD2061A,
	0,
	P9000_OPTIONS_CURSOR_TYPE_AUTO_CONFIGURE,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	1000,
	0,
	0,
	P9000_OPTIONS_DAC_NAME_BT485KPJ110,
	P9000_OPTIONS_DAC_RGB_WIDTH_8,
	4,
	( P9000_OPTIONS_FONTDRAW_OPTIONS_USE_NON_TERMINAL_FONTS |P9000_OPTIONS_FONTDRAW_OPTIONS_USE_TERMINAL_FONTS ),
	200000,
	0,
	( P9000_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINES |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_SEGMENTS |P9000_OPTIONS_LINEDRAW_OPTIONS_USE_PATTERN_REGISTERS ),
	0,
	256,
	256,
	256,
	P9000_OPTIONS_MEMORY_CONFIGURATION_3,
	0,
	1,
	32,
	8,
	32,
	128,
	2,
	512,
	0,
	"",
	20,
	0,
	0,
	( P9000_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT ),
	( P9000_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY |P9000_OPTIONS_RECTFILL_OPTIONS_USE_PATTERN_REGISTERS |P9000_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT |P9000_OPTIONS_RECTFILL_OPTIONS_USE_TWO_COLOR_TILE_SPEEDUP |P9000_OPTIONS_RECTFILL_OPTIONS_USE_REDUCED_STIPPLE_SPEEDUP ),
	P9000_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	( P9000_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL_SPANS ),
	0,
	"64x64",
	128,
	128,
	P9000_OPTIONS_VERBOSE_STARTUP_NO,
	0,
	0,
	0,
	2048,

};

/*
 * The list of option keywords.
 */

static const char *const p9000_options_keywords[] = 
{
	"allow-core-server-to-use-linear-frame-buffer",
	"arcdraw-options",
	"bitblt-options",
	"bt485-clock-doubler-threshold",
	"clock-name",
	"cursor-max-size",
	"cursor-type",
	"dac-16-bit-color-mode",
	"dac-24-bit-color-mode",
	"dac-access-delay-count",
	"dac-base-address",
	"dac-max-frequency",
	"dac-name",
	"dac-rgb-width",
	"dot-clock-divide",
	"fontdraw-options",
	"graphics-engine-loop-timeout-count",
	"linear-frame-buffer-size",
	"linedraw-options",
	"max-font-glyph-size",
	"max-number-of-glyphs-in-downloadable-font",
	"maximum-offscreen-downloadable-tile-height",
	"maximum-offscreen-downloadable-tile-width",
	"memory-configuration",
	"modedb-string",
	"number-of-downloadable-cursors",
	"number-of-downloadable-fonts",
	"number-of-graphics-states",
	"offscreen-tile-padded-height",
	"offscreen-tile-padded-width",
	"omm-full-coalesce-watermark",
	"omm-hash-list-size",
	"omm-horizontal-constraint",
	"omm-named-allocation-list",
	"omm-neighbour-list-increment",
	"omm-vertical-constraint",
	"options-file",
	"options-variable",
	"p9000-base-address",
	"pointdraw-options",
	"rectfill-options",
	"si-interface-version",
	"spansfill-options",
	"stipple-best-size",
	"tile-best-size",
	"two-color-tile-maximum-height",
	"two-color-tile-maximum-width",
	"verbose-startup",
	"video-memory-dimensions",
	"vram-ras-low-maximum",
	"vram-refresh-period",
	"vt-switch-save-lines",

	0
};
/*
 * This array maps the option index to the option kind.
 */
static enum p9000_options_kind option_index_to_option_kind[] =
{
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_OPTION_FILE,
	P9000_OPTIONS_OPTION_ENVIRONMENT,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_MULTIPLE_ENUMERATION,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_UNIQUE_ENUMERATION,
	P9000_OPTIONS_STRING,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,
	P9000_OPTIONS_NUMERIC,

	p9000_options_end_option_types
};



/*
 * List of enumeration keywords.
 */

static const char *const p9000_options_si_interface_version_keywords[] =
{
	"1-0",
	"1-1",
	"auto-configure",
	0
};
static const enum p9000_options_si_interface_version p9000_options_si_interface_version_index_to_value[] =
{
	P9000_OPTIONS_SI_INTERFACE_VERSION_1_0,
	P9000_OPTIONS_SI_INTERFACE_VERSION_1_1,
	P9000_OPTIONS_SI_INTERFACE_VERSION_AUTO_CONFIGURE,
	p9000_options_si_interface_version_end_enumeration
};
static const char *const p9000_options_verbose_startup_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum p9000_options_verbose_startup p9000_options_verbose_startup_index_to_value[] =
{
	P9000_OPTIONS_VERBOSE_STARTUP_YES,
	P9000_OPTIONS_VERBOSE_STARTUP_NO,
	p9000_options_verbose_startup_end_enumeration
};
static const char *const p9000_options_clock_name_keywords[] =
{
	"icd2061a",
	0
};
static const enum p9000_options_clock_name p9000_options_clock_name_index_to_value[] =
{
	P9000_OPTIONS_CLOCK_NAME_ICD2061A,
	p9000_options_clock_name_end_enumeration
};
static const char *const p9000_options_dac_name_keywords[] =
{
	"Bt485KPJ135",
	"Bt485KPJ110",
	0
};
static const enum p9000_options_dac_name p9000_options_dac_name_index_to_value[] =
{
	P9000_OPTIONS_DAC_NAME_BT485KPJ135,
	P9000_OPTIONS_DAC_NAME_BT485KPJ110,
	p9000_options_dac_name_end_enumeration
};
static const char *const p9000_options_memory_configuration_keywords[] =
{
	"1",
	"2",
	"3",
	"4",
	"5",
	0
};
static const enum p9000_options_memory_configuration p9000_options_memory_configuration_index_to_value[] =
{
	P9000_OPTIONS_MEMORY_CONFIGURATION_1,
	P9000_OPTIONS_MEMORY_CONFIGURATION_2,
	P9000_OPTIONS_MEMORY_CONFIGURATION_3,
	P9000_OPTIONS_MEMORY_CONFIGURATION_4,
	P9000_OPTIONS_MEMORY_CONFIGURATION_5,
	p9000_options_memory_configuration_end_enumeration
};
static const char *const p9000_options_cursor_type_keywords[] =
{
	"auto-configure",
	"dac-cursor",
	"software-cursor",
	0
};
static const enum p9000_options_cursor_type p9000_options_cursor_type_index_to_value[] =
{
	P9000_OPTIONS_CURSOR_TYPE_AUTO_CONFIGURE,
	P9000_OPTIONS_CURSOR_TYPE_DAC_CURSOR,
	P9000_OPTIONS_CURSOR_TYPE_SOFTWARE_CURSOR,
	p9000_options_cursor_type_end_enumeration
};
static const char *const p9000_options_dac_rgb_width_keywords[] =
{
	"6",
	"8",
	"default",
	0
};
static const enum p9000_options_dac_rgb_width p9000_options_dac_rgb_width_index_to_value[] =
{
	P9000_OPTIONS_DAC_RGB_WIDTH_6,
	P9000_OPTIONS_DAC_RGB_WIDTH_8,
	P9000_OPTIONS_DAC_RGB_WIDTH_DEFAULT,
	p9000_options_dac_rgb_width_end_enumeration
};
static const char *const p9000_options_dac_24_bit_color_mode_keywords[] =
{
	"rgba",
	"abgr",
	0
};
static const enum p9000_options_dac_24_bit_color_mode p9000_options_dac_24_bit_color_mode_index_to_value[] =
{
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_RGBA,
	P9000_OPTIONS_DAC_24_BIT_COLOR_MODE_ABGR,
	p9000_options_dac_24_bit_color_mode_end_enumeration
};
static const char *const p9000_options_dac_16_bit_color_mode_keywords[] =
{
	"555",
	"565",
	"655",
	"664",
	0
};
static const enum p9000_options_dac_16_bit_color_mode p9000_options_dac_16_bit_color_mode_index_to_value[] =
{
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_555,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_565,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_655,
	P9000_OPTIONS_DAC_16_BIT_COLOR_MODE_664,
	p9000_options_dac_16_bit_color_mode_end_enumeration
};
static const char *const p9000_options_bitblt_options_keywords[] =
{
	"use-ss-bitblt",
	"use-ms-bitblt",
	"use-sm-bitblt",
	"use-ms-stplblt",
	0
};
static const int p9000_options_bitblt_options_index_to_value[] =
{
	P9000_OPTIONS_BITBLT_OPTIONS_USE_SS_BITBLT,
	P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_BITBLT,
	P9000_OPTIONS_BITBLT_OPTIONS_USE_SM_BITBLT,
	P9000_OPTIONS_BITBLT_OPTIONS_USE_MS_STPLBLT,
	-1
};
static const char *const p9000_options_rectfill_options_keywords[] =
{
	"use-solid-fill-rect",
	"use-tile-fill-rect",
	"use-stipple-fill-rect",
	"use-offscreen-memory",
	"use-pattern-registers",
	"use-two-color-tile-speedup",
	"use-reduced-stipple-speedup",
	0
};
static const int p9000_options_rectfill_options_index_to_value[] =
{
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_SOLID_FILL_RECT,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_TILE_FILL_RECT,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_STIPPLE_FILL_RECT,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_OFFSCREEN_MEMORY,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_PATTERN_REGISTERS,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_TWO_COLOR_TILE_SPEEDUP,
	P9000_OPTIONS_RECTFILL_OPTIONS_USE_REDUCED_STIPPLE_SPEEDUP,
	-1
};
static const char *const p9000_options_linedraw_options_keywords[] =
{
	"use-line-rectangles",
	"use-line-draw",
	"use-segment-draw",
	"use-dashed-lines",
	"use-dashed-segments",
	"use-pattern-registers",
	0
};
static const int p9000_options_linedraw_options_index_to_value[] =
{
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_RECTANGLES,
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_LINE_DRAW,
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_SEGMENT_DRAW,
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_LINES,
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_DASHED_SEGMENTS,
	P9000_OPTIONS_LINEDRAW_OPTIONS_USE_PATTERN_REGISTERS,
	-1
};
static const char *const p9000_options_fontdraw_options_keywords[] =
{
	"use-terminal-fonts",
	"use-non-terminal-fonts",
	0
};
static const int p9000_options_fontdraw_options_index_to_value[] =
{
	P9000_OPTIONS_FONTDRAW_OPTIONS_USE_TERMINAL_FONTS,
	P9000_OPTIONS_FONTDRAW_OPTIONS_USE_NON_TERMINAL_FONTS,
	-1
};
static const char *const p9000_options_arcdraw_options_keywords[] =
{
	"draw-one-bit-arcs",
	0
};
static const int p9000_options_arcdraw_options_index_to_value[] =
{
	P9000_OPTIONS_ARCDRAW_OPTIONS_DRAW_ONE_BIT_ARCS,
	-1
};
static const char *const p9000_options_pointdraw_options_keywords[] =
{
	"use-plot-point",
	0
};
static const int p9000_options_pointdraw_options_index_to_value[] =
{
	P9000_OPTIONS_POINTDRAW_OPTIONS_USE_PLOT_POINT,
	-1
};
static const char *const p9000_options_spansfill_options_keywords[] =
{
	"use-solid-fill-spans",
	0
};
static const int p9000_options_spansfill_options_index_to_value[] =
{
	P9000_OPTIONS_SPANSFILL_OPTIONS_USE_SOLID_FILL_SPANS,
	-1
};
static const char *const p9000_options_allow_core_server_to_use_linear_frame_buffer_keywords[] =
{
	"yes",
	"no",
	0
};
static const enum p9000_options_allow_core_server_to_use_linear_frame_buffer p9000_options_allow_core_server_to_use_linear_frame_buffer_index_to_value[] =
{
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_YES,
	P9000_OPTIONS_ALLOW_CORE_SERVER_TO_USE_LINEAR_FRAME_BUFFER_NO,
	p9000_options_allow_core_server_to_use_linear_frame_buffer_end_enumeration
};


/*
 * Help message.
 */
static const char *const p9000_options_description = 
"si-interface-version\tThe version number that the SDD returns to the SI server.\n"
"verbose-startup\tPrint messages about chipset configuration if set to `yes'.\n"
"omm-named-allocation-list\tNamed allocation requests for the offscreen memory manager.  This option is primarily used to name `holes' in the video memory.\n"
"omm-horizontal-constraint\tThe widths of all offscreen memory requests are rounded up to this value.  O means use an internal heuristic.\n"
"omm-vertical-constraint\tThe heights of all offscreen memory requests are rounded up to this value.  0 means use an internal heuristic.\n"
"omm-neighbour-list-increment\tNumber of neighbour list nodes allocated at one time.  Neighbour lists are managed during every allocate and free operation.  0 means use an internal heuristic.\n"
"omm-full-coalesce-watermark\tIf the number of currently allocated blocks falls below this value the omm will attempt a full coalesion operation.  Remember that coalesion is an expensive operation.\n"
"omm-hash-list-size\tSize of the hash table of omm free blocks.  0 means use an an internal heuristic.\n"
"video-memory-dimensions\tVideo memory organization in pixels (WxH).\n"
"linear-frame-buffer-size\tSize in MB of linear frame buffer aperture.\n"
"clock-name\tThe type of clock chip on the video board.\n"
"dac-name\tThe type of DAC on board.\n"
"memory-configuration\tMemory configuration on board.  Use 3 for a 2M board and 2 for a 1M board.\n"
"p9000-base-address\tPhysical memory address at which the P9000 chipset and the frame buffer can be mapped.\n"
"dac-base-address\tPhysical memory address at which the RAMDAC on the board has to be I/O mapped.\n"
"vram-refresh-period\tNumber of cycles between memory refreshes.  A value of zero will select internal default\n"
"vram-ras-low-maximum\tMaximum amount of time the RAS signal can be asserted.  Zero selects internal default value.\n"
"dot-clock-divide\tDot clock divide factor\n"
"modedb-string\tModeDB entry in the following format: \"Clock Horizontal_timing Vertical_timing flags\".  Clock is in MHz.  The timing field consists of display, sync_start, sync_end and total timings in that order.\n"
"cursor-type\tCursor implementation types.\n"
"cursor-max-size\tMaximum size of the downloadable cursor in WXH format\n"
"dac-rgb-width\tNumber of significant bits per R/G/B output.  `default' will use the industry standard of 6.\n"
"dac-access-delay-count\tNumber of cycles to wait between dac accesses.\n"
"dac-24-bit-color-mode\tOrder of R/G/B pixels in a 32 bit word.\n"
"dac-16-bit-color-mode\tBits for R/G/B in 16 bit mode.\n"
"dac-max-frequency\tEvery dac has a maximum frequency to which it can operate without damaging itself/card/monitor.  This option allows overriding of the builtin default value for the dac.  A value of 0 (default) will use the builtin defaults.  UTMOST CAUTION SHOULD BE USED WHILE CHANGING THIS OPTION.  Wrong use can damage your system.  The value is in MHz.\n"
"bt485-clock-doubler-threshold\tBT485 manual recommends using the internal clock doubler beyond dot clock frequencies of 80MHz.  This option provides a way of specifying the threshold greater than which the clock doubler will be enabled.  A value of 0 indicates that clock doubler will not be used at all.\n"
"vt-switch-save-lines\tNumber of lines of screen to save.  Exact values would save the total memory occupied by the x server.\n"
"number-of-graphics-states\tNumber of SDD graphics states.  `0' means use internal default.\n"
"tile-best-size\tBest tile size as seen by the Si code\n"
"stipple-best-size\tBest stipple size as seen by si code.\n"
"two-color-tile-maximum-width\t2-Color tiles with width more than this value will not be converted to stipples.\n"
"two-color-tile-maximum-height\t2-Color tiles with height more than this value will not be converted to stipples.\n"
"offscreen-tile-padded-width\tPad small tiles to this value in offscreen memory.  Should be a power of two.\n"
"offscreen-tile-padded-height\tPad small tiles to this value in offscreen memory.  Should be a power of two.\n"
"maximum-offscreen-downloadable-tile-width\tDo not download tiles of more than this width into offscreen memory\n"
"maximum-offscreen-downloadable-tile-height\tDo not download tiles of more than this height into offscreen memory\n"
"graphics-engine-loop-timeout-count\tNumber of cycles to wait before signalling an error.\n"
"bitblt-options\tControlling fill functionality.\n"
"rectfill-options\tControlling fill functionality.\n"
"linedraw-options\tControlling zero-width lines and segment draw functionality.\n"
"fontdraw-options\tControlling the kinds of fonts that can be drawn\n"
"max-number-of-glyphs-in-downloadable-font\tThe maximum number of glyphs in a font suitable for downloading.  0 means ignore this criterion.\n"
"number-of-downloadable-fonts\tNumber of downloaded fonts.  `0' means to turn off font handling in the SDD.\n"
"max-font-glyph-size\tDimensions of the biggest glyph that will be processed by the SDD.\n"
"arcdraw-options\tControls the drawing operation for arcs.\n"
"pointdraw-options\tControlling plot point functionality.\n"
"spansfill-options\tControlling spans fill functionality.\n"
"allow-core-server-to-use-linear-frame-buffer\tAllow the core server to draw into the framebuffer.\n"
;

/*
 * Lookup a name in a table.
 */
static int
p9000_options_lookup_name(const char *name_p, const char *const *name_list_p)
{
	int name_index = 0;
	
	while (*name_list_p)
	{
		if (strcmp(*name_list_p, name_p))
		{
			name_index ++;
			name_list_p ++;
		}
		else
		{

#if (defined(__DEBUG__))
			if(p9000_options_debug)
			{
				(void) fprintf(debug_stream_p,
						"(p9000_options_ lookup) \"%s\" "
						"index = %d.\n", name_p, name_index);
					
			}
#endif
			return name_index;
			
		}
	}
	return -1;
	
}

/*
 * Get the next token.
 */

static char * 
p9000_options_parse_get_next_token(char *character_p)
{
	/* CONSTANTCONDITION */
	while (1)
	{
		/*
		 * Skip leading WS.
		 */
		while( (*character_p != EOS) && isspace(*character_p))
		{
			character_p ++;
		}
		if (*character_p == EOS)
		{
			break;
		}
		else if(*character_p == '#')
		{
			/*
			 * Comment.  Skip till new line.
			 */
			while ((*character_p != EOS) && (*character_p != '\n'))
			{
				character_p ++;
			}
		}
		else if (*character_p == '\\')
		{
			*character_p ++ = ' ';	/* replace '\' */
			*character_p = (*character_p == '\n') ? ' ' : *character_p;
		}
		else
		{
			return character_p;
		}
	}
	return (char *) 0;
}		

/*
 * p9000_options_parse : parse options.
 */
function struct p9000_options_structure *
p9000_options_parse (struct p9000_options_structure *option_struct_p,
			   const char *option_string_p)
{
	char * character_p;
	char * option_check_integer_p; /* return value of strtol() */
	struct stat stat_buf;
	
	char *option_list_p;		/* modifiable copy of option list */
	int option_name_index;		/* option keyword index */
	int option_enum_index;		/* enumeration value index */
	int option_enum_is_inverted; /* for !<value> parsing */
	
	char *tmp_p;				/* temporary */
	char *option_name_p, *option_value_p; /* for separating name=value */
	FILE *option_file_p;
	
	
	if (!option_struct_p)
	{
		option_struct_p = allocate_memory(sizeof (struct
												  p9000_options_structure));
		if (!option_struct_p)
		{
			perror(OPTION_MESSAGE_CANNOT_ALLOCATE_MEMORY);
			goto error;
			
		}
		
		/*
		 * Copy the defaults.
		 */
		*option_struct_p = p9000_options_default;
		
	}

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) "
				"option_string = \"%s\"\n", option_string_p);
	}
#endif

	/*
	 * Save the option string as we are going to munge it.
	 */
	option_list_p = strdup(option_string_p);
	
	character_p =
		p9000_options_parse_get_next_token(option_list_p);
	
	while(character_p)
	{
		/*
		 * parse the token, looking for name'='value pairs.
		 */
		option_name_p = character_p;
		while ((*character_p != EOS) && 
			   (*character_p != '='))
		{
			character_p ++;
		}
		if (*character_p != '=')
		{
			/*
			 * Error encountered.
			 */
			(void) fprintf(stderr, 
						   OPTION_MESSAGE_MALFORMED_OPTION_STRING,
						   option_name_p);
			
			free_memory(option_list_p);
			return (struct p9000_options_structure *) 0;
			
		}
		else
		{
			*character_p++ = EOS;
			if (*character_p == EOS)
			{
				/*
				 * Error encountered.
				 */
				(void) fprintf(stderr, 
							   OPTION_MESSAGE_MALFORMED_OPTION_STRING,
							   option_name_p);
			
				free_memory(option_list_p);
				return (struct p9000_options_structure *) 0;
				
			}
			/*
			 * Look for terminating white-space.
			 */
			if (*character_p == '\"')
			{
				/*
				 * Terminated by a '\"'.
				 */
				*character_p ++ = EOS;
				option_value_p = character_p;
				
				while ((*character_p != EOS) && 
					   (*character_p != '\"'))
				{
					character_p ++;
				}
				if (*character_p == EOS)
				{
					(void) fprintf(stderr,
						OPTION_MESSAGE_UNTERMINATED_STRING_CONSTANT,
								   option_name_p);
					free_memory (option_list_p);
					return (struct p9000_options_structure *) 0;
				}
				else
				{
					*character_p ++ = EOS;
				}
			}
			else
			{
				/*
				 * White space terminated.
				 */
				option_value_p = character_p;

				/* CONSTANTCONDITION */
				while (1)
				{
					
					while ( (*character_p != EOS) && ! isspace(*character_p))
					{
						character_p ++;
					}
			
					if (*character_p != EOS)
					{

						if (*character_p == '\n' && *(character_p-1) == '\\')
						{
							/*
							 * Skip backslashed newline.
							 */
							character_p ++;
						}
						else
						{
							*character_p++ = EOS;
							break;
						}
					}
					else
					{
						break;
					}

				}			
			}
		}

		/*
		 * Analyze the option name and option value extracted.
		 */
		option_name_index =
			p9000_options_lookup_name(option_name_p, &(p9000_options_keywords[0]));
				
		if (option_name_index == -1)
		{
			(void) fprintf(stderr,
					OPTION_MESSAGE_UNRECOGNIZED_OPTION,
					option_name_p);
			free_memory (option_list_p);
			return (struct p9000_options_structure *) 0;
		}
#if (defined(__DEBUG__))
		else
		{
			if (p9000_options_debug)
			{
				(void) fprintf(debug_stream_p,
						"(p9000_options_parse) recognized "
						"\"%s\" of type \"%s\", value "
						"\"%s\".\n", 
						option_name_p,
						option_type_dump[option_index_to_option_kind[option_name_index]],
						option_value_p);
				
			}
		}
#endif
	
		/*
		 * Depending on the kind of code, take action.
		 */
		switch (option_name_index)
		{

			
case 0 :	/* allow-core-server-to-use-linear-frame-buffer */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_allow_core_server_to_use_linear_frame_buffer_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "allow-core-server-to-use-linear-frame-buffer");
		goto error;
	}
	option_struct_p->allow_core_server_to_use_linear_frame_buffer = p9000_options_allow_core_server_to_use_linear_frame_buffer_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum allow-core-server-to-use-linear-frame-buffer value '%s'\n",
			p9000_options_allow_core_server_to_use_linear_frame_buffer_keywords[option_enum_index]);
	}
#endif
	break;

case 1 :	/* arcdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_arcdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "arcdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->arcdraw_options &= 
				(~p9000_options_arcdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->arcdraw_options |= 
				(p9000_options_arcdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum arcdraw-options value %d.\n",
			option_struct_p->arcdraw_options);
	}
#endif

	break;

case 2 :	/* bitblt-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_bitblt_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "bitblt-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->bitblt_options &= 
				(~p9000_options_bitblt_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->bitblt_options |= 
				(p9000_options_bitblt_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum bitblt-options value %d.\n",
			option_struct_p->bitblt_options);
	}
#endif

	break;


case 3 :	/* bt485-clock-doubler-threshold */
	option_struct_p->bt485_clock_doubler_threshold = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->bt485_clock_doubler_threshold == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"bt485-clock-doubler-threshold");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	bt485-clock-doubler-threshold = %d\n",
				option_struct_p->bt485_clock_doubler_threshold);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->bt485_clock_doubler_threshold >= 0) && (option_struct_p->bt485_clock_doubler_threshold <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"bt485-clock-doubler-threshold");
		goto error;
	}

	break;

case 4 :	/* clock-name */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_clock_name_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "clock-name");
		goto error;
	}
	option_struct_p->clock_name = p9000_options_clock_name_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum clock-name value '%s'\n",
			p9000_options_clock_name_keywords[option_enum_index]);
	}
#endif
	break;

case 5 :	/* cursor-max-size */
	option_struct_p->cursor_max_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	cursor-max-size = \"%s\"\n",
			option_struct_p->cursor_max_size);
	}
#endif

	break;

case 6 :	/* cursor-type */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_cursor_type_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "cursor-type");
		goto error;
	}
	option_struct_p->cursor_type = p9000_options_cursor_type_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum cursor-type value '%s'\n",
			p9000_options_cursor_type_keywords[option_enum_index]);
	}
#endif
	break;

case 7 :	/* dac-16-bit-color-mode */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_dac_16_bit_color_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "dac-16-bit-color-mode");
		goto error;
	}
	option_struct_p->dac_16_bit_color_mode = p9000_options_dac_16_bit_color_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum dac-16-bit-color-mode value '%s'\n",
			p9000_options_dac_16_bit_color_mode_keywords[option_enum_index]);
	}
#endif
	break;

case 8 :	/* dac-24-bit-color-mode */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_dac_24_bit_color_mode_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "dac-24-bit-color-mode");
		goto error;
	}
	option_struct_p->dac_24_bit_color_mode = p9000_options_dac_24_bit_color_mode_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum dac-24-bit-color-mode value '%s'\n",
			p9000_options_dac_24_bit_color_mode_keywords[option_enum_index]);
	}
#endif
	break;


case 9 :	/* dac-access-delay-count */
	option_struct_p->dac_access_delay_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dac_access_delay_count == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"dac-access-delay-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-access-delay-count = %d\n",
				option_struct_p->dac_access_delay_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dac_access_delay_count >= 1) && (option_struct_p->dac_access_delay_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"dac-access-delay-count");
		goto error;
	}

	break;

case 10 :	/* dac-base-address */
	option_struct_p->dac_base_address = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-base-address = \"%s\"\n",
			option_struct_p->dac_base_address);
	}
#endif

	break;


case 11 :	/* dac-max-frequency */
	option_struct_p->dac_max_frequency = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dac_max_frequency == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"dac-max-frequency");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dac-max-frequency = %d\n",
				option_struct_p->dac_max_frequency);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dac_max_frequency >= 0) && (option_struct_p->dac_max_frequency <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"dac-max-frequency");
		goto error;
	}

	break;

case 12 :	/* dac-name */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_dac_name_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "dac-name");
		goto error;
	}
	option_struct_p->dac_name = p9000_options_dac_name_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum dac-name value '%s'\n",
			p9000_options_dac_name_keywords[option_enum_index]);
	}
#endif
	break;

case 13 :	/* dac-rgb-width */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_dac_rgb_width_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "dac-rgb-width");
		goto error;
	}
	option_struct_p->dac_rgb_width = p9000_options_dac_rgb_width_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum dac-rgb-width value '%s'\n",
			p9000_options_dac_rgb_width_keywords[option_enum_index]);
	}
#endif
	break;


case 14 :	/* dot-clock-divide */
	option_struct_p->dot_clock_divide = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->dot_clock_divide == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"dot-clock-divide");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	dot-clock-divide = %d\n",
				option_struct_p->dot_clock_divide);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->dot_clock_divide >= 4) && (option_struct_p->dot_clock_divide <= INT_MAX)) || ((option_struct_p->dot_clock_divide >= 8) && (option_struct_p->dot_clock_divide <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"dot-clock-divide");
		goto error;
	}

	break;

case 15 :	/* fontdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_fontdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "fontdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->fontdraw_options &= 
				(~p9000_options_fontdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->fontdraw_options |= 
				(p9000_options_fontdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum fontdraw-options value %d.\n",
			option_struct_p->fontdraw_options);
	}
#endif

	break;


case 16 :	/* graphics-engine-loop-timeout-count */
	option_struct_p->graphics_engine_loop_timeout_count = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->graphics_engine_loop_timeout_count == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"graphics-engine-loop-timeout-count");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	graphics-engine-loop-timeout-count = %d\n",
				option_struct_p->graphics_engine_loop_timeout_count);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->graphics_engine_loop_timeout_count >= 1) && (option_struct_p->graphics_engine_loop_timeout_count <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"graphics-engine-loop-timeout-count");
		goto error;
	}

	break;


case 17 :	/* linear-frame-buffer-size */
	option_struct_p->linear_frame_buffer_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->linear_frame_buffer_size == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"linear-frame-buffer-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	linear-frame-buffer-size = %d\n",
				option_struct_p->linear_frame_buffer_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->linear_frame_buffer_size >= 0) && (option_struct_p->linear_frame_buffer_size <= 4)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"linear-frame-buffer-size");
		goto error;
	}

	break;

case 18 :	/* linedraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_linedraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "linedraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->linedraw_options &= 
				(~p9000_options_linedraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->linedraw_options |= 
				(p9000_options_linedraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum linedraw-options value %d.\n",
			option_struct_p->linedraw_options);
	}
#endif

	break;

case 19 :	/* max-font-glyph-size */
	option_struct_p->max_font_glyph_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	max-font-glyph-size = \"%s\"\n",
			option_struct_p->max_font_glyph_size);
	}
#endif

	break;


case 20 :	/* max-number-of-glyphs-in-downloadable-font */
	option_struct_p->max_number_of_glyphs_in_downloadable_font = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->max_number_of_glyphs_in_downloadable_font == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"max-number-of-glyphs-in-downloadable-font");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	max-number-of-glyphs-in-downloadable-font = %d\n",
				option_struct_p->max_number_of_glyphs_in_downloadable_font);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->max_number_of_glyphs_in_downloadable_font >= 0) && (option_struct_p->max_number_of_glyphs_in_downloadable_font <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"max-number-of-glyphs-in-downloadable-font");
		goto error;
	}

	break;


case 21 :	/* maximum-offscreen-downloadable-tile-height */
	option_struct_p->maximum_offscreen_downloadable_tile_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->maximum_offscreen_downloadable_tile_height == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"maximum-offscreen-downloadable-tile-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	maximum-offscreen-downloadable-tile-height = %d\n",
				option_struct_p->maximum_offscreen_downloadable_tile_height);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->maximum_offscreen_downloadable_tile_height >= 1) && (option_struct_p->maximum_offscreen_downloadable_tile_height <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"maximum-offscreen-downloadable-tile-height");
		goto error;
	}

	break;


case 22 :	/* maximum-offscreen-downloadable-tile-width */
	option_struct_p->maximum_offscreen_downloadable_tile_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->maximum_offscreen_downloadable_tile_width == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"maximum-offscreen-downloadable-tile-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	maximum-offscreen-downloadable-tile-width = %d\n",
				option_struct_p->maximum_offscreen_downloadable_tile_width);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->maximum_offscreen_downloadable_tile_width >= 1) && (option_struct_p->maximum_offscreen_downloadable_tile_width <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"maximum-offscreen-downloadable-tile-width");
		goto error;
	}

	break;

case 23 :	/* memory-configuration */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_memory_configuration_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "memory-configuration");
		goto error;
	}
	option_struct_p->memory_configuration = p9000_options_memory_configuration_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum memory-configuration value '%s'\n",
			p9000_options_memory_configuration_keywords[option_enum_index]);
	}
#endif
	break;

case 24 :	/* modedb-string */
	option_struct_p->modedb_string = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	modedb-string = \"%s\"\n",
			option_struct_p->modedb_string);
	}
#endif

	break;


case 25 :	/* number-of-downloadable-cursors */
	option_struct_p->number_of_downloadable_cursors = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_downloadable_cursors == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"number-of-downloadable-cursors");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-downloadable-cursors = %d\n",
				option_struct_p->number_of_downloadable_cursors);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_downloadable_cursors >= 0) && (option_struct_p->number_of_downloadable_cursors <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"number-of-downloadable-cursors");
		goto error;
	}

	break;


case 26 :	/* number-of-downloadable-fonts */
	option_struct_p->number_of_downloadable_fonts = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_downloadable_fonts == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"number-of-downloadable-fonts");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-downloadable-fonts = %d\n",
				option_struct_p->number_of_downloadable_fonts);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_downloadable_fonts >= 0) && (option_struct_p->number_of_downloadable_fonts <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"number-of-downloadable-fonts");
		goto error;
	}

	break;


case 27 :	/* number-of-graphics-states */
	option_struct_p->number_of_graphics_states = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->number_of_graphics_states == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"number-of-graphics-states");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	number-of-graphics-states = %d\n",
				option_struct_p->number_of_graphics_states);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->number_of_graphics_states >= 0) && (option_struct_p->number_of_graphics_states <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"number-of-graphics-states");
		goto error;
	}

	break;


case 28 :	/* offscreen-tile-padded-height */
	option_struct_p->offscreen_tile_padded_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_tile_padded_height == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"offscreen-tile-padded-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-tile-padded-height = %d\n",
				option_struct_p->offscreen_tile_padded_height);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_tile_padded_height >= 1) && (option_struct_p->offscreen_tile_padded_height <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"offscreen-tile-padded-height");
		goto error;
	}

	break;


case 29 :	/* offscreen-tile-padded-width */
	option_struct_p->offscreen_tile_padded_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->offscreen_tile_padded_width == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"offscreen-tile-padded-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	offscreen-tile-padded-width = %d\n",
				option_struct_p->offscreen_tile_padded_width);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->offscreen_tile_padded_width >= 1) && (option_struct_p->offscreen_tile_padded_width <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"offscreen-tile-padded-width");
		goto error;
	}

	break;


case 30 :	/* omm-full-coalesce-watermark */
	option_struct_p->omm_full_coalesce_watermark = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_full_coalesce_watermark == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"omm-full-coalesce-watermark");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-full-coalesce-watermark = %d\n",
				option_struct_p->omm_full_coalesce_watermark);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_full_coalesce_watermark >= 0) && (option_struct_p->omm_full_coalesce_watermark <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"omm-full-coalesce-watermark");
		goto error;
	}

	break;


case 31 :	/* omm-hash-list-size */
	option_struct_p->omm_hash_list_size = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_hash_list_size == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"omm-hash-list-size");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-hash-list-size = %d\n",
				option_struct_p->omm_hash_list_size);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_hash_list_size >= 0) && (option_struct_p->omm_hash_list_size <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"omm-hash-list-size");
		goto error;
	}

	break;


case 32 :	/* omm-horizontal-constraint */
	option_struct_p->omm_horizontal_constraint = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_horizontal_constraint == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"omm-horizontal-constraint");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-horizontal-constraint = %d\n",
				option_struct_p->omm_horizontal_constraint);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_horizontal_constraint >= 0) && (option_struct_p->omm_horizontal_constraint <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"omm-horizontal-constraint");
		goto error;
	}

	break;

case 33 :	/* omm-named-allocation-list */
	option_struct_p->omm_named_allocation_list = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-named-allocation-list = \"%s\"\n",
			option_struct_p->omm_named_allocation_list);
	}
#endif

	break;


case 34 :	/* omm-neighbour-list-increment */
	option_struct_p->omm_neighbour_list_increment = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_neighbour_list_increment == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"omm-neighbour-list-increment");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-neighbour-list-increment = %d\n",
				option_struct_p->omm_neighbour_list_increment);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_neighbour_list_increment >= 0) && (option_struct_p->omm_neighbour_list_increment <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"omm-neighbour-list-increment");
		goto error;
	}

	break;


case 35 :	/* omm-vertical-constraint */
	option_struct_p->omm_vertical_constraint = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->omm_vertical_constraint == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"omm-vertical-constraint");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	omm-vertical-constraint = %d\n",
				option_struct_p->omm_vertical_constraint);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->omm_vertical_constraint >= 0) && (option_struct_p->omm_vertical_constraint <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"omm-vertical-constraint");
		goto error;
	}

	break;

case 36 :	/* options-file */
	/*
	 * look up the file.
	 */
	if (stat(option_value_p, &stat_buf) != 0)
	{
		/*
		 * Warn the user of missing files, and continue.
		 */
		(void) fprintf(stderr, 
					OPTION_MESSAGE_CANNOT_STAT_FILE_ARGUMENT,
					option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		break;
	}

	if (stat_buf.st_size == 0)
	{
		/*
		 * Warn the user of zero length files, and continue.
		 */
		(void) fprintf(stderr,
					OPTION_MESSAGE_ZERO_LENGTH_FILE_ARGUMENT,
					option_value_p, "options-file");
		break;
	}

	/* read the option file into a buffer */
	if (!(tmp_p = allocate_and_clear_memory(stat_buf.st_size+1)))
	{
		perror(OPTION_MESSAGE_CANNOT_ALLOCATE_MEMORY);
		goto error;
	}

	if( (option_file_p = fopen(option_value_p, "r")) == NULL)
	{

		(void) fprintf(stderr, 
				OPTION_MESSAGE_CANNOT_OPEN_FILE_ARGUMENT,
				option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		goto error;
	}
	if (fread(tmp_p, stat_buf.st_size, 1, option_file_p) != 1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_CANNOT_READ_FILE_ARGUMENT,
				option_value_p, "options-file");
		perror(LIBRARY_NAME ": Reason ");
		goto error;
	}

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "\t\"%s\"\n", tmp_p);
	}
#endif
	/*
	 * Recursively invoke the interpreter.
	 */
	if (!p9000_options_parse(option_struct_p, tmp_p))
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_CANNOT_PROCESS_FILE_ARGUMENT,
				option_value_p, "options-file");
		free_memory(tmp_p);
		goto error;
	}
	free_memory(tmp_p);
	break;

case 37 :	/* options-variable */

	tmp_p = getenv(option_value_p);
	if (tmp_p)
	{

#if (defined(__DEBUG__))
		if (p9000_options_debug)
		{
			(void) fprintf(debug_stream_p, "\t\"%s\"\n", tmp_p);
		}
#endif
		if (!p9000_options_parse(option_struct_p, tmp_p))
		{
			(void) fprintf(stderr, 
					OPTION_MESSAGE_CANNOT_PROCESS_ENVIRONMENT_ARGUMENT,
				option_value_p, "options-variable");
			goto error;
		}

	}
	break;

case 38 :	/* p9000-base-address */
	option_struct_p->p9000_base_address = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	p9000-base-address = \"%s\"\n",
			option_struct_p->p9000_base_address);
	}
#endif

	break;

case 39 :	/* pointdraw-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_pointdraw_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "pointdraw-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->pointdraw_options &= 
				(~p9000_options_pointdraw_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->pointdraw_options |= 
				(p9000_options_pointdraw_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum pointdraw-options value %d.\n",
			option_struct_p->pointdraw_options);
	}
#endif

	break;

case 40 :	/* rectfill-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_rectfill_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "rectfill-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->rectfill_options &= 
				(~p9000_options_rectfill_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->rectfill_options |= 
				(p9000_options_rectfill_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum rectfill-options value %d.\n",
			option_struct_p->rectfill_options);
	}
#endif

	break;

case 41 :	/* si-interface-version */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_si_interface_version_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "si-interface-version");
		goto error;
	}
	option_struct_p->si_interface_version = p9000_options_si_interface_version_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum si-interface-version value '%s'\n",
			p9000_options_si_interface_version_keywords[option_enum_index]);
	}
#endif
	break;

case 42 :	/* spansfill-options */
	while (*option_value_p)
	{	
		tmp_p = option_value_p;
		/* skip till a comma */
		while((*tmp_p != EOS) && (*tmp_p != ','))
		{
			tmp_p ++;
		}
		if (*tmp_p)
		{
			*tmp_p++ = EOS;
		}

		if (*option_value_p == '!')
		{
			option_value_p ++;
			option_enum_is_inverted = 1;
		}
		else
		{
			option_enum_is_inverted = 0;
		}
		option_enum_index = 
			p9000_options_lookup_name(option_value_p, &(p9000_options_spansfill_options_keywords[0]));

		if (option_enum_index == -1)
		{
			(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
				option_value_p, "spansfill-options");
			goto error;
		}
		if (option_enum_is_inverted)
		{
			option_struct_p->spansfill_options &= 
				(~p9000_options_spansfill_options_index_to_value[option_enum_index]);
		}
		else
		{
			option_struct_p->spansfill_options |= 
				(p9000_options_spansfill_options_index_to_value[option_enum_index]);
		}

		option_value_p = tmp_p;
	}

#if (defined(__DEBUG__))
	if(p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "(p9000_options_parse) enum spansfill-options value %d.\n",
			option_struct_p->spansfill_options);
	}
#endif

	break;

case 43 :	/* stipple-best-size */
	option_struct_p->stipple_best_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	stipple-best-size = \"%s\"\n",
			option_struct_p->stipple_best_size);
	}
#endif

	break;

case 44 :	/* tile-best-size */
	option_struct_p->tile_best_size = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	tile-best-size = \"%s\"\n",
			option_struct_p->tile_best_size);
	}
#endif

	break;


case 45 :	/* two-color-tile-maximum-height */
	option_struct_p->two_color_tile_maximum_height = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->two_color_tile_maximum_height == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"two-color-tile-maximum-height");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	two-color-tile-maximum-height = %d\n",
				option_struct_p->two_color_tile_maximum_height);
	}
#endif 


	break;


case 46 :	/* two-color-tile-maximum-width */
	option_struct_p->two_color_tile_maximum_width = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->two_color_tile_maximum_width == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"two-color-tile-maximum-width");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	two-color-tile-maximum-width = %d\n",
				option_struct_p->two_color_tile_maximum_width);
	}
#endif 


	break;

case 47 :	/* verbose-startup */
	if ((option_enum_index = 
		p9000_options_lookup_name(option_value_p, &(p9000_options_verbose_startup_keywords[0])))
		== -1)
	{
		(void) fprintf(stderr, 
				OPTION_MESSAGE_INCORRECT_ENUMERATION_VALUE,
					option_value_p, "verbose-startup");
		goto error;
	}
	option_struct_p->verbose_startup = p9000_options_verbose_startup_index_to_value[option_enum_index];

#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p,
			"(p9000_options_parse) enum verbose-startup value '%s'\n",
			p9000_options_verbose_startup_keywords[option_enum_index]);
	}
#endif
	break;

case 48 :	/* video-memory-dimensions */
	option_struct_p->video_memory_dimensions = strdup(option_value_p);
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	video-memory-dimensions = \"%s\"\n",
			option_struct_p->video_memory_dimensions);
	}
#endif

	break;


case 49 :	/* vram-ras-low-maximum */
	option_struct_p->vram_ras_low_maximum = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->vram_ras_low_maximum == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"vram-ras-low-maximum");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	vram-ras-low-maximum = %d\n",
				option_struct_p->vram_ras_low_maximum);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->vram_ras_low_maximum >= 0) && (option_struct_p->vram_ras_low_maximum <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"vram-ras-low-maximum");
		goto error;
	}

	break;


case 50 :	/* vram-refresh-period */
	option_struct_p->vram_refresh_period = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->vram_refresh_period == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"vram-refresh-period");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	vram-refresh-period = %d\n",
				option_struct_p->vram_refresh_period);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->vram_refresh_period >= 0) && (option_struct_p->vram_refresh_period <= INT_MAX)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"vram-refresh-period");
		goto error;
	}

	break;


case 51 :	/* vt-switch-save-lines */
	option_struct_p->vt_switch_save_lines = 
		strtol(option_value_p, &option_check_integer_p, 0);
	if(option_check_integer_p == option_value_p &&
		option_struct_p->vt_switch_save_lines == 0)
	{
		(void) fprintf(stderr, OPTION_MESSAGE_BAD_INTEGER,
				"vt-switch-save-lines");
		goto error;
	}
			
#if (defined(__DEBUG__))
	if (p9000_options_debug)
	{
		(void) fprintf(debug_stream_p, "	vt-switch-save-lines = %d\n",
				option_struct_p->vt_switch_save_lines);
	}
#endif 


	/* CONSTANTCONDITION */
	if (!(0|| ((option_struct_p->vt_switch_save_lines >= 0) && (option_struct_p->vt_switch_save_lines <= 4096)) ))
	{
		(void) fprintf(stderr, 
			OPTION_MESSAGE_INTEGER_OPTION_OUT_OF_BOUNDS,
			"vt-switch-save-lines");
		goto error;
	}

	break;


			default :
				(void) fprintf(stderr,
						OPTION_MESSAGE_INTERNAL_ERROR);
				free_memory(option_list_p);
				return (struct p9000_options_structure *) 0;
			
		}
		
		/*
		 * while ...
		 */
		character_p = 
			p9000_options_parse_get_next_token(character_p);
		
	}
	/*
	 * Free the space we allocated.
	 */
	free_memory(option_list_p);
	
	return option_struct_p;

  error:
	if (option_list_p)
	{
		free_memory(option_list_p);
	}
	
	return (struct p9000_options_structure *) 0;
	
}

#if (defined(__TEST__))
int
main(int parameter_count, char ** parameter_pp)
{
	int i;
	int string_length = 0;
	char * options_p;

#if (defined(__DEBUG__))
	p9000_options_debug = 
		getenv("p9000_options_debug") ? TRUE :	FALSE;
	if (debug_stream_p == NULL && (debug_stream_p =
		    fopen(getenv("debug_stream"), "w")) == NULL)
	{
		debug_stream_p = stdout;
	}
#endif

	for(i = 1; i < parameter_count; i++)
	{
		string_length += strlen(*(parameter_pp + i));
	}
	options_p = allocate_memory(string_length + 1);
	*options_p = EOS;
	
	for(i = 1; i < parameter_count; i++)
	{
		strcat(options_p, *(parameter_pp +i));
	}

	p9000_options_parse(0, options_p);

}

#endif
