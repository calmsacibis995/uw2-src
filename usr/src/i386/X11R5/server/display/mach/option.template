
/***								-*- C -*-
 ***
 ***	Warning!  Target file, do not modify.
 ***	
 ***	Generated from: %FILEHEADER%
 ***
 ***	Generated by: (%TOOLVERSION%).
 ***
 ***/

#ident	"@(#)mach:mach/option.template	1.1"

PUBLIC

#include "stdenv.h"
#include "global.h"

%ENUMERATIONS%

%DEFINES%

struct %PREFIX%structure
{
%OPTION_STRUCTURE_MEMBER_LIST%
};

/*
 * Names of the option defaults
 */

%DEFAULTNAMES%

#if (defined(__DEBUG__))
export boolean	%PREFIX%debug = FALSE;
#endif


PRIVATE
#include <string.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <limits.h>

/*
 * The types of options.
 */

enum %PREFIX%kind
{
%OPTION_TYPES_ENUMERATION%
	%PREFIX%end_option_types
};

#if (defined(__DEBUG__))

static const char *const option_type_dump[] = 
{
%OPTION_TYPES_DUMP%
	0
};

#endif

/*
 * The default options.
 */
static struct %PREFIX%structure %PREFIX%default =
{
%DEFAULT%
};

/*
 * The list of option keywords.
 */

static const char *const %PREFIX%keywords[] = 
{
%OPTION_KEYWORDS%
	0
};
/*
 * This array maps the option index to the option kind.
 */
static enum %PREFIX%kind option_index_to_option_kind[] =
{
%OPTION_INDICES%
	%PREFIX%end_option_types
};



/*
 * List of enumeration keywords.
 */

%ENUMERATION_DUMP%

/*
 * Help message.
 */
static const char *const %PREFIX%description = 
%DESCRIPTION%;

/*
 * Lookup a name in a table.
 */
static int
%PREFIX%lookup_name(const char *name_p, const char *const *name_list_p)
{
	int name_index = 0;
	
	while (*name_list_p)
	{
		if (strcmp(*name_list_p, name_p))
		{
			name_index ++;
			name_list_p ++;
		}
		else
		{

#if (defined(__DEBUG__))
			if(%PREFIX%debug)
			{
				(void) fprintf(debug_stream_p,
						"(%PREFIX% lookup) \"%s\" "
						"index = %d.\n", name_p, name_index);
					
			}
#endif
			return name_index;
			
		}
	}
	return -1;
	
}

/*
 * Get the next token.
 */

static char * 
%PREFIX%parse_get_next_token(char *character_p)
{
	/* CONSTANTCONDITION */
	while (1)
	{
		/*
		 * Skip leading WS.
		 */
		while( (*character_p != EOS) && isspace(*character_p))
		{
			character_p ++;
		}
		if (*character_p == EOS)
		{
			break;
		}
		else if(*character_p == '#')
		{
			/*
			 * Comment.  Skip till new line.
			 */
			while ((*character_p != EOS) && (*character_p != '\n'))
			{
				character_p ++;
			}
		}
		else if (*character_p == '\\')
		{
			*character_p ++ = ' ';	/* replace '\' */
			*character_p = (*character_p == '\n') ? ' ' : *character_p;
		}
		else
		{
			return character_p;
		}
	}
	return (char *) 0;
}		

/*
 * %PREFIX%parse : parse options.
 */
function struct %PREFIX%structure *
%PREFIX%parse (struct %PREFIX%structure *option_struct_p,
			   const char *option_string_p)
{
	char * character_p;
	char * option_check_integer_p; /* return value of strtol() */
	struct stat stat_buf;
	
	char *option_list_p;		/* modifiable copy of option list */
	int option_name_index;		/* option keyword index */
	int option_enum_index;		/* enumeration value index */
	int option_enum_is_inverted; /* for !<value> parsing */
	
	char *tmp_p;				/* temporary */
	char *option_name_p, *option_value_p; /* for separating name=value */
	FILE *option_file_p;
	
	
	if (!option_struct_p)
	{
		option_struct_p = allocate_memory(sizeof (struct
												  %PREFIX%structure));
		if (!option_struct_p)
		{
			perror(DEFAULT_OPTION_CANNOT_ALLOCATE_MEMORY_MESSAGE);
			goto error;
			
		}
		
		/*
		 * Copy the defaults.
		 */
		*option_struct_p = %PREFIX%default;
		
	}

#if (defined(__DEBUG__))
	if (%PREFIX%debug)
	{
		(void) fprintf(debug_stream_p, "(%PREFIX%parse) "
				"option_string = \"%s\"\n", option_string_p);
	}
#endif

	/*
	 * Save the option string as we are going to munge it.
	 */
	option_list_p = strdup(option_string_p);
	
	character_p =
		%PREFIX%parse_get_next_token(option_list_p);
	
	while(character_p)
	{
		/*
		 * parse the token, looking for name'='value pairs.
		 */
		option_name_p = character_p;
		while ((*character_p != EOS) && 
			   (*character_p != '='))
		{
			character_p ++;
		}
		if (*character_p != '=')
		{
			/*
			 * Error encountered.
			 */
			(void) fprintf(stderr, 
						   DEFAULT_OPTION_MALFORMED_OPTION_STRING_MESSAGE,
						   option_name_p);
			
			free_memory(option_list_p);
			return (struct %PREFIX%structure *) 0;
			
		}
		else
		{
			*character_p++ = EOS;
			if (*character_p == EOS)
			{
				/*
				 * Error encountered.
				 */
				(void) fprintf(stderr, 
							   DEFAULT_OPTION_MALFORMED_OPTION_STRING_MESSAGE,
							   option_name_p);
			
				free_memory(option_list_p);
				return (struct %PREFIX%structure *) 0;
				
			}
			/*
			 * Look for terminating white-space.
			 */
			if (*character_p == '\"')
			{
				/*
				 * Terminated by a '\"'.
				 */
				*character_p ++ = EOS;
				option_value_p = character_p;
				
				while ((*character_p != EOS) && 
					   (*character_p != '\"'))
				{
					character_p ++;
				}
				if (*character_p == EOS)
				{
					(void) fprintf(stderr,
						DEFAULT_OPTION_UNTERMINATED_STRING_CONSTANT_MESSAGE,
								   option_name_p);
					free_memory (option_list_p);
					return (struct %PREFIX%structure *) 0;
				}
				else
				{
					*character_p ++ = EOS;
				}
			}
			else
			{
				/*
				 * White space terminated.
				 */
				option_value_p = character_p;

				/* CONSTANTCONDITION */
				while (1)
				{
					
					while ( (*character_p != EOS) && ! isspace(*character_p))
					{
						character_p ++;
					}
			
					if (*character_p != EOS)
					{

						if (*character_p == '\n' && *(character_p-1) == '\\')
						{
							/*
							 * Skip backslashed newline.
							 */
							character_p ++;
						}
						else
						{
							*character_p++ = EOS;
							break;
						}
					}
					else
					{
						break;
					}

				}			
			}
		}

		/*
		 * Analyze the option name and option value extracted.
		 */
		option_name_index =
			%PREFIX%lookup_name(option_name_p, &(%PREFIX%keywords[0]));
				
		if (option_name_index == -1)
		{
			(void) fprintf(stderr,
					DEFAULT_OPTION_UNRECOGNIZED_OPTION_MESSAGE,
					option_name_p);
			free_memory (option_list_p);
			return (struct %PREFIX%structure *) 0;
		}
#if (defined(__DEBUG__))
		else
		{
			if (%PREFIX%debug)
			{
				(void) fprintf(debug_stream_p,
						"(%PREFIX%parse) recognized "
						"\"%s\" of type \"%s\", value "
						"\"%s\".\n", 
						option_name_p,
						option_type_dump[option_index_to_option_kind[option_name_index]],
						option_value_p);
				
			}
		}
#endif
	
		/*
		 * Depending on the kind of code, take action.
		 */
		switch (option_name_index)
		{

			%PARSING_CODE%

			default :
				(void) fprintf(stderr,
						DEFAULT_OPTION_INTERNAL_ERROR_MESSAGE);
				free_memory(option_list_p);
				return (struct %PREFIX%structure *) 0;
			
		}
		
		/*
		 * while ...
		 */
		character_p = 
			%PREFIX%parse_get_next_token(character_p);
		
	}
	/*
	 * Free the space we allocated.
	 */
	free_memory(option_list_p);
	
	return option_struct_p;

  error:
	if (option_list_p)
	{
		free_memory(option_list_p);
	}
	
	return (struct %PREFIX%structure *) 0;
	
}

#if (defined(__TEST__))
int
main(int parameter_count, char ** parameter_pp)
{
	int i;
	int string_length = 0;
	char * options_p;

#if (defined(__DEBUG__))
	%PREFIX%debug = 
		getenv("%PREFIX%debug") ? TRUE :	FALSE;
	if (debug_stream_p == NULL && (debug_stream_p =
		    fopen(getenv("debug_stream"), "w")) == NULL)
	{
		debug_stream_p = stdout;
	}
#endif

	for(i = 1; i < parameter_count; i++)
	{
		string_length += strlen(*(parameter_pp + i));
	}
	options_p = allocate_memory(string_length + 1);
	*options_p = EOS;
	
	for(i = 1; i < parameter_count; i++)
	{
		strcat(options_p, *(parameter_pp +i));
	}

	%PREFIX%parse(0, options_p);

}

#endif
