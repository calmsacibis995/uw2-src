# This file contains the help messages used by the Command Line interface.
# Each help message is bracketed by lines starting with ++.
# The debugger does not depend on the size (number of lines) of any message,
# but it does depend on the order of the messages.  New messages MUST be
# added to the end of the file.

# This version is for the version of debug that supports threads

++ !
NAME
! - f¸hrt einen Shell-Befehl aus.

SYNOPSIS
! befehl_zeile 
!!

BESCHREIBUNG
F¸hrt einen Shell-Befehl aus. Der Rest der Zeile wird an die
Shell zur Verarbeitung ¸bergeben. Besonders die Umleitung wird
NICHT vom Debugger, sondern von der Shell ausgef¸hrt. Die
Variable $SHELL enth‰lt, wenn sie gesetzt ist, die komplette
Pfadbezeichnung der zu verwendenden Shell. Wenn $SHELL nihct
angegeben ist, wird /usr/bin/sh verwendet. Der Debugger wartet,
bis der Befehl ausgef¸hrt ist, ¸bernimmt aber nicht die Kontrolle
der daraus sich ergebenden Verarbeitungsprozesse.

!! Gibt an, daﬂ der letzte Shell-Befehl erneut ausgef¸hrt werden soll.

SIEHE AUCH
create, Umleitung
++

++ alias
NAME
alias - Hinzuf¸gen, auflisten oder Entfernen von Alias-Bezeichnungen.

SYNOPSIS
alias Name Tokens ...
alias [Name]
alias -r Name

BESCHREIBUNG
Die erste Form macht aus 'Name' einen Alias f¸r die Marken. Alle
Zeichen bis zum Zeilenvorschub oder Kommentar werden als zur
Definition gehˆrig angenommen. Bestehende Alias-Bezeichnungen
oder Debugger-Befehle kˆnnen als eine neue Alias-Bezeichnung
umdefiniert werden. Wenn eine Alias-Bezeichnung definiert ist,
ist die Verwendung dieser Bezeichnung gleichwertig mit der
Eingabe der Sequenz der Marken, die sie ersetzt.
Alias-Bezeichnungen kˆnnen in Form von anderen
Alias-Bezeichnungen definiert werden, allerdings nicht rekursiv.

Alias-Definitionen kˆnnen spezifische Identifikatoren $1, $2, ...
enthalten. Jeder dieser Identifikatoren $n wird in einer
Alias-Definition durch das n'te Element der Aufrufzeile ersetzt,
wobei die Argumente beginnend mit 1 numeriert sind. Vor jedem
Argument muﬂ ein Leerzeichen stehen und dahinter ein Leerzeichen,
ein 'CR/LF' das Kommentar-Zeichen (#) oder der Anfang eines
Blocks ({) stehen. Die spezifischen Identifikatoren $1, $2, ...
werden innerhalb einer Zeichenkette in Anf¸hrungszeichen nicht
ersetzt.

Wenn eine Alias-Definition den spezifischen Identifikator $#
enth‰lt, wird dieser beim Aufruf der Alias-Definition mit der
Anzahl der Argumente ersetzt, die derzeit w‰hrend des aktuellen
Alias-Aufrufes verwendet werden. Wenn eine Alias-Definition den
spezifischen Identifikator $* enth‰lt, wird dieser beim Aufruf
der Alias-Definition mit einer Liste aller Argumente ersetzt, die
w‰hrend dem aktuellen Alias-Aufrufes ¸bergeben wurden, wobei die
einzelnen Argumente durch jeweils ein Leerzeichen getrennt sind.

Ohne Argumente, listet der Befehl 'alias' alle aktuellen
Alias-Bezeichnungen auf. Mit einem einzelnen Namen, zeigt dieser
Befehl die entsprechende Alias-Bezeichnung f¸r diesen Namen.

Mit der Option -r entfernt 'alias' alle bestehenden
Alias-Bezeichnungen f¸r den angegebenen Namen.

BEISPIELE
alias
alias i
alias i step -i
alias edit list $1@1
alias print_list while($1) { print *$1; set $1 = $1->next }
alias b if ($# > 0) { stop $* } else { stop %list_file@%list_line }
alias -r i
++

++ stop
NAME
stop - Definiert oder zeigt Stop-Ereignisse an.

SYNOPSIS
stop [-p Prozeﬂliste] [[-q] [-c Anzahl] Stopp_Ausdr [Befehl]]
Stop [-p Prozeﬂliste]

BESCHREIBUNG
Ein Stop-Ereignis gibt eine Bedingung im Adreﬂbereich eines
Programms an, die den Debugger veranlaﬂt, die Ausf¸hrung des
Programms zu unterbrechen. Ein 'Stopausdruck'
besteht aus einem oder mehreren Ausdr¸cken, die mit den
Operatoren && (und) oder || (oder) verbunden sind. Jeder Ausdruck
kann:

1) entweder eine Stelle sein
        Eine bestimmte Stelle im Programmtext - diese Ereignisse sind
        wie herkˆmmliche Breakpoints;

2) oder (Ausdruck)
        Ein Ausdruck in der gel‰ufigen Sprache - diese Art von
        Stop-Ausdr¸cken wird wahr, wenn der Ausdruck wahr wird;

3) *lvalue (Wert)
   Eine Stelle in den Programmdaten, die ge‰ndert werden kann -
   diese Art von Ausdr¸cken wird wahr, wenn sich der Wert ‰ndert.

Stopausdrucke werden kontinuierlich vom Debugger
bewertet, wenn der Hauptprozeﬂ oder der Ablaufstrang l‰uft. Wenn
der gesamte Ausdruck wahr wird, zeigt der Debugger das Eintreten
des Ereignisses an und f¸hrt den entsprechenden, optionalen
'Befehl' aus.

Siehe Stopausdruck f¸r n‰here Angaben.

Die Option -q gibt an, daﬂ der Debugger das Ereignis nicht angibt.

Die Option -c gibt an, daﬂ das Ereignis die ersten 'Z‰hlung' Male
nicht auslˆst, wenn der Stopausdruck wahr wird.                                                    

Die zweite Form des Stop-Befehls zeigt alle Ereignisse f¸r die
angegebene Liste von Ablaufstr‰ngen und Prozessen an.

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Stop-Befehls f¸r alle Ablaufstr‰nge oder alle vom aktuellen
Programm (%program) abgeleiteten Einschritt-Prozesse, wenn die
Option -p nicht angegeben ist.

BEISPIELE
stop myfile.c@230
stop *bar
stop (x == 5)
stop foo && (a > 7)
stop (a == 4) || (b == 7)                                                    

SIEHE AUCH
%program, %verbose, assoccmd, delete, disable, enable, events,
Ausdruck, Standort, Prozeﬂliste, Bereich, Stopausdruck
++


++ break
NAME
break - Verlassen der 'While'-Schleife.

SYNOPSIS
break                                                    

BESCHREIBUNG
Der Befehl 'break' veranlaﬂt den Debugger, die innerste
'While'-Schleife zu verlassen.

BEISPIELE
while($i < 10) { if (x[$i] == $myvar) break; set $i = $i + 1 }

SIEHE AUCH
continue, while
++


++ continue
NAME
continue - f‰hrt bei der n‰chsten Wiederholung mit der
'While'-Schleife fort.

SYNOPSIS
continue

BESCHREIBUNG
Der Befehl 'continue' veranlaﬂt den Debugger, mit der Ausf¸hrung
der n‰chsten Wiederholung der innersten 'While'-Schleife zu
beginnen. Die Ausf¸hrung beginnt mit der erneuten Bewertung des
Schleifenausdrucks.

BEISPIELE
while (i < 20) { step; if (i % 2) continue; p i, x[i] }

SIEHE AUCH
break, while
++


++ cancel
NAME
cancel - hebt anstehende Signale auf.

SYNOPSIS
cancel [-p Prozeﬂliste] [Signal ...]

BESCHREIBUNG
Der Befehl 'cancel' entfernt ein Signal oder eine Liste von
Signalen aus den anstehenden Signalen f¸r die angegebene Liste
von Ablaufstr‰ngen und Prozessen und Ablauffolgen (Standard
%thread or %proc). Diese Signale werden nicht von den angegebenen
Ablaufstr‰ngen oder Prozessen empfangen, wenn deren Ausf¸hrung
weitergef¸hrt wird. Wenn keine Signale angegeben sind, werden
alle anstehenden Signale f¸r die angegebenen Ablaufstr‰nge oder
Prozesse aufgehoben.

BEISPIELE
cancel
cancel segv
cancel -p all sigfpe sigemt

SIEHE AUCH
kill, Prozeﬂliste, signal, signames
++


++ create
NAME
create - Erstellt und steuert einen oder mehrere neue Prozesse.

SYNOPSIS
create [-dr] [-f all|none|procs] [-l Start_Ort] [Befehlszeile]

BESCHREIBUNG
Der Befehl 'create' hat eine Shell-‰hnliche Befehlszeile und
erstellt einen oder mehrere Prozesse. Die Befehlezeile kann
Umleitungen f¸r Ein- und/oder Ausgaben sowie ein Shell-Pipe
enthalten. Alle sich daraus ergebenden Prozesse werden an der mit
'Anfangstandort' angegebenen Stelle angehalten. Wenn keine
Startposition angegeben ist, oder die angegebene Startposition
nicht im Adreﬂbereich eines Programms gefunden werden kann, wird
der Prozeﬂ an der Funktion 'main' angehalten. Wenn keine
Funktion 'main' existiert, wird der Prozeﬂ an der im Kopf der
Objektdatei angegebenen Adresse angehalten. Um einen Prozeﬂ zu
erstellen und auszuf¸hren, m¸ssen Sie zuerst 'create' und dann
'run' eingeben. 

Wenn keine 'Befehlszeile' angegeben ist, wird
vorhergehende 'Befehlszeile' verwendet. Alle Prozesse,
die durch Aufrufe mit dieser 'Befehlszeile' erstellt
wurden, werden gelˆscht.

Jedem erstellten Prozeﬂ wird ein Identifikator f¸r den
Debugger-Prozeﬂ zugeteilt. Der Bezug auf diesen Prozeﬂ in
Befehlen mit der Option -p kann mit diesem Identifikator oder mit
dessen ID des Systemprozesses erfolgen. Der erste in einer
Pipeline erstellte Prozeﬂ wird zum aktuellen Prozess (%proc).
Wenn dieser Prozeﬂ die Schnittstellen der Ablaufstr‰nge benutzt,
wird der (Einschritt-) Ablaufstrang im neuen Prozeﬂ zum
aktuellen Ablaufstrang (%thread). Alle anhand eines einzelnen
ausf¸hrbaren Programms erstellten (via fork(2)) Prozesse kˆnnen
auch mit dem Namen dieses ausf¸hrbaren Programms (Programmname)
identifiziert werden.

Wenn die Option -r angegeben ist, werden Ein- und Ausgaben des
Prozesses an ein Pseudo-Terminal umgeleitet. Wenn dieser Prozeﬂ
Eingaben erfordert, muﬂ der Befehl 'input' verwendet werden. Die
Option -d gibt an, daﬂ keine Umleitung erfolgt. Wenn keine
Option angegeben ist, wird die mit %redir angegebene Betriebsart
verwendet (Standard, keine Umleitung).

Wenn die Option -f mit dem Argument 'none' angegeben ist, wird
der Debugger nicht die untergeordneten Prozesse jeglicher Prozesse mit
Verzweigung verfolgen. Wenn die Option -d mit den Argumenten
'all' oder 'procs' angegeben ist, werden alle untergeordneten Prozesse vom
Debugger gesteuert (diese Prozesse kˆnnen von der
Debugger-Steuerung mit 'release' befreit werden). Wenn -f nicht
angegeben ist, wird der Debugger entsprechend %follow gesteuert
(Standard, Verfolgung aller  untergeordneten Prozesse).

Alle von einem Hauptprozeﬂ erstellten Ablaufstr‰nge werden vom
Debugger verfolgt (kˆnnen aber mit 'release' aus der Verfolgung
freigegeben werden). Siehe Beschreibung von %thread_change f¸r
weitere Informationen ¸ber die Steuerung des Debuggers in Bezug
auf neu erstellte Ablaufstr‰nge.

BEISPIEL
create
create -f none myprog 1 2 3
create myprog 1 2 3 | myfilter1 | myfilter2

SIEHE AUCH
!, %follow, %program, %redir, grab, input, Prozeﬂliste, Prozeﬂ,
Programm, rename, release, %thread, %thread_change
++


++ delete
NAME
delete - Lˆscht Ereignisse

SYNOPSIS
delete Ereignisnummer ...
delete -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
Die erste Form lˆscht Ereignisse, die den angegebenen
Ereignisnummern entsprechen.

Die zweite Form lˆscht alle Ereignisse des angegebenen
Ereignistyps (Ereignistyp) (alle Typen, wenn kein Typ angegeben
ist) in der angegebenen Liste von Ablaufstr‰ngen und Prozessen
(im aktuellen Ablaufstrang oder Prozeﬂ, wenn keiner angegeben
ist). Es gibt folgende Ereignistypen ('Ereignistyp'): 'onstop',
'signal', 'stop' oder 'syscall'.


BEISPIELE
delete 1 3 5
delete -a -p p1
delete -a stop
delete -a syscall

SIEHE AUCH
change, disable, enable, events, onstop, Prozeﬂliste,
signal, stop, syscall
++


++ dis
NAME
dis - Disassembliert Maschinenbefehle.

SYNOPSIS
dis [-p Prozeﬂliste] [-c Anweisungszahl] [Standort]

BESCHREIBUNG
Disassembliert 'Anweisungszahl' Befehle in jedem angegebenen
Ablaufstrang oder Prozeﬂ (Standard %thread oder %proc). Wenn das
Argument 'Anweisungszahl' nicht angegeben ist, wird als Standard
%num_lines verwendet. '%num_lines' beginnt bei 10 und kann
ge‰ndert werden.

Wenn das Argument 'Standort' (Stelle) angegeben ist, beginnt das
Disassemblieren an der angegebenen Stelle in jedem angegebenen
Ablaufstrang oder Prozeﬂ. Wenn keine Stelle angegeben ist,
beginnt das Disassemblieren nach der Auslˆsung eines Ereignisses
oder nach dem Reset von %frame an der mit %loc angegebenen
Adresse. Die nachfolgenden Befehle 'dis' fahren bei der Adresse
fort, die genau unter dem zuletzt mit dem vorhergehenden 'dis'
angezeigten Befehl steht.

BEISPIELE
dis
dis -c 20 main
dis file.c@10

SIEHE AUCH
%frame, %loc, %num_lines, dump, Standort, print, Prozeﬂliste
++


++ disable
NAME
disable - Deaktiviert Ereignisse.                                                    

SYNOPSIS
disable Ereignisnummer ...
disable -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
Die erste Form deaktiviert die Ereignisse, die den angegebenen
Ereignisnummern entsprechen.

Die zweite Form deaktiviert alle Ereignisse des angegebenen
Ereignistyps (Ereignistyp) (alle Typen, wenn kein Typ angegeben
ist) in der angegebenen Liste von Ablaufstr‰ngen und Prozessen
(im aktuellen Ablaufstrang oder Prozeﬂ, wenn keiner angegeben
ist). Es gibt folgende Ereignistypen ('Ereignistyp'): 'onstop',
'signal', 'stop' oder 'syscall'.

Deaktivierte Ereignisse haben keine Auswirkung f¸r die
betreffenden Ablaufstr‰nge oder Prozesse, werden aber nicht
gelˆscht. Sie kˆnnen mit 'enable' wieder aktiviert werden.

BEISPIELE
disable 3 5
disable -a -p p1.1,p2.3
disable -a onstop
disable -a signal

SIEHE AUCH
change, delete, enable, events, onstop, Prozeﬂliste, signal,
stop, syscall
++

++ dump
NAME
dump - Zeigt den Inhalt des Speichers an.

SYNOPSIS
dump [-p Prozeﬂliste] [-c Bytezahl] Standort

BESCHREIBUNG
Der Befehl 'dump' zeigt den Inhalt des Speichers f¸r jeden
angegebenen Ablaufstrang oder Prozeﬂ an (Standard, %thread oder
%proc). Er zeigt 'Bytezahl' Byte an, 16 Byte pro Zeile, in
hexadezimal und in ASCII, beginnend mit der unter 'Standort'
angegebenen Adresse.

Wenn das Argument 'Bytezahl'  nicht angegeben ist, werden
'%num_bytes' angezeigt. '%num_bytes' beginnt bei 256 und kann
ge‰ndert werden.

BEISPIELE
dump -c 16 myptr
dump %esp
dump 0x80001248

SIEHE AUCH
%num_bytes, dis, Standort, print, Prozeﬂliste
++


++ enable
NAME
enable - Aktiviert Ereignisse.

SYNOPSIS
enable Ereignisnummer ...
enable -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
 Die erste Form aktiviert Ereignisse, die den angegebenen
 Ereignisnummern entsprechen.

Die zweite Form aktiviert alle Ereignisse des angegebenen
Ereignistyps (alle Typen, wenn kein Typ angegeben ist) in der
angegebenen Liste von Ablaufstr‰ngen und Prozessen (im aktuellen
Ablaufstrang oder Prozeﬂ, wenn keiner angegeben ist). Es gibt
folgende Ereignistypen ('Ereignistyp'): 'onstop', 'signal', 'stop'
oder 'syscall'.

Nur deaktivierte Ereignisse kˆnnen aktiviert werden. Wenn ein
Ereignis aktiviert ist, wirkt es erneut in dem Ablaufstrang oder
Prozeﬂ, in dem es definiert ist.

BEISPIELE
enable 3 5
enable -a -p p1,p2.3
enable -a stop
enable -a signal

SIEHE AUCH
change, delete, disable, events, onstop, Prozeﬂliste, signal,
stop, syscall
++


++ events
NAME
events - Listet Ereignise auf.

SYNOPSIS
events [-p Prozeﬂliste] [Ereignisnummer ...]                                                    

BESCHREIBUNG
Ohne Argumente listet der Befehl 'events' alle Stop-Ereignisse,
signalbezogene Aktionen, Aktionen bei Systemaufrufen und Aktionen
des Befehls 'onstop' f¸r den aktuellen Ablaufstrang oder Prozeﬂ.
Wenn die Option -p angegeben ist, werden die Ereignisse in
Verbindung mit den angegebenen Ablaufstr‰ngen und Prozessen
angezeigt.

Wenn eine oder mehrere Ereignisnummern angegeben sind, zeigt
'events' die komplette Liste der angegebenen Ereignisse an. Die
komplette Liste enth‰lt alle Ablaufstr‰nge und Prozesse, f¸r die
das Ereignis definiert ist, und den kompletten, dazugehˆrigen
Befehlsblock, falls vorhanden.

BEISPIELE
events
events -p p1,p2.3
events 3

SIEHE AUCH
change, delete, disable, enable, onstop, Prozeﬂliste, signal,
stop, syscall
++


++ grab
NAME
grab - ‹bernimmt die Steuerung des Lebensprozeﬂ oder des Kernbildes.

SYNOPSIS
grab  [-f all|none|procs] [-l Ladedatei] Prozeﬂ_Spezifikationfunktion ...
grab -c Kerndatei Objektdatei

BESCHREIBUNG
Die erste Form hat einen oder mehrere 'Prozeﬂ_Spezifikationfunktionen'
(Prozessidentifikatoren); 'debug' versucht, die Steuerung jedes
der angegebenen Prozesse zu ¸bernehmen (die Steuerung wird nur
¸bergeben, wenn Sie die entsprechende Berechtigung dazu haben).
Jeder Prozeﬂ kann entweder als '/proc Pfadname' oder als
Prozeﬂ_ID angegeben werden.

Die Option -l gibt an, daﬂ eine alternative Objektdatei zum Laden
der Symbole f¸r den Prozess verwendet werden soll; es kann nur
ein Prozess angegeben werden.                                                    

Wenn die Option -f mit dem Argument 'none' angegeben ist, wird
der Debugger nicht die untergeordneten Prozesse jeglicher Prozesse mit
Verzweigung verfolgen. Wenn die Option -d mit den Argumenten
'all' oder 'procs' angegeben ist, werden alle untergeordneten Prozesse vom
Debugger gesteuert (diese Prozesse kˆnnen von der
Debugger-Steuerung mit 'release' befreit werden). Wenn -f nicht
angegeben ist, wird der Debugger entsprechend %follow gesteuert
(Standard, Verfolgung aller  untergeordneten Prozesse).

Alle von einem Hauptprozeﬂ erstellten Ablaufstr‰nge werden vom
Debugger verfolgt (kˆnnen aber mit 'release' aus der Verfolgung
freigegeben werden). Siehe Beschreibung von %thread_change f¸r
weitere Informationen ¸ber die Steuerung des Debuggers in Bezug
auf neu erstellte Ablaufstr‰nge.

Die zweite Form ˆffnet eine Kerndatei sowie die entsprechende
Objektdatei zur Pr¸fung. ‹bernommene Kernbilder kˆnnen mit allen
f¸r die Pr¸fung von Lebensprozessen zur Verf¸gung stehenden
Befehlen gepr¸ft, aber nicht f¸r die Ausf¸hrung ge‰ndert werden.

‹bernommene Prozesse, wie erstellte, werden mit einem
Prozeﬂidentifikator f¸r Debugger versehen und kˆnnen entweder
mit diesem Identifikator oder mit deren Prozeﬂ-ID oder mit dem
Namen des Programms, von dem sie abgeleitet sind, aufgerufen
werden. Der erste ¸bernommene Prozeﬂ wird zum aktuellen Prozeﬂ
(%proc). Wenn dieser Prozeﬂ die Schnittstellen der Ablaufstr‰nge
verwendet, wird der Debugger einen Ablaufstrang aus diesem
Prozeﬂ w‰hlen und ihn zum aktuellen Ablaufstrang (%thread)
machen.

BEISPIELE
grab 123
grab -f procs /proc/123 3455
grab -l myobject /proc/3455
grab -c core.save myobject

SIEHE AUCH
%follow, %proc, %program, create, Prozeﬂliste, Prozeﬂ, release,
rename, %thread, %thread_change
++


++ help
NAME
help - Ruft Hilfe auf.

SYNOPSIS
help [Thema]

BESCHREIBUNG
Das Argument 'Thema' kann ein beliebiges Alias, ein Befehlsname
oder ein Hilfethema sein. Wenn 'Thema' nicht angegeben ist, wird
die Liste der verf¸gbaren Befehle und Hilfethemen angezeigt.                                                    

BEISPIELE
help
help stop
help b
help Standort
++


++ if
NAME
if - Bedingte Verzweigung.

SYNOPSIS
if (Ausdruck) Befehl
if (Ausdruck) Befehl else Befehl

BESCHREIBUNG
Der Ausdruck 'Ausdruck' wird in der aktuellen Sprache ((%db_lang oder
%lang) im Kontext des aktuellen Ablaufstranges oder
Einschritt-Prozesses bewertet. Wenn der Ausdruck wahr ist, wird
der Teil 'then' ausgef¸hrt. Andernfalls wird der Teil 'else'
ausgef¸hrt, wenn er vorhanden ist. Das Argument 'Befehl' kann
entweder ein einfacher Befehl oder ein Block sein.

BEISPIELE
stop  file.c@myfunc { if (x < 10) run; else print x }

SIEHE AUCH
%db_lang, %lang, Block, Ausdruck, Bereich, while
++


++ input
NAME
input - Sendet die Eingabe an einen Prozess.                                                    

SYNOPSIS
input [-p Prozeﬂname|-r Pseudo-tty] [-n] Zeichenkette

BESCHREIBUNG
Wenn ein Prozeﬂ mit 'create -r' erstellt wurde, werden dessen
Ein- und Ausgaben gemeinsam mit den E/A jeglicher anderer
Prozesse, die vom gleichen Programm abgeleitet wurden, an ein
Pseudo-Terminal umgeleitet. Um Eingaben an einen solchen Prozeﬂ
zu senden, muﬂ der Befehl 'input' verwendet werden.

'Pseudo-tty' ist der Name des Pseudo-Terminals, an den die
Eingaben umgeleitet werden sollen. Der Debugger bezeichnet alle
umgeleiteten Prozeﬂ-Ausgaben mit dem Namen des Pseudo-Terminals.
Alternativ kann ein Prozeﬂ- oder Programmname angegeben werden.
Wenn kein Prozeﬂ oder 'Pseudo-tty' angegeben ist, wird der dem
aktuellen Programm zugeteilte Pseudo-Terminal angenommen.

Die Eingabe 'Zeichenkette' (Zeichenkette) wird an den angegebenen
Pseudo-Terminal oder den, dem angegebenen Prozeﬂ oder Programm
zugeteilten Pseudo-Terminal gesendet. An die Zeichenkette wird
ein 'CR/LF' angef¸gt, auﬂer wenn die Option -n angegeben ist.

BEISPIELE
input -r pts1 "Hier steht eine Zeichenkette"
input -p myprog "Hier steht eine weitere Zeichenkette"

SIEHE AUCH
%redir, create
++


++ jump
NAME
jump - Ver‰ndert den Programmz‰hler des Ablaufstrangs oder des
Programms.

SYNOPSIS
jump [-p Prozeﬂliste] Standort

BESCHREIBUNG
Ein Ablaufstrang oder ein Prozeﬂ muﬂ erst angehalten werden,
bevor dieser Befehl erfolgreich daf¸r verwendet werden kann. Der
Befehl 'jump' stellt den Programmz‰hler f¸r die Liste der
Ablaufstr‰nge und Prozesse (%thread oder %proc) auf die unter
'Standort' angegebene Adresse. Wenn der Ablaufstrang oder der
Prozeﬂ die Ausf¸hrung beendet, wird er bei dieser Adresse
beginnen.

Die Stelle ('Standort' kann jegliche beliebige Adresse innerhalb
des Textes des angegebenen Ablaufstranges oder Prozesses sein;
dabei ist jedoch sehr vorsichtig vorzugehen. Der Befehl 'jump'
versucht nicht, den Stapel des Ablaufstranges oder Prozesses
anzupassen, wenn die Adresse auﬂerhalb der aktuellen Funktion
liegt. Man muﬂ auch vorsichtig sein, wenn man in einem Code
springt, der Nebenwirkungen haben kann.

SYNOPSIS
jump 10
jump -p p2.1 main+8

SIEHE AUCH
Standort, Prozeﬂliste
++


++ kill
NAME
kill - Sendet ein Signal an einen Ablaufstrang oder Prozeﬂ.

SYNOPSIS
kill [-p Prozeﬂliste] [Signal]

BESCHREIBUNG
Das angegebene Signal ('signal') wird an den aktuellen
Ablaufstrang oder Einschritt-Prozeﬂ oder an die Liste von
Ablaufstr‰ngen und Prozessen, wenn die Option -p angegeben ist,
gesendet. Im Gegensatz zu den meisten anderen Debugger-Befehlen
wird das Signal, wenn ein Prozeﬂ-ID in 'Prozeﬂliste' angegeben ist,
an den Prozeﬂ als ein Ganzes gesendet und nicht an jeden
Ablaufstrang in diesem Prozeﬂ.

Signale kˆnnen mit Nummer oder mit Namen angegeben werden. Ein
Signalname kann mit oder ohne den Initialen 'SIG' als Pr‰fix
angegeben werden. Groﬂ- oder Kleinschreibung ist unbedeutend.
Wenn kein Signal angegeben ist, wird 'SIGKILL' verwendet.

BEISPIELE
kill -p p1.2,p2.3
kill sigfpe
kill -p p3 8

SIEHE AUCH
cancel, Prozeﬂliste, signal, signames
++


++ list
NAME
list - Zeigt die Ursprungszeilen an.

SYNOPSIS
list [-p Prozeﬂliste] [-c Z‰hlung] [Ablaufstrang-ID@][Dateiname@]Funktionname
list [-p Prozeﬂliste] [-c Z‰hlung] [Ablaufstrang-ID@][Dateiname@]Zeilennummer
list [-p Prozeﬂliste] [-c Z‰hlung] /norm_Ausdruck/
list [-p Prozeﬂliste] [-c Z‰hlung] ?norm_Ausdruck?
list [-p Prozeﬂliste] [-c Z‰hlung]

BESCHREIBUNG
Der Befehl 'list' zeigt die Ursprungszeilen f¸r die angegebenen
Ablaufstr‰nge und Prozesse an oder f¸r den aktuellen Ablaufstrang
oder Prozeﬂ, wenn 'Prozeﬂliste' nicht angegeben ist.                                                    

Die ersten vier Formen geben Startpunkt f¸r die Anzeige an. Die
ersten beiden Formen ermˆglichen die Angabe eines Ablaufstranges
oder Prozesses, einer Datei, einer Funktion und einer
Zeilennummer. 'Ablaufstrang-ID' kann sich auf einen Ablaufstrang oder
Einschritt-Prozeﬂ beziehen. Wenn ein Ablaufstrang oder Prozeﬂ
angegeben ist, wird jegliche, mit der Option -p angegebene
Prozeﬂliste ¸berschrieben.

Die dritte Form findet die n‰chste Zeile, die dem regul‰ren
Ausdruck 'ed(1)-style' entspricht. Die vierte Form sucht
r¸ckw‰rts ausgehend von der aktuellen Zeile. Der abschlieﬂende
Schr‰gstrich oder das abschlieﬂende Fragezeichen kˆnnen
weggelassen werden, au0er wenn andere Befehle in dieser Zeile
folgen. Die letzte Form f‰hrt mit der Anzeige dere Dateie fort,
und zwar ab der zuletzt angezeigten Zeile, oder ab %file@%line
nach Auslˆsung eines Ereignisses oder nach Reset von %frame.

Wenn das Argument 'Z‰hlung' angegeben ist, werden dementsprechend
viele Zeilen angezeigt, andernfalls werden %num_linies angezeigt.
%num_lines beginnt bei 10 und kann ge‰ndert werden.                                                    

Nachdem ein Zeilenblock angezeigt ist, wird %list_file auf den
Namen der angezeigten Datei und %list_line auf die Nummer der
zuletzt angezeigten Ursprungszeile gesetzt.                                                    

BEISPIELE
list -c 20
list myfile@1
list myfunc
list /x/
list ?foobar
list /

SIEHE AUCH
%file, %frame, %line, %list_file, %list_line, Standort,
print, Prozeﬂliste, norm_Ausdruck
++

++ map
NAME
map - Zeigt die virtuelle Adressenverteilung an.

SYNOPSIS
map [-p Prozeﬂliste]

BESCHREIBUNG
Zeigt die virtuelle Adreﬂverteilung f¸r einen oder mehrere
Ablaufstr‰nge oder Prozesse an. Ohne Argumente wird die
Verteilung f¸r den aktuellen Prozeﬂ (%proc) angezeigt. Da alle
Ablaufstr‰nge innerhalb eines Prozesses den gleichen
Adreﬂbereich teilen, wird die virtuelle Adreﬂverteilung die
gleiche f¸r alle Ablaufstr‰nge innerhalb eines Prozesses sein.

SIEHE AUCH
create, grab, Prozeﬂliste
++


++ symbols
NAME
symbols - Zeigt Symbolnamen, Werte und Typen an.                                                    

SYNOPSIS
symbols [-p Prozeﬂliste] [-o Objekt] [-n Dateiname] [-dfgltuv] [Muster]

BESCHREIBUNG
Zeigt die Liste der Variablennamen an, die im aktuellen Rahmen
(%frame) in den angegebenen Ablaufstr‰ngen oder Prozessen
(Standard: %thread oder %proc) sichtbar sind. Ohne Optionen (oder
mit der Option -l) werden die lokalen Namen angezeigt, die in der
aktuellen Funktion (%func) definiert sind. Mit der Option -f
werden nur die sichtbaren Namen angezeigt, die lokal f¸r die
aktuelle Datei (%file) gelten. Wenn ein Dateiname ('Dateiname')
mit der Option -n angegeben ist, werden anstelle die Dateisymbole
angezeigt. Mit der Option -g werden nur die sichtbaren, globalen
Namen angezeigt, die im aktuellen Objekt (ausf¸hrbare Datei oder
geteilte Bibliothek) definiert ist. Wenn die Option -g zusammen
mit der Option -o verwendet wird, werden die globalen Namen in
der angegebenen Objektdatei angezeigt. Mit der Option -d werden
die integrierten Debugger-Variablen angezeigt. Mit der Option -u
werden die f¸r den Debugger erhaltenen Benutzervariablen
angezeigt.

Wenn ein Modell 'sh(1)-style' angegeben ist, wird die Anzeige
weiter eingeschr‰nkt und nur die Namen angezeigt, die diesem
Modell entsprechen.

Mit der Option -t werden zus‰tzlich zu den Namen die Symboltypen
angezeigt. Mit der Option -v werden die Symbolwerte angezeigt.
Wenn die aktuelle Programmiersprache C++ ist, zeigt der Befehl
'symbols -v' nicht die statischen Typen an. Diese kˆnnen durch
Ausdrucken des Symbols mit dem Befehl 'print' angezeigt werden.

BEISPIELE
symbols -ftv
symbols -g -o libc.so.1 exec*

SIEHE AUCH
%file, %frame, %func, Muster, print, Prozeﬂliste
++


++ print
NAME
print - Druckt den Wert eines Ausdrucks aus.                                                    

SYNOPSIS
print [-p Prozeﬂliste] [-f Format] [-v] Ausdruck, ...

BESCHREIBUNG
Zeigt die Ergebnisse der Bewertung einer Liste von durch Komma
getrennten Ausdr¸cken an. Die Ausdr¸cke werden im Kontext
mit den angegebenen Ablaufstr‰ngen und Prozessen bewertet
(Standard: %thread oder %proc). Mit der Option -f muﬂ ein Format
angegeben werden. Die Ausdr¸cke kˆnnen Programmvariablen,
integrierte Debugger-Variablen (z.B. %line) und
benutzerdefinierte Variablen ($myvar, $HOME) enthalten. Wenn ein
Funktionsaufruf bewertet wird, erstellt der Debugger einen
Stapelrahmen f¸r diese Funktion und f¸hrt sie aus.
Debugger-Ereignisse werden w‰hrend der Ausf¸hrung der Funktion
deaktiviert. Ausdr¸cke werden in der aktuellen Programmiersprache
(%lang oder %db_lang) bewertet. Hinter jedem Ausdruck wird ein
Leerzeichen gedruckt und die Zeile wird mit einem CR/LF
abgeschlossen, auﬂer wenn ein Format angegeben ist.

Mit der Option -v werden detailliertere Informationen angezeigt.
Diese zus‰tzlichen Informationen enthalten Beispiele f¸r alle vom
Debugger w‰hrend der Bewertung des Ausdrucks aufgerufenen
Funktionen. Dies ist bei C++ n¸tzlich, um zu sehen, wie
¸berlastete Funktion gelˆst werden. Mit der Option -v werden auch
Elemente der Compiler-Struktur und -Gliederung angezeigt wie
Zeiger auf virtuelle Funktionstabellen.

Der Befehl 'set' kann auch zur Bewertung von Sprachausdr¸cken
verwendet werden. Aber bei 'set' wird das Ergebnis eines
Ausdruckes nicht ausgedruckt. Dieser Befehl wird haupts‰chlich
zur Bewertung eines Ausdrucks f¸r Nebenwirkungen wie Zuweisungen
verwendet.

BEISPIELE
print %line, %file, %func
print "a[i] == ", a[i]
print *ptr->next
print -f "0x%x\n" main
print -v myfunc(1, 2, 3)

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Format, Prozeﬂliste, Bereich, set
++

++ ps
NAME
ps - Prozess-Status.                                                    

SYNOPSIS
ps [-p Prozeﬂliste]

BESCHREIBUNG
Zeigt den Status der gesteuerten Ablaufstr‰nge und Prozesse an.
Wenn die Option -p nicht angegeben ist, wird der Status aller
gesteuerten Ablaufstr‰nge und Prozesse angezeigt. Der aktuelle
Ablaufstrang (%thread), wenn vorhanden, oder der aktuelle Prozeﬂ
(%proc) wird mit dem Sternzeichen (*) gekennzeichnet.

SIEHE AUCH
Prozeﬂliste
++

++ pwd
NAME
pwd - Druckt das aktuelle Arbeitsverzeichnis aus.                                                    

SYNOPSIS
pwd                                                    

BESCHREIBUNG
Der Befehl 'pwd' druckt das aktuelle Arbeitsverzeichnis des
Debuggers aus.

SIEHE AUCH
cd
++

++ quit
NAME
quit - Verl‰ﬂt den Debugger.

SYNOPSIS
quit

BESCHREIBUNG
Verl‰ﬂt den Debugger. Alle gesteuerten Prozesse werden gelˆscht
(wenn sie erstellt waren) oder freigegeben und ausgef¸hrt (wenn
sie ¸bernommen wurden).

SIEHE AUCH
release
++

++ release
NAME
release - Gibt einen oder mehrere gesteuerte Ablaufstr‰nge oder
Prozesse frei.

SYNOPSIS
release [-s] [-p Prozeﬂliste]

BESCHREIBUNG
Die angegebenen Ablaufstr‰nge oder Prozesse (Standard: %thread
oder %proc) werden nicht mehr vom Debugger gesteuert oder
kontrolliert. Ohne Option wird jeder Ablaufstrang oder Prozeﬂ
freigegeben und kann ausgef¸hrt werden. Mit der Option -s wird
jeder im angehaltenen Zustand befindliche Prozeﬂ freigegeben.
Die Option -s wird f¸r Ablaufstr‰nge ignoriert. Ein Ablaufstrang
oder Prozeﬂ kann freigegeben werden, selbst wenn er nicht vom
Debugger ¸bernommen wurde; das heiﬂt, erstellte Prozesse kˆnnen
ebenfalls freigegeben werden.

BEISPIELE
release -p p1
release -s

SIEHE AUCH
Prozeﬂliste, quit
++

++ run
NAME
run - Befiehlt die Ausf¸hrung eines Ablaufstrangs oder Prozesses.                                                    

SYNOPSIS
run [-p Prozeﬂliste] [-bfr] [-u Standort]

BESCHREIBUNG
Befiehlt die Ausf¸hrung der angegebenen Liste von Ablaufstr‰ngen
und Prozessen (Standard: %thread oder %proc). Mit der Option -f
wird der Ablaufstrang oder der Prozeﬂ vom Debugger im
Vordergrund ausgef¸hrt, d.h. der Debugger wartet, bis die
Ablaufstr‰nge oder Prozesse anhalten, bevor er die Steuerung an
den Benutzer ¸bergibt. Mit der Option -b wird die Ausf¸hrung im
Hintergrund bestimmt (kein Warten). Die Steuerung wird sofort an
den Benutzer ¸bergeben und der Ablaufstrang oder Prozeﬂ wird
gestartet. Wenn weder -f noch -b angegeben sind wird der Standard
durch den Wert der Debugger-Variablen %wait bestimmt.

Mit der Option -r wird der Ablaufstrang oder Prozess ausgef¸hrt,
bis die aktuelle Funktion zur¸ckgibt. Mit der Option -u wird eine
Stelle angegeben, an der ausgef¸hrt werden soll.                                                    

Ablaufstr‰nge, die derzeit nicht auf einem Kern ausgef¸hrt
werden, kˆnnen nicht f¸r die Ausf¸hrung befohlen werden (wie z.B.
Ablaufstr‰nge die mit dem Status 'OFF LWP' im Befehl 'ps'
angezeigt werden).

BEISPIELE
run -p all -b
run -r
run -u 108

SIEHE AUCH
%wait, Standort, Prozeﬂliste, ps, step, Ablaufstrang
++

++ script
NAME
script - F¸hrt ein Befehls-Skript des Debuggers aus.

SYNOPSIS
script [-q] fname

BESCHREIBUNG
Liest und f¸hrt Debuggerbefehle aus einer Datei aus. Befehle
werden auf dem Bildschirm angezeigt, bevor sie ausgef¸hrt werden,
auﬂer wenn die Option -q angegeben ist. Skripts kˆnnen
verschachtelt werden. ++

++ set
NAME
set - Eine Debugger- oder Programmvariable ‰ndern.

SYNOPSIS
set [-p Prozeﬂliste] [-v] debug_or_user_var [=] Ausdruck [,Ausdruck...]
set [-p Prozeﬂliste] [-v] Sprachenausdruck

BESCHREIBUNG
Der Befehl 'set' hat zwei Formen. Die erste Form wird f¸r die
Zuweisung eines neuen W f¸r eine integrierte oder erhaltene
Debugger-Variable verwendet (z.B. %lang oder $foo). Die normalen
Werte von 'Ausdruck' h‰ngen von der Variablen ab. Einige, wie %lang,
nehmen eine speziell definierte Reihe von Namen an. Andere kˆnnen
jeglichen Debugger- oder Sprachausdruck ¸bernehmen, der in einen
Zeichenkettenwert umgewandelt werden kann. Im Falle einer (durch
Komma getrennten) Liste von Zeichenketten und Benutzervariablen
werden die Zeichenkettenwerte dieser Ausdr¸cke zusammengezogen.
Siehe 'Hilfe' ¸ber jede Debugger-Variable f¸r die spezifischen,
Normalwerte.

In der zweiten Form kann der Befehl 'set' zur Bewertung
beliebiger Sprachausdr¸cke verwendet werden, obwohl die typische
Verwendung die Bewertung eines Zuweisungsausdrucks ist. Wenn mehr
als ein Ablaufstrang oder Prozeﬂ angegeben ist, wird der Befehl
der Reihe nach im Kontext jedes Ablaufstranges oder
Prozesses bewertet.

Mit der Option -v werden Beispiele aller vom Debugger w‰hrend der
Bewertung des Ausdrucks aufgerufenen Befehl angezeigt. Dies ist
bei C++ n¸tzlich, um zu sehen, wie ¸berlastete Funktion gelˆst
werden.

BEISPIELE
set %global_path = %global_path, ":src/new/mydir"
set -p all %path = "mydir"
set %frame 2
set %eax = 0x3421
set x = 3
set -v myfunc(a, b)

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Prozeﬂliste, Bereich, Benutzervariablen
++


++ signal
NAME
signal - Definiert oder listet Signalaktionen f¸r einen
Ablaufstrang oder Prozeﬂ.

SYNOPSIS
signal [-p Prozeﬂliste] [-iq] [Signal ... [Befehl]]

BESCHREIBUNG
Wenn ein Signal an einen Ablaufstrang oder Prozeﬂ gesendet wird, 
f‰ngt der Debugger das Signal ab und zeigt dessen Auftreten an. 
Dann kann das Signal mit dem Befehl 'cancel' aufgehoben werden oder 
der Prozeﬂ kann weiterlaufen und das Signal empfangen. Wenn die 
Option -i mit einem oder mehreren Signalnamen oder -nummern 
angegeben wird (siehe 'kill'), bedeutet dies, daﬂ der Debugger diese 
Signale ignorieren wird (nicht f¸r die unter 'Prozeﬂliste' angegebene 
Liste von Ablaufstr‰ngen oder Prozessen abfangen wird). Ein 
Signalname kann mit oder ohne den Initialen 'SIG' als Pr‰fix 
angegeben werden. Groﬂ- oder Kleinschreibung ist unbedeutend. 
Wenn das Signal ohne die Option -i angegeben ist, wird die 
Standard-Aktion f¸r dieses Signal wiederhergestellt.

Wenn ein Befehl mit einem Satz von Signalen angegeben wird,
erstellt der Debugger ein Ereignis f¸r diesen Satz. Dieses
Ereignis kann gelˆscht, deaktiviert oder aktiviert werden und
kann ein Ereignis der Befehle 'stop', 'onstop' und 'syscall'
sein. Dem gleichen Signal kˆnnen mehrere Ereignisse zugewiesen
werden. Wenn alle Ereignisse f¸r ein gegebenen Signal gelˆscht
werden, wird die Standard-Aktion des Debuggers f¸r dieses Signal
jedoch nicht entfernt. Mit der Option -q wird das Signalereignis
nicht angek¸ndigt.

Ohne Argumente werden die Signalaktionen f¸r die unter 'Prozeﬂliste'
angegebenen Prozesse angezeigt.

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Stop-Befehls f¸r alle Ablaufstr‰nge oder alle vom aktuellen
Programm (%program) abgeleiteten Einschritt-Prozesse, wenn die
Option -p nicht angegeben ist.

BEISPIELE
signal -i fpe emt
signal SIGFPE
signal 8 { if (x == 0) cancel 8; run }

SIEHE AUCH
assoccmd, cancel, delete, disable, enable, kill, Prozeﬂliste, signames
++

++ step
NAME
step - F¸hrt einen Prozess im Einzelschritt aus.                                                    

SYNOPSIS
step [-p Prozeﬂliste] [-ibfoq] [-c Z‰hlung]

BESCHREIBUNG
Die Liste der Ablaufstr‰nge und Prozesse (Standard %thread oder
%proc) wird 'Z‰hlung' Mal angehalten (Standard 1). Ein 'Z‰hlung' von
0 bedeutet, daﬂ schrittweise wiederholt wird bis von einem
Ereignis unterbrochen oder angehalten wird.                                                    

Mit der Option -i, Befehlsschritt; andernfallsAnweisungsschritt.
Mit der Option -o, ‹bergehen von Funktionsaufrufen (behandelt
eine Subroutine als einen einzigen Befehl); andernfalls
schrittweises Durchgehen von Funktionsaufrufen.

Mit der Option -f wird der Ablaufstrang oder der Prozeﬂ vom
Debugger im Vordergrund ausgef¸hrt, d.h. der Debugger wartet, bis
die Ablaufstr‰nge oder Prozesse anhalten, bevor er die Steuerung
an den Benutzer ¸bergibt. Mit der Option -b wird die Ausf¸hrung
im Hintergrund bestimmt (kein Warten). Die Steuerung wird sofort
an den Benutzer ¸bergeben und der Ablaufstrang oder Prozeﬂ wird
gestartet. Wenn weder -f noch -b angegeben sind wird der Standard
durch den Wert der Debugger-Variablen %wait bestimmt.

Mit der Option -q zeigt der Debugger beim schrittweisen
Durchgehen nicht das Prozeﬂ-ID des Prozesses an und druckt auch
nicht die n‰chste Ursprungszeile.

Ablaufstr‰nge, die derzeit nicht auf einem Kern ausgef¸hrt
werden, kˆnnen nicht f¸r die Ausf¸hrung befohlen werden (wie z.B.
Ablaufstr‰nge die mit dem Status 'OFF LWP' im Befehl 'ps'
angezeigt werden).

BEISPIELE
step -io
step -b
step -p all -c 10

SIEHE AUCH
%verbose, %wait, Prozeﬂ, Prozeﬂliste, ps, run, Ablaufstrang
++


++ halt
NAME
halt - Unterbricht einen Ablaufstrang oder Prozeﬂ, der derzeit
im Hintergrund l‰uft.

SYNOPSIS
halt [-p Prozeﬂliste]

BESCHREIBUNG
Der Debugger leitet jeden genannten Ablaufstrang oder
Einschritt-Prozeﬂ (Standard, %thread or %proc) so, daﬂ er sofort
die Ausf¸hrung unterbricht. Der Antrag kann aufgrund der
Systemtr‰gheit und der Zeitplan‰nderungen eventuell nicht sofort
wirken.

Das Argument 'halt' ist f¸r Ablaufstr‰nge und Prozesse, die im
Vordergrund ausgef¸hrt werden, nicht n¸tzlich, da der Debugger
die Steuerung erst an den Benutzer ¸bergibt, wenn diese
Ablaufstr‰nge oder Prozesse anhalten. Um einen im Vordergrund
ausgef¸hrten Ablaufstrang oder Prozeﬂ anzuhalten, m¸ssen Sie die
Unterbrechungstaste dr¸cken (normalerweise die Taste 'Entf').

SIEHE AUCH
%wait, Prozeﬂliste, run, step
++

++ syscall
NAME
syscall - Definiert die Verfolgung von Systemaufrufen.

SYNOPSIS
syscall [-p Prozeﬂliste] [[-eqx] [-c Z‰hlung] Aufruf ... [Befehl]]                                                    

BESCHREIBUNG
Dieser Befehl definiert Aktionen, die zu unternehmen sind, wenn
ein Ablaufstrang oder ein Prozeﬂ einen Systemaufruf beginnt oder
abschlieﬂt. Ohne Argumente werden die aktuellen Aktionen f¸r
Systemaufrufe f¸r den genannten Ablaufstrang oder Prozeﬂ
angezeigt.

Wenn ein oder mehrere Systemaufrufnamen oder -nummern angegeben
sind, unterbricht der Debugger den Ablaufstrang oder Prozeﬂ am
Eingang (-e, Standard) und/oder am Ausgang (-x) dieser
Systemaufrufe. Das Systemaufrufereignis wird angek¸ndigt und
jeder dazugehˆrige Befehl ausgef¸hrt.

Die Option -q bedeutet ein Unterdr¸cken der Anzeige - Das
Ereignis wird nicht angek¸ndigt. Die Option -c gibt an, daﬂ das
Ereignis 'Z‰hlung' Mal auslˆsen wird, bevor der Debugger den
Ablaufstrang oder Prozeﬂ unterbricht. Der Ablaufstrang oder
Prozeﬂ wird nach jedem darauffolgenden Auftreten unterbrochen.

Verwenden Sie 'help sysnames', um eine Liste der g¸ltigen
Systemaufrufnamen anzuzeigen. Groﬂ- oder Kleinschreibung ist
unbedeutend.                                                    

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Befehls f¸r alle Ablaufstr‰nge oder alle vom aktuellen
Programm (%program) abgeleiteten Einschritt-Prozesse, wenn die
Option -p nicht angegeben ist.

BEISPIELE
syscall -c 10 write { if (fd == 5) run }
syscall -qx read

SIEHE AUCH
%program, assoccmd, delete, disable, enable, events, Prozeﬂliste
++


++ regs
NAME
regs - Zeigt den Inhalt der Prozessorregister an.

SYNOPSIS
regs [-p Prozeﬂliste]

BESCHREIBUNG
Zeigt den Inhalt der Prozessorregister f¸r die angegebenen
Ablaufstr‰nge und Prozesse (Standard, %thread or %proc) in
hexadezimal an.                                                    

SIEHE AUCH
dis, dump, Prozeﬂliste
++


++ stack
NAME
stack - Zeigt die R¸ckverfolgung eines Funktionsaufrufes an.

SYNOPSIS
stack [-p Prozeﬂliste] [-f Rahmen] [-c Z‰hlung] [-a Adresse ] [ -s stack ]

BESCHREIBUNG
Zeigt die aktiven Funktionen f¸r die Liste von Ablaufstr‰ngen und
Prozessen (Standard, %thread or %proc) an. Die Funktionen werden
mit ihren Namen, Argumentnamen und Werten sowie der aktiven
Zeilennummer oder Adresse innerhalb der Funktion angezeigt.
Funktionsnamen, Argumentnamen und Zeilenummern kˆnnen nicht
verf¸gbar sein, wenn nicht ausreichend Symbolinformation
vorliegt.

'Z‰hlung' gibt die Anzahl der anzuzeigenden Rahmen an. Wenn dieses
Argument nicht angegeben ist, wird der gesamte Stapel angezeigt.
Die Option -f gibt die Nummer des Rahmens an, mit dem die Anzeige
beginnen soll. Rahmen sind von 0 ab (Boden des Stapels,
Anfangsrahmen) numeriert.

Die Optionen -a und -s ermˆglichen die Angabe einer Startadresse
(Programmz‰hler) und/oder eines Startwertes f¸r den Stapelzeiger.
Dies ist manchmal n¸tzlich, wenn man eine Stapelverfolgung f¸r
einen Prozeﬂ durchf¸hren will, der an eine unerlaubte Adresse
gesprungen ist, oder dessen Stapelzeiger nicht mehr stimmt. 
Beide Optionen erwarten eine hexadezimale Adresse.

BEISPIELE
stack -p p2
stack -f 2 -c 3
stack -a 0x80494958 -s 0xbfff8004

SIEHE AUCH
Prozeﬂliste
++

++ while
NAME
while - Bedingte Schleife.

SYNOPSIS
while (Ausdruck) Befehl

BESCHREIBUNG
Der Ausdruck 'Ausdruck' wird in der aktuellen Programmiersprache 
(%lang oder %db_lang) im Kontext des aktuellen Ablaufstranges oder 
Einschritt-Prozesses bewertet. Wenn der Ausdruck wahr ist, wird der 
Befehl 'Befehl' ausgef¸hrt. Dann wird die Sequenz wiederholt. 'Befehl' 
kann ein einzelner Befehl oder ein Block sein.

BEISPIELE
while ($foo < 10) { print $foo, a[$foo]; set $foo = $foo + 1 }

SIEHE AUCH
%db_lang, %lang, Block, break, continue, Ausdruck, if, Bereich
++


++ cd
NAME
cd - Wechselt das aktuelle Arbeitsverzeichnis.

SYNOPSIS
cd [Phadname]

BESCHREIBUNG
Der Befehl 'cd' wechselt das aktuelle Arbeitsverzeichnis des
Debuggers auf das unter 'Phadname' angegebene Verzeichnis. Wenn
kein Pfadname angegeben ist, verwendet 'cd' das in der
Umgebungsvariablen HOME angegebene Verzeichnis.

SIEHE AUCH
pwd
++

++ change
NAME
change - ƒnderung eines bestehenden Ereignisses.                                                    

SYNOPSIS
change Ereignisnummer [-p Prozeﬂliste] [-evqx] [-c Z‰hlung]
        [Stopausdruck|Aufruf...|Signal...] [{Befehle}]

BESCHREIBUNG
Ereignisnummer muﬂ als erstes stehen und gibt die Ereignisnummer
eines bestehenden, g¸ltigen Ereignisses an. Die anderen Optionen
ermˆglichen die ƒnderung der verschiedenen Attribute dieses
Ereignisses:
1) Die Liste der Ablaufstr‰nge und Prozesse, f¸r die
   es gilt (-p). 
2) die Anzeige (-q unterdr¸ckt die Ank¸ndigung eines Ereignisses,
   -v gibt alle Informationen an), 
3) F¸r Systemaufrufe f¸r das Auftreten des Ereignisses am Anfang 
   oder am Ende oder zu beiden Zeitpunkten (-ex), 
4) F¸r Stopp- und Systemaufrufereignisse die Anzahl des Auftretens
   des Ereignisses, bevor es angek¸ndigt wird (-c), 
5) Die zugehˆrigen Befehle (m¸ssen in geschweiften Klammern {} stehen), 
6) und der Ausdruck, die Systemaufrufliste oder die Signalliste in
   Verbindung mit einem Ereignis.

BEISPIELE
change 3 -q
change 5 -p p2 -c 10
change 7 { print "x == ", x }
change 9 -x write

SIEHE AUCH
assoccmd, delete, disable, enable, events, onstop,
Prozeﬂliste, signal, stop, syscall
++

++ export
NAME
export - F¸gt der Umgebung ein Paar Name-Wert hinzu.                                                    

SYNOPSIS
export $username

BESCHREIBUNG
Exportiert eine f¸r den Debugger erhaltene, benutzerdefinierte
Variable f¸r die Umgebung. 'username' (und dessen aktueller Wert)
wird ein Teil der Umgebung, der von den mit Debugger erstellten
Prozessen empfangen wird. Wenn der Wert von $username sich ‰ndert,
muﬂ er erneut exportiert werden, damit der neue Wert Teil der Umgebung 
werden kann. 'username' wird ohne das Pr‰fix '$' exportiert.

SIEHE AUCH
Benutzervariablen
++

++ fc
NAME
fc - Findet, bearbeitet und f¸hrt Befehle erneut aus.

SYNOPSIS
fc [-e ename] [-nlr] [first [last]]
fc -e - [old=new] [Befehl]

BESCHREIBUNG
'fc' ermˆglicht das Bearbeiten und Abrufen von Befehlen 'ksh(1)
style'. In der ersten Form wird eine Reihe von Befehlen von
'first' bis 'last' aus den zuletzt eingegebenen Befehlen HISTSIZE
gew‰hlt. Die Argumente 'first' und 'last' kˆnnen als Zahlen oder
als Zeichenketten angegeben werden. Eine Zeichenkette wird
verwendet, um den letzten Befehl, der mit dieser Zeichenkette
beginnt, zu finden. Eine negative Zahl wird als Offset f¸r die
aktuelle Befehlszahl verwendet.

Wenn die Option -l angegeben ist, werden die Befehle auf dem
Standard-Ausgabeger‰t aufgelistet. Andernfalls wird der
Programmeditor 'ename' f¸r eine tempor‰re Datei aufgerufen, die
die Befehle enth‰lt. Wenn 'ename' nicht angegeben ist, wird der
Wert der Umgebunsgvariablen FCEDIT (default /usr/bin/ed)
verwendet. Wenn die Bearbeitung beendet ist, werden die
bearbeiteten Befehle ausgef¸hrt.

Wenn 'first' nicht angegeben ist, wird als Standard der
vorhergehende Befehl f¸r die Bearbeitung und -16 f¸r die Liste
genommen. Die Option -r kehrt die Reihenfolge der Befehle um; die
Option -n unterdr¸ckt Befehlsnummern beim Auflisten.

In der zweiten Form wird der Befehl 'Befehl' nach dem Austausch
'old=new' erneut ausgef¸hrt. Wenn 'Befehl' nicht angegeben ist,
wird als Standard der vorhergehende Befehl verwendet.

SIEHE AUCH
%mode
++

++ logoff
NAME
logoff - Stoppt die Protokollierung von Sitzungen.

SYNOPSIS
logoff

BESCHREIBUNG
Schaltet die Protokollierung von Sitzungen ab.

SIEHE AUCH
logon
++


++ logon
NAME
logon - Startet Protokollierung von Sitzungen.

SYNOPSIS
logon [Protokolldatei]

BESCHREIBUNG
Startet Protokollierung von Sitzungen. Alle Debugger-Ausgaben werden an
'Protokolldatei' gesendet. Jede Ausgabezeile beginnt mit dem Zeichen #
(Kommentar). Debugger-Befehle werden ebenfalls an 'Protokolldatei'
gesendet, aber ohne vorstehendes #. Wenn keine 'Protokolldatei'
angegeben ist, wird die zuletzt in der aktuellen Debug-Sitzung
verwendete 'Protokolldatei' angenommen. Neue Befehle und Ausgaben
werden an dieser Datei angeh‰ngt. Die vom Debugger erstellten
Protokolldateien kˆnnen als Debuggers-Befehlsskripts verwendet werden.

SIEHE AUCH
logoff, script
++


++ onstop
NAME
onstop - Definiert die auszuf¸hrende Aktion, wenn der
Ablaufstrang oder Prozeﬂ anh‰lt.

SYNOPSIS
onstop [-p Prozeﬂliste] [Befehl]

BESCHREIBUNG
Ohne Argument 'Befehl' werden die aktuellen Aktionen des Befehls
'onstop' f¸r die Liste der in 'Prozeﬂliste' angegebenen
Ablaufstr‰nge und Prozesse angezeigt.

'Befehl' kann ein einzelner Befehl oder ein Befehlsblock sein.
Wenn ein Befehl oder ein Befehlsblock angegeben ist, werden
jedesmal, wenn eiin angegebener Ablaufstrang oder Prozeﬂ anh‰lt,
die Befehle ausgef¸hrt (im Kontext mit diesem Ablaufstrang
oder Prozeﬂ). Das Anhalten enth‰lt einzelne Schritte sowie das
Anhalten f¸r en anderes Debugger-Ereignis (signal, syscall,
stop).

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
dieses Befehls f¸r alle Ablaufstr‰nge oder alle vom aktuellen
Programm (%program) abgeleiteten Einschritt-Prozesse, wenn die
Option -p nicht angegeben ist.

BEISPIELE
onstop -p p2
onstop { print i, x[i] }

SIEHE AUCH
%program, delete, disable, enable, events, signal,
stop, syscall
++

++ rename
NAME
rename - ƒndert den Namen, unter dem ein Programm bekannt ist.

SYNOPSIS
rename Programmname Name

BESCHREIBUNG
Wenn ein Prozeﬂ ¸bernommen oder erstellt wird, kann der Name des
ausf¸hrbaren Programms, von dem der Prozeﬂ abgeleitet wurde, f¸r 
den Bezug auf alle von diesem ausf¸hrbaren Programm abgeleiteten
Ablaufstr‰nge und Prozesse in jedem Argument 'Prozeﬂliste' verwendet 
werden. Umbenennen gibt einen neuen Namen f¸r die Verwendung mit 
diesem Programm an.

SIEHE AUCH
create, grab, Prozeﬂliste
++

++ %file
NAME
%file - Die aktuelle Ursprungsdatei.

BESCHREIBUNG
'%file' wird auf den Namen der Ursprungsdatei in Verbindung mit dem
aktuellen Rahmen, falls bekannt, definiert, sobald ein
Ablaufstrang oder Prozeﬂ anh‰lt oder '%frame' ge‰ndert wird.
Jeder Ablaufstrang oder Einschritt-Prozeﬂ hat seine eigene
%file. Der erste Befehl 'list' nach der Definition von %frame
zeigt die Quelle von %file an, wenn kein Dateiname angegeben ist.
Sie kˆnnen %file nicht explizit ‰ndern.

SIEHE AUCH
%frame, %line, %list_file, %list_line, list
++

++ %follow
NAME
%follow - Soll der Debugger untergeordnete Prozesse verfolgen?

BESCHREIBUNG
Der Debugger steuert Prozesse f¸r den Benutzer, die entweder vom
Debugger als Ergebnis eines Befehls 'create' erstellt wurden,
oder w‰hrend einer Ausf¸hrung als ein Ergebnis des Befehls 'grab'
¸bernommen wurden. Wenn '%follow' entweder auf 'all' oder 'procs'
gesetzt wird, ¸bernimmt der Debugger auch die Steuerung der
untergeordneten Prozesse aller gesteuerten Prozesse mit Verzweigung. Wenn
'%follow' auf 'none' gesetzt ist, werden keine untergeordneten Prozesse
gesteuert. Die mit %follow gesetzte, globale Betriebsart kann
durch einen individuellen Befehl 'create' oder 'grab'
¸berschrieben werden. Alle gesteuerten Prozesse kˆnnen mit dem
Befehl 'release' aus der Steuerung freigegeben werden.

Der Standardwert f¸r %follow ist 'all'.

Alle von einem Hauptprozeﬂ erstellten Ablaufstr‰nge werden vom
Debugger verfolgt (kˆnnen aber mit 'release' aus der Verfolgung
freigegeben werden). Siehe Beschreibung von %thread_change f¸r
weitere Informationen ¸ber die Steuerung des Debuggers in Bezug
auf neu erstellte Ablaufstr‰nge.

SIEHE AUCH
create, grab, Prozeﬂ, release, set, %thread_change
++

++ %frame
NAME
%frame - Die aktuelle Rahmennummer im Aufrufstapel.

SYNOPSIS
Das Standard-Ziel f¸r Ursprungslisten, Symboldurchsicht,
Disassemblierung und Bewertung von Ausdr¸cken. '%frame' ist auf
die Zahl des obersten Rahmens (Numerierung ab 0 f¸r den
Anfangsrahmen) definiert, wenn ein Ablaufstrang oder ein
Einschritt-Prozeﬂ anh‰lt. Jeder Ablaufstrang oder
Einschritt-Prozeﬂ hat seinen eigenen %frame. Sie m¸ssen %frame
explizit mit dem Befehl 'set' definieren. Die Definition von
%frame wird auch die damit verbundenen Variablen %db_lang, %file,
%func, %line, %list_file, %list_line und %loc zur¸cksetzen, um
einen ‹berblick ¸ber den aktuellen Kontext zu erhalten.

SIEHE AUCH
%db_lang, %file, %func, %line, %loc
++


++ %func
NAME
%func - Die aktuelle Funktion.

BESCHREIBUNG
'%func' wird auf den Namen der entsprechenden Funktion des
aktuellen Rahmens (%frame) gesetzt, sobald ein Ablaufstrang oder
Einschritt-Prozeﬂ anh‰lt oder '%frame' ge‰ndert wird. Jeder
Ablaufstrang oder Einschritt-Prozeﬂ hat sein eigenes Argument
'%func'. Sie kˆnnen %func explizit mit dem Befehl 'set'
definieren. aber nur f¸r eine Funktion mit einem im Stapel aktiven
Rahmen; %frame (und die dazugehˆrigen Variablen %db_lang, %file,
%func, %line, %list_file, %list_line und %loc) werden ebenfalls
aktualisiert, um den neuen Kontext wiederzugeben.

SIEHE AUCH
%frame
++


++ %lang
NAME
%lang - Die aktuelle Programmiersprache.

BESCHREIBUNG
Die aktuelle Programmiersprache. Wenn dieses Argument angegeben
ist, wird der Wert von %db_lang ¸berschrieben. G¸ltige
Zeichenketten f¸r die Zuweisung von %lang sind: 
       C      ANSI C 
       C++    C++ Version 2 oder 3
Wenn %lang gesetzt ist oder mit einer leeren
Zeichenkette ('') definiert ist, verwendet der Debugger %db_lang
als aktuelle Sprache. Befehle, die %lang in der Bewertung von
Ausdr¸cken verwenden, enthalten if, print, set, stop, whatis,
while

SIEHE AUCH
%db_lang, C++, Ausdruck
++

++ %loc
NAME
%loc - Die aktuelle Stelle.  

BESCHREIBUNG
Der aktuelle Ausf¸hrungspunkt, %loc, wird f¸r den aktuellen
Rahmen auf den Inhalt des Programmz‰hlers gesetzt, sobald ein
Ablaufstrang oder Einschritt-Prozeﬂ anh‰lt oder %frame ge‰ndert
wird. Jeder Ablaufstrang oder Einschritt-Prozeﬂ hat sein eigenes
Argument '%loc'. Sie kˆnnen %loc nicht explizit ‰ndern. Der erste
Befehl 'dis', nachdem der Rahmen (%frame) definiert ist, wird
Befehle ab der Adresse %loc disassemblieren, wenn keine Stelle
explizit angegeben wurde.

SIEHE AUCH
%frame, dis
++

++ %list_file
NAME
%list_file - Der Name der zuletzt aufgelisteten Datei.                                                    

BESCHREIBUNG
Der Befehl 'list_file' speichert Spuren der zuletzt mit dem
Befehl 'list' angezeigten Datei. %list_file ‰ndert sich, sobald
der Befehl 'list' ausgef¸hrt wird, und wird auf den Namen der
Datei zur¸ckgesetzt, die die aktuelle Stelle (%loc) im aktuellen
Rahmen (%frame) enth‰lt, sobald ein Ablaufstrang oder
Einschritt-Prozeﬂ anh‰lt oder %frame ge‰ndert wird. Jeder
Ablaufstrang oder Einschritt-Prozeﬂ hat sein eigenes Argument
'%list_file'.

SIEHE AUCH
%file, %frame, %line, %list_line, list
++

++ %list_line
NAME
%list_line - Die zuletzt aufgelistete Zeilennummer.

BESCHREIBUNG
Der Befehl 'list_line' speichert Spuren der zuletzt mit dem
Befehl 'line' angezeigten Datei. %list_line ‰ndert sich, sobald
der Befehl 'list' ausgef¸hrt wird, und wird auf die Zeilennummer
zur¸ckgesetzt, die die aktuelle Stelle (%loc) im aktuellen Rahmen
(%frame) enth‰lt, sobald ein Ablaufstrang oder Einschritt-Prozeﬂ
anh‰lt oder %frame ge‰ndert wird. Jeder Ablaufstrang oder
Einschritt-Prozeﬂ hat sein eigenes Argument '%list_line'.

SIEHE AUCH
%file, %frame, %line, %list_file, list
++

++ %line
NAME
%line - Die aktuelle Zeilennummer.

BESCHREIBUNG
'%line ist auf die Zeilennummer gesetzt, die die aktuelle Stelle
(%loc) im aktuellen Rahmen (%frame) enth‰lt, sobald ein
Ablaufstrang oder Einschritt-Prozeﬂ anh‰lt oder %frame ge‰ndert
wird. Der erste Befehl 'list' nach Definition von %frame zeigt
den Ursprungsstart ab Zeile %line an, wenn keine Stelle angegeben
ist. Sie kˆnnen %line nicht explizit definieren.

SIEHE AUCH
%frame, %file, %list_file, %list_line, list
++

++ %mode
NAME
%mode - Die aktuelle Zeilenbearbeitungsart.                                                    

BESCHREIBUNG
Debug unterst¸tzt die Aufzeichnung und die Bearbeitung von
Befehlen 'ksh(1) style'. '%mode ist die f¸r die Bearbeitung der
Befehlszeile verwendete Bearbeitungsart. %mode wird beim Starten
auf den Wert der Umgebungsvariablen VISUAL gesetzt, oder, wenn
sie nicht existiert, auf den Wert der Umgebungsvariablen EDITOR.
Sie kann jederzeit mit dem Befehl 'set' zur¸ckgesetzt werden.
G¸ltige Werte sind 'vi' und 'emacs'. Das Setzen von %mode auf
einen anderen Wert bricht die Befehlsbearbeitung ab.

SIEHE AUCH
fc
++

++ %path
NAME
%path - Der lokale Suchpfad f¸r Ursprungsdateien.

BESCHREIBUNG
Jedes Programm hat sein eigenes Argument %path. Der Wert von
%path muﬂ eine durch Komma getrennte Liste von Verzeichnisnamen
sein. Wenn der Debugger versucht, die Ursprungszeilen einer Datei
anzuzeigen, wird er die in %path angegebenen Verzeichnisse nach
einer Datei dieses Namens durchsuchen. Nach der Suche im lokalen
Pfad wird das angegebene Programm angezeigt und der Debugger
sucht seine globale Pfadliste (%global_path).

SIEHE AUCH
%global_path
++

++ %proc
NAME
%proc - Der aktuelle Prozeﬂ.

BESCHREIBUNG
Diese Variable enth‰lt den Prozeﬂnamen des aktuellen Prozesses.
er kann explizit mit dem Befehl 'set' oder implizit mit 'create',
'grab' oder 'release' bestimmt werden. Die Definition von %proc
bestimmt auch implizit %program, %thread und %frame.

SIEHE AUCH
%frame, %program, %thread, Prozeﬂliste
++

++ %program
NAME
%program - Das aktuelle Programm.

BESCHREIBUNG
Diese Variable enth‰lt den Programmnamen des Programms, das den
aktuellen Prozeﬂ (%proc) enth‰lt. Sie kˆnnen es explizit mit dem
Befehl 'set' oder implizit mit 'create', 'grab' oder 'release'
definieren. Programme werden von der ausf¸hrbaren Datei benannt,
von der sie abgeleitet wurden und kˆnnen mit dem Befehl 'rename'
umbenannt werden. Die Definition von %program bestimmt auch
implizit %proc, %thread und %frame.

SIEHE AUCH
%frame, %proc, %thread, Prozeﬂliste
++

++ %prompt
NAME
%prompt - Das Bereitschaftszeichen des Debuggers.

BESCHREIBUNG
Das Bereitschaftszeichen des Debuggers fordert den Benutzer zur
Eingabe auf, indem der Wert des Bereitschaftszeichens (%prompt)
ausgedruckt wird. Der Standard-Wert ist 'debug>'. Sie kˆnnen das
%prompt mit dem Befehl 'set' ‰ndern. ++

++ %thisevent
NAME
%thisevent - Die Nummer des derzeit behandelten Ereignisses.

BESCHREIBUNG
Innerhalb eines zugehˆrigen Befehls enth‰lt %thisevent die
Ereignisnummer des Ereignisses, zu dem die Befehle gehˆren. Den
Wert von %thisevent kˆnnen Sie nicht explizit ‰ndern.                                                    

SIEHE AUCH
%lastevent, assoccmd
++


++ %lastevent
NAME
%lastevent - Die Nummer des zuletzt erstellten Ereignisses.

BESCHREIBUNG
Nach einem Befehl, der eine Ereignissnummer zuteilt (stop,
signal, syscall, oder onstop), enth‰lt %thisevent die gerade
zugeteilte Ereignisnummer. Den Wert von %lastevent kˆnnen Sie
nicht explizit ‰ndern.

SIEHE AUCH
%thisevent
++


++ assoccmd
NAME
assoccmd - Ein Debugger-Befehl oder Befehlsblock.                                                    

BESCHREIBUNG
Verschiedene Befehle verwenden einen optional zugeteilten Befehl
oder einen Befehlsblock. Dieser muﬂ als letzter in der
Argumentliste erscheinen und kann Befehle mit eigenen,
zugeteilten Befehlen enthlaten, d.h. zugeteilte Befehle kˆnnen
verschachtelt sein. Die Befehle werden ausgef¸hrt, sobald das
betreffende Ereignis (stop, signal, usw.) auftritt. Innerhalb
eines zugeteilten Befehls enth‰lt %thisevent die Ereignisnummer
des zu behandelnden Ereignisses. Der Ablaufstrang oder Prozeﬂ,
der dieses Ereignis angetroffen hat, wird vor¸bergehend als
aktuell deklariert, w‰hrend die Befehle ausgef¸hrt werden.

SIEHE AUCH
%thisevent, Block, onstop, signal, stop, syscall
++

++ Block
NAME
Block - Eine Liste von Befehlen.

BESCHREIBUNG
Ein Befehl oder eine Liste mit durch Strichpunkt getrennten Befehlen in
geschweiften Klammern. Blˆcke kˆnnen als zugeteilte Befehle
verwendet werden oder unabh‰ngig von anderen Befehlen erscheinen.
Blˆcke kˆnnen f¸r die Zusammenfassung von Befehlen zur Umleitung
deren Ausgabe mit einer einzigen Umleitung verwendet werden.

BEISPIELE
{ if (i) print *ptr; else print *mptr } > myfile

SIEHE AUCH
assoccmd, Umleitung
++

++ Format
NAME
Format - Die Form der Ausgabe f¸r den Befehl 'print'.

BESCHREIBUNG
Das Format ist eine Zeichenkette ‰hnlich wie die Zeichenketten
f¸r den C-Befehl 'printf'. Jede Spezifikation eines Formates kann
wie folgt angegeben werden:
        %[flags][width][.[precision]][conversion_character]format_character
 Alle Felder haben die gleiche Bedeutung wie beimn Befehl
'printf'. Breite und Pr‰zision sind auf 1024 begrenzt. Die
Positionsparameter von printf und das Formatzeichen von 'printf'
'n' werden nicht akzeptiert. Jede Formatangabe entspricht einem
der im Befehl 'print' angegebenen Ausdr¸cke in der Reihenfolge,
in der sie stehen. Zeichen, die nicht zum Format gehˆren werden
wie angegeben ausgedruckt. Formatzeichen haben folgende
Bedeutungen (Elemente, die mit einem Sternchen (*) versehen sind
kˆnnen nicht auf allen Systemen zur Verf¸gung stehen):
        a*,A*   Gleitpunkt in hexadezimal mit dezimalem Exponent (als
                Zweierpotenz)
        b*,B*   Bin‰re Ganzzahl ohne Vorzeichen 
        C*      Breites Zeichen c Zeichen ohne Vorzeichen
        d,i     Dezimale Ganzzahl mit Vorzeichen
        e,E     Gleitpunkt in 'style [-]d.ddde+/-dd'
        f       Gleitpunkt in 'style [-]ddd.dddd'
        g,G     Gleitpunkt in einem der obigen Formate
        o       Oktalzahl ohne Vorzeichen
        p       ung¸ltig * (gemeiner Zeiger; hexadezimale Adresse)
        S*      Breite Zeichenkette
        s       Zeichenkette
        u       Dezimale Ganzzahl ohne Vorzeichen
        x,X     Hexadezimale Ganzzahl ohne Vorzeichen
        z       Standard-Format des Debuggers f¸r
                den Ausdruck
        %       %

SIEHE AUCH
print
++

++ Standort
NAME
Standort - Eine Adresse in einem Ablaufstrang oder Prozeﬂ.

BRSCHREIBUNG
Die Syntax f¸r einen Stellenindikator lautet Adresse[+-Konstante]
        [Ablaufstrang-ID@][Dateiname@]line
        [Ablaufstrang-ID@][Dateiname@]Funktion[+-Konstante]
wobei 'Adresse' eine oktale oder hexadezimale Programmadresse und 
'Konstante' eine dezimale Ganzzahl ist. 'Ablaufstrang-ID' kann sich 
auf einen Ablaufstrang oder Einschritt-Prozeﬂ beziehen.

BEISPIELE
17              eine Zeilennummer in der aktuellen Datei (%file)
foo.c@17        eine Zeilennummer in einer anderen Datei
0x80801234      eine Adresse
main            ein Funktionsname oder ein Etikett
main+3          drei Byte nach dem Etikett
p1.2@main       ein Funktionsname in einem angegebenen Ablaufstrang
%loc            die aktuelle Stelle
%line           die aktuelle Datei- und Zeilennummer
%r0             ein Register
%r0+80          ein Register plus Offset
%pc-4           ein Register minus Offset
$myvar          eine benutzerdefiniert Variable

SIEHE AUCH
%file, %line, %loc, Bereich, Benutzervariablen
++

++ Prozeﬂliste
NAME
Prozeﬂliste - Liste mit Prozeﬂnamen.

BESCHREIBUNG
Eine durch Komma getrennte Liste von 'Prozeﬂnamen'. Die meisten
Befehle akzeptieren eine 'Prozeﬂliste' mit der Option -p. Eine
Prozeﬂliste darf keine Leerzeichen enthalten.

Ein Prozeﬂname kann aus folgenden Elementen bestehen:
1)  dem Schl¸sselwort 'all', zur Bezeichnung aller gesteuerten
    Ablaufstr‰nge und Prozesse,
2)  ein vom Anwender angegebenen oder vom Debugger erstellten
    Programmnamen, der alle von diesem Programm abgeleitete
    Ablaufstr‰nge und Prozesse bezeichnet,
3)  eine vom Debugger erstellte Prozeﬂ-ID in der Form pn (z.B.
    p1, p2), das entweder den Prozeﬂ selbst (bei einem
    Einschritt-Prozeﬂ), oder alle Ablaufstr‰nge im Prozeﬂ
    bezeichnet,
4)  eine vom Debugger erstellte Ablaufstrang-ID in der Form pn.n
    (z.B. p2.3, p3.1),
5)  die Debugger-Variable %program, die alle vom aktuellen
    Programm abgeleiteten Ablaufstr‰nge und Prozesse bezeichnet,
6)  die Debugger-Variable %proc, die den aktuellen Prozeﬂ
    bezeichnet, wenn es ein Einschritt-Prozeﬂ ist, oder alle vom
    aktuellen Prozeﬂ abgeleitete Ablaufstr‰nge,
7)  die Debugger-Variable %thread, die den aktuellen Ablaufstrang
    bezeichnet,
8)  eine dezimale Ganzzahl, die der Systemprozess-ID eines
    gesteuerten Prozesses und allen davon abgeleiteten
    Ablaufstr‰ngen entspricht,
9)  jegliche benutzerdefiniert variable (z.B. $foo), die einen
    Ganzzahlwert enth‰lt, und als Systemprozeﬂ-ID ausgelegt
    wird,
10) jegliche benutzerdefiniert variable, die einen
    Zeichenkettenwert enth‰lt, der als eine der o.a. Formen oder
    als eine Liste ausgelegt werden kann.

SIEHE AUCH
%proc, %program, %thread, Prozeﬂliste, rename, Benutzervariablen
++

++ Umleitung
NAME
Umleitung - ƒnderung des Ziels f¸r die Debugger-Ausgabe.                                                    

BESCHREIBUNG
Hinter jedem Befehl oder jedem Block kann das Zeichen '>' und ein
Dateiname oder ein '|' und eine Befehlszeile der UNIX (r)-Shell
stehen. Dies veranlaﬂt die Umleitung der Ausgabe des Befehls in
die Datei oder die Umleitung in den Shell-Befehl. Sie kˆnnen auch
'>> Dateiname' verwenden, wobei die Ausgabe an die Datei
angeh‰ngt wird und nicht den aktuellen Inhalt der Datei
¸berschreibt.

BEISPIELE
stack > save.stack
symbols -gtv | grep int | pg

SIEHE AUCH
Block
++

++ Muster
NAME
Muster - ein reul‰rer Ausdruck 'sh(1) style'.                                                    

BESCHREIBUNG
Ein Modell zur Filterung der Ausgabe des Befehls 'symbols'.
        *       Steht f¸r jede Zeichenkette, einschlieﬂlich
                Nullkette 
        ?       Steht f¸r ein einzelnen Zeichen
        [...]   Steht f¸r jedes der in Klammern stehenden Zeichen, 
                Bereiche
                        sind zul‰ssig, und ! als erstes Zeichen
                        gibt eine Negation an

SIEHE AUCH
symbols
++

++ norm_Ausdruck
NAME
norm_Ausdruck - ein regul‰rer Ausdruck 'ed(1) style'.

BESCHREIBUNG
Ein regul‰rer Ausdruck, der zur Suche eines Modells in einer Ursprungsdatei mit dem Befehl 'list' verwendet wird.
        .       Steht f¸r ein beliebiges Zeichen auﬂer CR/LF
        [...]   Steht f¸r jedes der Zeichen in Klammer,
                Bereiche sind zul‰ssig, und ^ bedeutet eine Negation
        *       bedeutet Null oder mehr der vorhergehenden RE
        ^       Steht f¸r eine Nullkette am Anfang einer Zeile
        $       Steht f¸r eine Nullkette am Ende einer Zeile
        \{m\}   Gibt genau m Auftreten des vorhergehenden RE an
        \{m,\}  Gibt mindestens m Auftreten des vorhergehenden RE an
        \{m,n\} Bedeutet n zu n, inklusive, Auftreten
        \(...\) Steht f¸r das gleiche wie ... 
        \digit  Steht f¸r die n'te RE in Klammer im gleichen Ausdruck
        \<      Steht f¸r eine Nullkette am Anfang eines Wortes
        \>      Steht f¸r eine Nullkette am Ende eines Wortes

SIEHE AUCH
list
++

++ Benutzervariablen
NAME
Benutzervariablen - benutzerdefinierte oder f¸r den Debugger erhaltene
Variablen.

BESCHREIBUNG
Namen, die mit einem Dollarzeichen ($) beginnen sind f¸r den
Debugger-Benutzer reserviert. Beim Starten importiert der
Debugger die Shell-Umgebung als einen Ausgangssatz von
benutzerdefinierten Variablen. Sie kˆnnen mit dem Befehl 'set'
eine neue Variable erstellen. Benutzerdefinierte Variablen sind
Zeichenketten und werden, wo erforderlich, mit
'strtol(3)' in einen Zahlenwert umgewandelt.

SIEHE AUCH
export, set
++

++ %db_lang
NAME
%db_lang - Die interne Notierung des Debuggers f¸r die aktuelle
Sprache.

BESCHREIBUNG
'db_lang' ist die Sprache des aktuellen Ablaufstranges oder
Prozesses und wird vom Debugger zur Bewertung von
Sprachausdr¸cken verwendet. Es wird vom Debugger basierend auf
den in der Objektdatei enthaltenen Informationen definiert und
kann nicht direkt vom Benutzer zur¸ckgesetzt werden.. Wenn der
Debugger nicht die Sprache des aktuellen Ablaufstrangs oder
Prozesses bestimmen kann, wird der Standardwert ovn %db_lang, C,
angenommen. Ein explizites Definieren von %lang ¸berschreibt die
Sprache des aktuellen Ablaufstranges oder Prozesses. Befehle, die
%db_lang zur Bewertung von Ausdr¸cken verwenden, umfassen if,
print, set, stop, whatis, und while

SIEHE AUCH
%lang, C++, Ausdruck
++

++ %global_path
NAME
%global_path - Der globale Suchpfad des Debuggers.

BESCHREIBUNG
Der Wert von %global_path muﬂ eine durch Komma getrennte Liste
von Verzeichnisnamen sein. Wenn der Debugger versucht, die
Ursprungszeilen einer Datei anzuzeigen, wird er die im lokalen %path
angegebenen Verzeichnisse nach einer Datei dieses Namens
durchsuchen. Nach der Suche im lokalen Pfad wird das angegebene
Programm angezeigt und der Debugger sucht seine globale Pfadliste
(%global_path). '%global_path' kann auch von der Befehlszeile des
Debugger aus mit der Option -s gesetzt werden.

SIEHE AUCH
%path
++

++ %num_bytes
NAME
%num_bytes - Standard-Anzahl der auszugebenden Byte.

BESCHREIBUNG
Wenn der Befehl 'dump' ohne die Option -c angegeben wird, werden
%num_bytes angezeigt. Der Ausgangswert von %num_bytes betr‰gt 256
und kann mit dem Befehl 'set' ge‰ndert werden.

SIEHE AUCH
dump
++

++ %num_lines
NAME
%num_lines -- Anzahl anzuzeigender Zeilen

BESCHREIBUNG
Wenn der Befehl 'dis' oder 'list' ohne die Option -c angegeben
wird, werden jeweils %num_lines Zeilen angezeigt. Der
Ausgangswert von %num_lines betr‰gt 10 und kann mit dem Befehl
'set' ge‰ndert werden.

SIEHE AUCH
dis, list
++

++ %result
NAME
%result - Ausf¸hrungs-Status der Debugger-Befehle.

BESCHREIBUNG
Nach der Ausf¸hrung jedes Debugger-Befehls, wird dessen Status in
der Variablen %result gespeichert. 0 bedeutet erfolgreiche
Ausf¸hrung. Ungleich Null bedeutet einen Ausf¸hrungsfehler. ++

++ %verbose
NAME
%verbose - Detail der Informationen f¸r Debugger-Ereignisse.

BESCHREIBUNG
Wenn ein vom Debugger gesteuerter Ablaufstrang oder Prozeﬂ
anh‰lt, druckt der Debugger normalerweise eine Meldung aus, um
den Grund f¸r das Anhalten, die Ablaufstrang- oder Prozeﬂ-ID und
die n‰chste Ursprungszeile, wenn vorhanden, oder die n‰chste Zeile
des disassemblierten Textes anzugeben.'%verbose' kann zur
Steuerung dieser Ausgabe verwendet werden. G¸ltige Werte sind:
        quiet es erfolgt keine Ausgabe, wenn ein Ablaufstrang
        oder Prozeﬂ anh‰lt source es wird nur die n‰chste Zeile
        mit Ursprungstext oder mit disassembliertem Text angezeigt
        events wenn ein Ereignis das Anhalten ausgelˆst hat, wird
        auch dieses Ereignis angezeigt (dies betrifft nicht die
                angeforderten Stopps (Stopps oder Einzelschritt))
        reason Grund f¸r das Anhalten, einschlieﬂlich Ereignisse
        und angeforderte Stopps all hˆchste Detailstufe (derzeit
        gleich mit 'reason')

Die Standard-Betriebsart ist 'all'.
Die Betriebsart 'quiet' kann auch als Option -q bei bestimmten
Debugger-Befehlen angegeben werden. Diese individuellen Optionen
-q ¸berschreiben die Betriebsart %verbose.

SIEHE AUCH
change, signal, step, stop, syscall, %thread_change
++

++ %wait
NAME
%wait - Synchrone oder asynchrone Befehlsausf¸hrung.

BESCHREIBUNG
Wenn der Debugger einen Ablaufstrang oder Einschritt-Prozeﬂ
startet, wartet er normalerweise, bis der Ablaufstrang oder
Prozeﬂ anh‰lt, bevor er die Steuerung en den Benutzer ¸bergibt.
Wenn %wait auf 'background', 0 oder 'no' gesetzt wird, geht der
Debugger in die asynchrone Betriebsart ¸ber. In dieser
Betriebsart ¸bergeben Befehle, die einen Ablaufstrang oder
Prozeﬂ starten, die Steuerung sofort an den Benutzer, ohne auf
das Anhalten des Ablaufstrangs oder Prozesses zu warten. Wenn
%wait auf 'foreground', 1 oder 'yes' gesetzt wird, geht der
Debugger wieder in die Standard-Betriebsart zur¸ck. Die globale
Variable %wait kann mit dem Optionen -f oder -b der Befehle 'run'
und 'step' ¸berschrieben werden.

SIEHE AUCH
run, step
++

++ Stopausdruck
NAME
Stopausdruck - Prozeﬂ Adresse Leertaste Ereignis Ausdr¸cke

BESCHREIBUNG
'Stopausdrucke' sind besondere Ausdr¸cke, die vom
Stopp-Befehl akzeptiert werden. Ein Stopausdruck
besteht aus einem oder mehreren Stopp-Ereignissen, die mit dem
Zeichen '&&' (und) oder '||' (oder) zusammengef¸hrt wurden. Diese
Operatoren sind linkszuordnend, aber der Debugger kann nicht die
Reihenfolge gew‰hrleisten, in der die Operatoren bewertet werden.
Jedes Stopp-Ereignis kann sein: 
        Standort 
        ( Ausdruck ) 
        *lvalue

Jeder Typ eines Stopp-Ereignisses hat eine bestimmte Aktion,
wodurch das Ereignis vom Debugger bemerkt wird. Wenn eine
derartige Aktion auftritt, wird der gesamte Stopp-Ausdruck auf
'wahr' bewertet. Wenn er wahr ist, lˆst das Ereignis normal aus
(der Debugger informiert den Benutzer ¸ber das Ereignis und f¸hrt
jeden dazugehˆrigen Befehl aus).

Eine Stelle ('Standort') ist eine Adresse im Text des Prozesses,
an der der Debugger einen Breakpoint setzen kann. Wenn ein
Ablaufstrang oder Prozeﬂ die angegebene Stelle erreicht, bemerkt
der Debugger das Ereignis. F¸r Stoppereignisse, die sich auf
Funktionsnamen beziehen, ist der Ausdruck wahr, solange diese
Funktion aktiv ist. F¸r Stoppereignisse, die f¸r eine besondere
Adresse oder Zeilennummer gelten, ist der Ausdruck nur wahr, wenn
sich der Ablaufstrang oder Prozeﬂ an dieser Adresse oder Zeile
befindet. Geben Sie 'help Standort' ein, um die komplette Syntax
dieses Befehls einzusehen. Wenn die aktuelle Sprache C++ ist,
kˆnnen Stoppereignisse auch die spezifischen Funktionen von C++
verwenden. Geben 'help C++' f¸r n‰here Einzelheiten ein.

'Ausdruck' kann jeder beliebige, g¸ltige Ausdruck in der aktuellen
Sprache (%lang oder %db_lang) sein. Der Debugger bemerkt das
Stopp-Ereignis, wenn ein beliebiger Identifikator im Ausdruck den
Wert ‰ndert. Dann wird der gesamte Ausdruck erneut im
Kontext der aktuellen Sprache bewertet.

'lvalue' kann jeder beliebige Ausdruck in der aktuellen Sprache
sein, der auf der linken Seite einer Zuweisung in dieser Sprache
g¸ltig w‰re. Der Debugger bemerkt dieses Ereignis, wenn sich der
Inhalt der Variablen 'Standort' ‰ndert. Die ƒnderung an sich
macht diese Art von Stoppereignis wahr.

Es kˆnnen noch umfangreichere Stoppausdr¸cke durch Kombinieren mit
Stoppereignissen erstellt werden, indem man den Operator && (und)
verwendet. Um zum Beispiel in der Funktion a nur anzuhalten, wenn
die Funktion b auch aktiv ist, geben Sie 'stop a &&b' ein. Um
anzuhalten, wenn der Wert eines Ausdruckes x innerhalb einer
Funktion y wahr wird, geben Sie 'stop y && (x)' ein.

BEISPIELE
stop myfile.c@230
stop *bar
stop (x == 5)
stop foo && (a > 7)
stop (a == 4) || (b == 7)                                                    

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Standort, Bereich, stop
++

++ %redir
NAME
%redir - Sollen die E/A des Prozesses umgeleitet werden?

BESCHREIBUNG
%redir' steuert das Verhalten des Befehls 'create'. Als
Standard werden die E/A des Prozesses bei 'create' nicht
umgeleitet, auﬂer wenn die Option -r angegeben ist. Wenn %redir
auf 1 oder 'yes' gesetzt ist, wird 'create' die E/A des
Prozesses umleiten, auﬂer wenn die Option -n angegeben ist. Das
Standard-Verhalten kann durch Setzen von %redir auf 0 oder 'no'
wiederhergestellt werden.

SIEHE AUCH
create, grab, input
++


++ Ausdruck
NAME
Ausdruck - Debugger-Ausdruck

BESCHREIBUNG
Debugger-Ausdr¸cke haben die gleiche Syntax wie die aktuelle
Sprache (%lang oder %db_lang). Der Debugger akzeptiert Ausdr¸cke,
die jegliche Kombination von Programmvariablen oder Funktionen,
qualifizierten Namen, integrierten Debugger-Variablen und
benutzerdefinierten Variablen enthalten. Ein qualifizierter Name
gibt einen Programmidentifikator an, der im aktuellen
Kontext nicht sichtbar sein kann. Die Syntax lautet:
       [[Ablaufstrang-ID]@][[Quelledatei]@][[Funktion]@][[Zeilennummer]@]Identifikator
    oder [[Ablaufstrang-ID]@]Rahmennummer@Identifikator oder
       [[Ablaufstrang-ID]@]Objektname@[Quelledatei@]Identifikator

Der qualifizierte Name wird von links nach rechts bewertet und
kann durch VErwendung von '@' verdeutlicht werden. 'Rahmennummer'
und 'Funktion' m¸ssen sich auf Funktionen beziehen, die derzeit
aktiv sind. 'Ablaufstrang-ID' kann sich auf einen Ablaufstrang oder
Einschritt-Prozeﬂ beziehen. 'Objektname' bezieht sich auf jedes
Objekt (ausf¸hrbare Datei oder geteilte Bibliothek), das im
Prozeﬂ enthalten ist.

Wenn die aktuelle Sprache C ist, unterst¸tzt 'debug' die
Bewertung aller legalen ANSI C Ausdr¸cke, auﬂer denen, die eine
Makro-Erweiterung oder Struktur, Verbindung oder Aufz‰hlung
erfordern. Ein Beispiel f¸r eine Typendeklaration in einem
Ausdruck lautet: 
        ((struct { int i; char c; } *)p)->c = 'a';

Wenn die aktuelle Sprache C++ ist, akzeptiert 'debug' einen
Nebensatz von C++-Ausdr¸cken. Sie C++ f¸r n‰here Einzelheiten.

Ausdr¸cke, die mit einem Bindestrich (-) beginnen oder
Zeichenfolgen mit besonderer Bedeutung f¸r den Debugger
enthalten, m¸ssen in runden, eckigen oder geschweiften Klammern
eingeschlossen werden. Spezielle Zeichenfolgen sind: >, >>, |,
||, &&, #, Komma, Strichpunkt, LF.

SIEHE AUCH
%db_lang, %lang, C++, if, print, Bereich, set, stop, Stopausdruck,
Benutzervariablen, while
++

++ Bereich
NAME
Bereich - Die Sichtbarkeit eines Programmidentifikators

BESCHREIBUNG
Debugger-Befehle, die Stellen oder Ausdr¸cke akzeptieren kˆnnen
sich auf Identifikatoren in gesteuerten Programmen beziehen:
Funktionen, Parameter, Variablen, Etiketten, Typen, Struktur und
Verbindungen sowie Mitgliedsnamen und Aufz‰hlungen. Stellen
kˆnnen sich auch auf Ursprungszeilennummern beziehen. Ob ein Name f¸r
den Debugger jederzeit sichtbar ist, h‰ngt vom Status des
Programms zu diesem Zeitpunkt ab (Kontext) und von der Menge
der Debug-Informationen, die das Programm an den Debugger
liefert.

Ursprungszeilennummern, Namen von lokalen Variablen f¸r eine
spezifische Funktion, Parameternamen, Typennamen, Struktur und
Verbindung sowie Mitgliedsnamen und Aufz‰hlungen sind nur
verf¸gbar, wenn die Datei, in der sie sich befinden, mit der
Option -g kompiliert wurde. Namen von globalen und
dateistatischen Funktionen und Variablen sind verf¸gbar, wenn die
Datei, die sie definiert, mit der Option -g kompiliert wurde oder
die Symboltabelle des Programms nicht abgelegt wurde.

Ursprungszeilennummern und dateistatische Funktionen und Variablen
sind nur sichtbar, wenn der aktuelle Kontext sich in dieser
Datei befindet, d.h., wenn das Programm irgendwo in dem von
dieser Datei erstellten Code angehalten ist. Funktionsparameter
sind nur sichtbar, wenn der aktuelle Kontext sich in dieser
Funktion befindet. Lokale Variablen sind nur sichtbar, wenn der
aktuelle Kontext sich innerhalb deren Definitionsblock
befindet.

Identifikatoren, die nicht im aktuellen Kontext sichtbar
sind, kˆnnen oft noch in Stellen oder Ausdr¸cken erfaﬂt werden,
wenn man deren qualifizierten Namen verwendet. Siehe 'Ausdruck' und
'Standort' f¸r die komplette Syntax.                                                    

Symbole, die in geteilten Bibliotheken definiert sind, sind nicht
sichtbar, bis diese Bibliotheken vom dynamischen Linker geladen
werden. Symbole von geteilten Bibliotheken, die mit Aufrufen
dlopen(3X) geladen wurden, sind nur nach dem Aufruf dlopen
verf¸gbar.

SIEHE AUCH
%frame, %func, %line, Ausdruck, Standort
++

++ whatis
NAME
whatis - Zeigt den Typ eines Ausdrucks an.

SYNOPSIS
whatis [-p Prozeﬂliste] Ausdruck

BESCHREIBUNG
'whatis' zeigt den Typ des Ausdrucks im aktuellen Kontext
(%frame) an. Wenn 'Prozeﬂliste' angegeben ist, wird der Typ des
Ausdrucks im Kontext jedes Ablaufstranges oder Prozesses in
der Liste bewertet.'Ausdruck' kann jeglicher Ausdruck in der
aktuellen Sprache sein.

Wenn eine Variable ein Struktur- oder Klassentyp ist, zeigt
'whatis Variable' den Namen der Struktur oder Klasse an. 'whatis
structure_tag_name' oder 'whatis type_name' zeigt ale bekannten
Informationen ¸ber diesen Typ an, einschlieﬂlich der
Strukturelemente oder Aufz‰hlungen.

Wenn ein Zeiger f¸r ein Basisklassenobjekt mit virtuellen Funktionen
gegeben ist, und wenn die Fehlerbehebungsfunktion feststellen
kann, daﬂ der Objekttyp von der Basisklasse abgeleitet ist,
wird whatis sowohl die Basisklasse als auch die abgeleitete
Klasse anzeigen.                                                    

BEISPIELE
whatis i
whatis main
whatis (i + 1) * 2.0
whatis struct foobar

SIEHE AUCH
%db_lang, C++, Ausdruck
++

++ Programm
NAME
Programm - ein ausf¸hrbares Objekt.

BESCHREIBUNG
Ein Programm ist ein ausf¸hrbares Objekt in allen durch
die Fehlerbehebungsfunktion verst‰ndlichen Objektdateiformaten
und in allen der gemeinsam benutzten Bibliotheken, die das
ausf¸hrbare Objekt beim Startzeit laden wird.  Die ausf¸hrbare
Abbildung eines Programms ist ein Prozeﬂ. Da ein Prozeﬂ
mˆglicherweise eine Verzweigung durchf¸hrt, werden viele Prozesse
u. U. von einem einzigen Programm abgeleitet. Alle Prozesse
enthalten mˆglicherweise mehrere Steuerungsablaufstr‰nge. Wenn
auf ein Programm durch den Programmnamen verwiesen wird oder wenn
auf das aktuelle Programm (%Programm) in einer Liste ¸ber
Fehlerbehebungsprozesse verwiesen wird, werden alle von dem
aktuellen Abruf des Programms abgeleiteten Prozesse und
Ablaufstr‰nge eingeschlossen.

SIEHE AUCH
%proc, %program, %thread, Prozeﬂ, Prozeﬂliste, Ablaufstrang
++

++ Prozeﬂ
NAME
Prozeﬂ - die ausf¸hrbare Abbildung eines Programms.

BESCHREIBUNG
Ein Prozeﬂ ist die ausf¸hrbare Abbildung eines Programm und enth‰lt
einen oder mehrere Steuerungsablaufstr‰nge.  Alle Ablaufstr‰nge
innerhalb eines Prozesses teilen den allgemeinen Prozeﬂadreﬂraum,
Prozeﬂ- und ¸bergeordnete Prozeﬂbezeichner, Privilegien, Stamm-
und Arbeitsverzeichnisse, Datei-Deskriptors, Datei- und Datensatzsperren,
Ressourcenbegrenzungen und den Signalbehandlungskontext (auﬂer Signalmaske
und Signalstapel) Wenn auf einen Prozeﬂ durch den Fehlerbehebungsbezeichner,
Systembezeichner oder durch Verwendung der Variable %proc in einer
Liste ¸ber Fehlerbehebungsprozesse verwiesen wird, werden alle
Steuerungsablaufstr‰nge innerhalb des Prozesses eingeschossen. Ist der 
Prozeﬂ kein Mehrfach-Ablaufstrangprozeﬂ, dann ist der Prozeﬂ ein 
Einzelobjekt-Ablaufstrangprozeﬂ.

SIEHE AUCH
%follow, %proc, %program, %thread, Prozeﬂliste, Programm, Ablaufstrang
++

++ Ablaufstrang
NAME
Ablaufstrang - Ein einziger Steuerungsablaufstrang.

BESCHREIBUNG
Ein Ablaufstrang ist ein Einzelausf¸hrungskontext innerhald eines Prozesses.
Jeder Ablaufstrang hat seinen eigenen Satz von Registern, Signalmasken
und Signalstapeln.  Ein "Ablaufstrang" im Kontext der Fehlerbehebungsfunktion
bezieht sich auf von den Schnittstellen in <thread.h> implementierte 
Einheiten auf Benutzerebene.  Diese Ablaufstr‰nge unterscheiden sich
von (und werden gebaut auf) dem vom Kern unterst¸tzten Light-Weight
Prozeﬂ (LWP). 

Zu einem gegebenen Zeitpunkt kann ein Ablaufstrang entweder auf
einem LWP laufen oder inaktiv sein. Ein inaktiver Ablaufstrang
kann vom Testhilfeprogramm nicht gestartet werden, doch kann sein
Status ¸berpr¸ft und ge‰ndert werden.

SIEHE AUCH
%proc, %program, %thread, Prozeﬂ, Prozeﬂliste, Programm,
ps, run, step
++

++ %thread
NAME
%thread - der aktuelle Ablaufstrang.

BESCHREIBUNG
Diese Variable enth‰lt den Ablaufstrangnamen des aktuellen Ablaufstrangs.
Sie kann explizit ¸ber den "set" Befehl oder implizit ¸ber die Befehle
"create", "grab" oder "release" eingestellt werden.
Durch Einstellen von %thread werden %proc, %program und %frame implizit
eingestellt. Wenn der aktuelle Prozeﬂ (%proc) ein Einzelablaufstrangprozeﬂ ist, 
enth‰lt %thread eine leere Zeichenkette.

SIEHE AUCH
%frame, %proc, %program, Prozeﬂ, Prozeﬂliste, Programm, Ablaufstrang
++

++ %thread_change
NAME
%thread_change - Steuerung der Funktion bei ƒnderung des Zustands.

BESCHREIBUNG
Der Zustand eines Ablaufstrangs kann sich w‰hrend
seiner Lebensdauer mehrmals ‰ndern: er wird erstellt und ist vorhanden;
er kann unterbrochen oder fortgesetzt werden; ein Multiplex-Ablaufstrang
gibt mˆglicherweise seinen LWP auf oder wird von einem LWP aufgenommen.
%thread_change regelt die Fehlerbehebungsfunktion, wenn
sich der Zustand ‰ndert. Die g¸ltigen Werte sind:
     ignorieren  Die Fehlerbehebungsfunktion druckt keine Nachricht,
                 die die ƒnderung ank¸ndigt. Der betreffende Ablaufstrang wird nicht gestoppt.
                 Ein neu erstellter oder fortgesetzter oder ein von einem
                 LWP aufgenommener Ablaufstrang wird laufend eingestellt
                 wenn mˆglich.
     ank¸ndigen  Die Fehlerbehebungsfunktion druckt eine Nachricht, die die
                 ƒnderung des Zustands ank¸ndigt. Der betreffende Ablauftrang wird nicht gestoppt.
                 Ein neu erstellter oder fortgesetzter oder ein von einem
                 LWP aufgenommener Ablaufstrang wird laufend eingestellt
                 wenn mˆglich.
     stoppen     Die Fehlerbehebungsfunktion druckt eine Nachricht, die die
                 ƒnderung des Zustands ank¸ndigt und den betreffenden Ablaufstrang stoppt
                 wenn mˆglich.  Ein fortgesetzter oder ein von einem LWP
                 aufgenommener Ablaufstrang wird gestoppt (oder im Off
                 LWP-Zustand).  Zur Erstellung eines Ablaufstrangs wird der 
                 Anlaufstrang, der den neuen Ablaufstrang erstellt, gestoppt
                 wenn die im thr_create(3T) Aufruf angegebene Funktion erreicht
                 wird.

Der Standardwert f¸r %thread_change ist "stoppen".

SIEHE AUCH
Prozeﬂ, Programm, Ablaufstrang
++

++ C++
NAME
C++ - C++-specific behavior

BESCHREIBUNG
Die Fehlerbehebungsfunktion erkennt die Objektdateien, die mit dem
C++ Compilation System 2.0 oder C++ Translator, cfront (Version 2.1 oder 3.0)
kompiliert wurden. Die aktuelle Sprache (%db_lang) wird auf C++ eingestellt.  
Namen werden als C++ Quelle und nicht wie in Objektdatei angezeigt. 


Ist C++ die aktuelle Sprache, akzeptiert das Testhilfeprogramm
eine Untermenge von C++ Ausdr¸cken, darunter folgende:

    o  alle Ausdr¸cke, die akzeptiert werden, wenn C die aktuelle
       Sprache ist
    o  Aufrufe von Mitgliederfunktionen einschlieﬂlich
       virtueller und statischer Mitgliederfunktionen
    o  Aufrufe von ¸bergeladenen Funktionen
    o  Ausdr¸cke, bei denen Typennamen als Typendefinitionen
       (typedefs) verwendet werden
    o  Ausdr¸cke mit ¸bergeladenen Operatorenfunktionen
    o  Ausdr¸cke, die auf Klassenmitglieder mit einem
       impliziten "this"-Zeiger zugreifen, wenn der Prozeﬂ oder
       Ablaufstrang in einer Funktion gestoppt wurde, die
       Klassenmitglied ist

Die print- und set-Befehle haben eine Verbose-Option (-v), die weitere
Informationen einschlieﬂlich der von der Fehlerbehebungsfunktion w‰hrend der
Auswertung des Ausdrucks aufgerufenen Funktionsprototypen aller Funktionen druckt.
Mit dieser Option erhalten Sie Informationen ¸ber Ausdr¸cke w‰hrend
¸berlasteter Funktionen oder Operationen. Die print -v Option zeigt auﬂerdem
Compiler-erstellte Struktur und Klassenmitglieder (Beispiel: Zeiger und
virtuelle Funktionstabellen).

Wenn ein Zeiger f¸r ein Basisklassenobjekt mit virtuellen Funktionen
gegeben ist, und wenn die Fehlerbehebungsfunktion feststellen
kann, daﬂ der Objekttyp von der Basisklasse abgeleitet ist,
wird whatis sowohl die Basisklasse als auch die abgeleitete
Klasse anzeigen. Der print Befehl wird auch das Objekt im Hinblick
auf den abgeleiteten Typ anzeigen.

Beim Drucken vom Inhalt einer Struktur oder Klasse wird der Print
Befehl statische Klassenmitglieder mit der Bemerkung, daﬂ sie
statisch sind, anzeigen. Beachten Sie, daﬂ symbols -v keine
statischen Mitglieder anzeigt. Bemerken Sie auch, daﬂ die vom
Compiler erstellten Mitglieder nur mit print -v angezeigt werden.

Anhaltepunkte (Stopp-Ereignisse) sind mˆglicherweise eingestellt auf:

     o  Klassenmitgliederfunktionen einschlieﬂlich Konstruktoren und Destruktoren
        und Konvertierungsfunktionen
     o  ¸bergeladene Operatorenfunktionen und
     o  ¸bergeladene Funktionen, die den kompletten Prototyp verwenden oder 
     o  ¸bergeladene Funktionen ohne Prototypeninformationen 
        In diesem Fall zeigt das Testhilfeprogramm eine Liste der Funktionen an  
        und fordert Sie auf, eine oder alle Mˆglichkeiten zu w‰hlen.

Ein Stopp-Ereignis wird mˆglicherweise auch auf einer bestimmten
Funktionskombination von Objekten und Mitgliedern mit der Syntax
"stop Zeiger->Funktion" oder"stop Objekt.Funktion" erstellt.
 debug stoppt den Prozeﬂ oder Ablaufstrang bei der Eingabe
der Funktion nur, wenn "dieser" Zeiger mit dem
angegebenen Objekt ¸bereinstimmt. Wenn die Funktion eine
virtuelle Funktion ist, wird debug den Anhaltepunkt auf der
entsprechenden ‹bersteuerungsfunktion einstellen.

BEISPIELE
print *this
print -v ptr->overloaded_f(1, 2)
whatis ptr_to_base
stop C::f(int)
stop C::C
stop C::~C
stop C::operator int()
stop C::operator+
stop ptr->f(char *)

SIEHE AUCH
%db_lang, Ausdruck, print, set, stop, whatis
++
