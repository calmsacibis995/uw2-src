# This file contains the help messages used by the Command Line interface.
# Each help message is bracketed by lines starting with ++.
# The debugger does not depend on the size (number of lines) of any message,
# but it does depend on the order of the messages.  New messages MUST be
# added to the end of the file.

++ !
NAME
! - f¸hrt einen Shell-Befehl aus.                                                    

SYNOPSIS
! Befehlszeile 
!!

BESCHREIBUNG
F¸hrt einen Shell-Befehl aus. Der Rest der Zeile wird an die
Shell zur Verarbeitung ¸bergeben. Besonders die Umleitung wird
NICHT vom Debugger, sondern von der Shell ausgef¸hrt. Die
Variable $SHELL enth‰lt, wenn sie gesetzt ist, die komplette
Pfadbezeichnung der zu verwendenden Shell. Wenn $SHELL nicht
angegeben ist, wird /usr/bin/sh verwendet. Der Debugger wartet,
bis der Befehl ausgef¸hrt ist, ¸bernimmt aber nicht die Kontrolle
der daraus sich ergebenden Verarbeitungsprozesse.

!! Gibt an, daﬂ der letzte Shell-Befehl erneut ausgef¸hrt werden
soll.

SIEHE AUCH
create, Umleitung
++

++ alias
NAME
alias - Hinzuf¸gen, auflisten oder Entfernen von
Alias-Bezeichnungen.

SYNOPSIS
alias Name Tokens ...
alias [Name]
alias -r Name

BESCHREIBUNG
Die erste Form macht aus "Name" einen Alias f¸r die Marken. Alle
Zeichen bis zum Zeilenvorschub oder Kommentar werden als zur
Definition gehˆrig angenommen. Bestehende Alias-Bezeichnungen
oder Debugger-Befehle kˆnnen als eine neue Alias-Bezeichnung
umdefiniert werden. Wenn eine Alias-Bezeichnung definiert ist,
ist die Verwendung dieser Bezeichnung gleichwertig mit der
Eingabe der Sequenz der Marken, die sie ersetzt.
Alias-Bezeichnungen kˆnnen in Form von anderen
Alias-Bezeichnungen definiert werden, allerdings nicht rekursiv.

Alias-Definitionen kˆnnen spezifische Identifikatoren $1, $2, ...
enthalten. Jeder dieser Identifikatoren $n wird in einer
Alias-Definition durch das n'te Element der Aufrufzeile ersetzt,
wobei die Argumente beginnend mit 1 numeriert sind. Vor jedem
Argument muﬂ ein Leerzeichen stehen und dahinter ein Leerzeichen,
ein 'CR/LF' das Kommentar-Zeichen (#) oder der Anfang eines
Blocks ({) stehen. Die spezifischen Identifikatoren $1, $2, ...
werden innerhalb einer Zeichenkette in Anf¸hrungszeichen nicht
ersetzt.

Wenn eine Alias-Definition den spezifischen Identifikator $#
enth‰lt, wird dieser beim Aufruf der Alias-Definition mit der
Anzahl der Argumente ersetzt, die derzeit w‰hrend des aktuellen
Alias-Aufrufes verwendet werden. Wenn eine Alias-Definition den
spezifischen Identifikator $* enth‰lt, wird dieser beim Aufruf
der Alias-Definition mit einer Liste aller Argumente ersetzt, die
w‰hrend dem aktuellen Alias-Aufrufes ¸bergeben wurden, wobei die
einzelnen Argumente durch jeweils ein Leerzeichen getrennt sind.

Ohne Argumente, listet der Befehl 'alias' alle aktuellen
Alias-Bezeichnungen auf. Mit einem einzelnen Namen, zeigt dieser
Befehl die entsprechende Alias-Bezeichnung f¸r diesen Namen.

Mit der Option -r entfernt 'alias' alle bestehenden
Alias-Bezeichnungen f¸r den angegebenen Namen.

BEISPIELE
alias
alias i
alias i step -i
alias edit list $1@1
alias print_list while($1) { print *$1; set $1 = $1->next }
alias b if ($# > 0) { stop $* } else { stop %list_file@%list_line }
alias -r i
++                                                    

++ stop
NAME
stop - Definiert oder zeigt Stopp-Ereignisse an.

SYNOPSIS
stop [-p Prozeﬂliste] [[-q] [-c Z‰hlung] Stopausdruck [Befehl]]
stop [-p Prozeﬂliste]

BESCHREIBUNG
Ein Stopp-Ereignis gibt eine Bedingung im Adreﬂbereich eines
Programms an, die den Debugger veranlaﬂt, die Ausf¸hrung des
Programms zu unterbrechen. Ein 'Stopausdruck'
besteht aus einem oder mehreren Ausdr¸cken, die mit den
Operatoren && (und) oder || (oder) verbunden sind. Jeder Ausdruck
kann:

1) entweder eine Stelle sein
        Eine bestimmte Stelle im Programmtext - diese Ereignisse sind
        wie herkˆmmliche Breakpoints;

2) oder (Ausdruck)
        Ein Ausdruck in der gel‰ufigen Sprache - diese Art von
        Stopp-Ausdr¸cken wird wahr, wenn der Ausdruck wahr wird;

3) *lvalue (Wert)
   Eine Stelle in den Programmdaten, die ge‰ndert werden kann -
   diese Art von Ausdr¸cken wird wahr, wenn sich der Wert ‰ndert.

Stoppausdr¸cke werden st‰ndig vom Debugger ausgewertet, wenn der
Subjektprozeﬂ l‰uft. Wenn der gesamte Ausdruck wahr wird, meldet
der Debugger das Vorkommen des Ereignisses und f¸hrt den optionalen
damit verbundenen "Befehl" aus.

Siehe Stopausdruck f¸r n‰here Angaben.

Die Option -q gibt an, daﬂ der Debugger das Ereignis nicht angibt.

Die Option -c gibt an, daﬂ das Ereignis die ersten 'Z‰hlung' Male
nicht auslˆst, wenn der Stopausdruck wahr wird.

Die zweite Form des Stoppbefehls listet alle Stoppereignisse f¸r
die angegebenen Prozesse.

Wenn der Stoppbefehl keine -p Option erh‰lt, gelten seine
Aktionen f¸r alle vom aktuellen Programm (%program) abgeleiteten
Prozesse. Dies ist bei den meisten anderen Befehlen nicht der
Fall.

BEISPIELE
stop myfile.c@230
stop *bar
stop (x == 5)
stop foo && (a > 7)
stop (a == 4) || (b == 7)                                                    

SIEHE AUCH
%program, %verbose, assoccmd, delete, disable, enable, events,
Ausdruck, Standort, Prozeﬂliste, Bereich, Stopausdruck
++


++ break
NAME
break - Verlassen der 'While'-Schleife.

SYNOPSIS
break                                                    

BESCHREIBUNG
 Der Befehl 'break' veranlaﬂt den Debugger, die innerste
 'While'-Schleife zu verlassen.

BEISPIELE
while($i < 10) { if (x[$i] == $myvar) break; set $i = $i + 1 }

SIEHE AUCH
continue, while
++


++ continue
NAME
continue - f‰hrt bei der n‰chsten Wiederholung mit der
'While'-Schleife fort.

SYNOPSIS
continue

BESCHREIBUNG
Der Befehl 'continue' veranlaﬂt den Debugger, mit der Ausf¸hrung
der n‰chsten Wiederholung der innersten 'While'-Schleife zu
beginnen. Die Ausf¸hrung beginnt mit der erneuten Bewertung des
Schleifenausdrucks.

BEISPIELE
while (i < 20) { step; if (i % 2) continue; p i, x[i] }

SIEHE AUCH
break, while
++


++ cancel
NAME
cancel - hebt anstehende Signale auf.

SYNOPSIS
cancel [-p Prozeﬂliste] [Signal ...]

BESCHREIBUNG
Die angegebenen "Signale" werden in den benannten Prozessen (%proc
standardm‰ﬂig) abgebrochen. Wenn eines der Signale von der
Fehlerbehebungsfunktion in einem der benannten Prozesse abgeh‰ngt
wurde, dann wird dieses Signal nicht von diesen Prozessen
empfangen, wenn sie mit der Ausf¸hrung fortfahren. Wenn keine
Signale gegeben werden, werden alle Signale abgebrochen, die auf
die benannten Prozesse warten.

BEISPIELE
cancel
cancel segv
cancel -p all sigfpe sigemt

SIEHE AUCH
kill, Prozeﬂliste, signal, signames
++


++ create
NAME
create - Erstellt und steuert einen oder mehrere neue Prozesse.

SYNOPSIS
create [-dr] [-f all|none|procs] [-l Anfangstandort] [Befehlszeile]

BESCHREIBUNG
Der Befehl 'create' hat eine Shell-‰hnliche Befehlszeile und
erstellt einen oder mehrere Prozesse. Die Befehlezeile kann
Umleitungen f¸r Ein- und/oder Ausgaben sowie ein Shell-Pipe
enthalten. Alle sich daraus ergebenden Prozesse werden an der mit
'Anfangstandort' angegebenen Stelle angehalten. Wenn keine
Startposition angegeben ist, oder die angegebene Startposition
nicht im Adreﬂbereich eines Programms gefunden werden kann, wird
der Prozeﬂ an der Funktion 'main' angehalten. Wenn keine
Funktion 'main' existiert, wird der Prozeﬂ an der im Kopf der
Objektdatei angegebenen Adresse angehalten. Um einen Prozeﬂ zu
erstellen und auszuf¸hren, m¸ssen Sie zuerst 'create' und dann
'run' eingeben. 

Wenn keine 'Befehlszeile' angegeben ist, wird
die vorhergehende 'Befehlszeile' verwendet. Alle Prozesse,
die durch Aufrufe mit dieser 'Befehlszeile' erstellt
wurden, werden gelˆscht.

Jeder erstellte Prozeﬂ erh‰lt eine
Debugger-Prozeﬂidentifikation. Diese Identifikation oder
die Systemprozeﬂ-ID weist auf diesen Prozeﬂ in Befehlen mit einer
-p Option hin. Der in einer Pipeline erst erstellte
Prozeﬂ ist der aktuelle Prozeﬂ (%proc). Alle von einem einzigen
ausf¸hrbaren Programm erstellten Prozesse (¸ber fork(2)) werden
mˆglicherweise auch vom Namen dieses ausf¸hrbaren Programms
(Programmname) referenziert.

Wenn die Option -r angegeben ist, werden Ein- und Ausgaben des
Prozesses an ein Pseude-Terminal umgeleitet. Wenn dieser Prozeﬂ
Eingaben erfordert, muﬂ der Befehl 'input' verwendet werden. Die
Option -d gibt an, daﬂ keine Umleitung erfolgt. Wenn keine
Option angegeben ist, wird die mit %redir angegebene Betriebsart
verwendet (Standard, keine Umleitung).

Wenn die Option -f mit dem Argument 'none' angegeben ist, wird
der Debugger nicht die untergeordneten Prozesse jeglicher Prozesse mit
Verzweigung verfolgen. Wenn die Option -d mit den Argumenten
'all' oder 'procs' angegeben ist, werden alle untergeordneten Prozesse vom
Debugger gesteuert (diese Prozesse kˆnnen von der
Debugger-Steuerung mit 'release' befreit werden). Wenn -f nicht
angegeben ist, wird der Debugger entsprechend %follow gesteuert
(Standard, Verfolgung aller untergeordneten Prozesse).

BEISPIEL
create
create -f none myprog 1 2 3
create myprog 1 2 3 | myfilter1 | myfilter2

SIEHE AUCH
!, %follow, %program, %redir, grab, input, Prozeﬂliste,
rename, release
++


++ delete
NAME
delete - Lˆscht Ereignisse

SYNOPSIS
delete Ereignisnummer ...
delete -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
Die erste Form lˆscht Ereignisse, die den angegebenen Ereignisnummern entsprechen.

Die zweite Form lˆscht alle Ereignisse des angegebenen
Ereignistyp (keine Angabe: alle Typen) in den angegebenen
Prozessen (keine Angabe: der aktuelle Prozeﬂ). "Ereignistyp" kann
"onstop", "signal", "stop" oder "syscall sein".


BEISPIELE
delete 1 3 5
delete -a -p p1
delete -a stop
delete -a syscall

SIEHE AUCH
change, disable, enable, events, onstop, Prozeﬂliste,
signal, stop, syscall
++


++ dis
NAME
dis - Disassembliert Anweisungen f¸r die Maschine.

SYNOPSIS
dis [-p Prozeﬂliste] [-c Anweisungszahl] [Standort]

BESCHREIBUNG
Demontiert "Anweisungszahl" Anweisungen in allen angegebenen
Prozessen (Standard %proc). Wenn keine Anweisungszahl angegeben ist,
ist die Zahl standardm‰ﬂig %num_lines.%num_lines Starten bei 10
und ƒnderungen mˆglich.

Wenn ein "Standort" angegeben ist, wird die Demontage am
gegebenen Standort in allen angegebenen Prozessen anfangen. Wenn
kein Standort angegeben ist, wird der erste dis nach einem
Ereignis ausgelˆst oder nachdem %frame zur¸ckgesetzt ist, am %loc
gestartet. Weitere dis Befehle werden von der Adresse unter den
vom vorigen dis Befehl angezeigten Anweisungen angegeben.

BEISPIELE
dis
dis -c 20 main
dis file.c@10                                                    

SIEHE AUCH
%frame, %loc, %num_lines, dump, Standort, print, Prozeﬂliste
++


++ disable
NAME
disable - Deaktiviert Ereignisse.                                                    

SYNOPSIS
disable Ereignisnummer ...
disable -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
Die erste Form deaktiviert die Ereignisse, die den angegebenen
Ereignisnummern entsprechen.

Die zweite Form deaktiviert alle Ereignisse des angegebenen
Ereignistyp (keine Angabe: alle Typen) in den angegebenen
Prozessen (keine Angabe: der aktuelle Prozeﬂ). "Ereignistyp" kann
"onstop", "signal", "stop" oder "syscall sein".

Deaktivierte Ereignisse beeinflussen ihre Prozesse nicht, werden aber nicht gelˆscht. Sie kˆnnen mit "enable" wieder aktiviert werden.

BEISPIELE
disable 3 5
disable -a -p p1
disable -a onstop
disable -a signal

SIEHE AUCH
change, delete, enable, events, onstop, Prozeﬂliste, signal,
stop, syscall
++

++ dump
NAME
dump - Zeigt den Inhalt des Speichers an.

SYNOPSIS
dump [-p Prozeﬂliste] [-c Bytezahl] Standort

BESCHREIBUNG
Dump zeigt den Inhalt des Speichers f¸r jeden angegebenen Prozeﬂ (Standard %proc) an. Er zeigt "Bytezahl" (Standard %num_bytes) Bytes, 16 Bytes pro Zeile, in Hexadezimal und ASCII an und f‰ngt dabei bei der im "Standardort" angegebenen Adresse an.

%num_bytes f‰ngt bei 256 an und kann ge‰ndert werden.

BEISPIELE
dump -c 16 myptr
dump %esp
dump 0x80001248

SIEHE AUCH
%num_bytes, dis, Standort, print, Prozeﬂliste
++


++ enable
NAME
enable - Aktiviert Ereignisse.

SYNOPSIS
enable Ereignisnummer ...
enable -a [-p Prozeﬂliste] [Ereignistyp]

BESCHREIBUNG
 Die erste Form aktiviert Ereignisse, die den angegebenen Ereignisnummern entsprechen.

Die zweite Form aktiviert alle Ereignisse des angegebenen
Typs (keine Angabe: alle Typen) in den angegebenen
Prozessen (keine Angabe: der aktuelle Prozeﬂ). "Ereignistyp" kann
"onstop", "signal", "stop" oder "syscall sein".

Nur deaktivierte Ereignisse kˆnnen aktiviert werden. Ein Ereignis
beeinfluﬂt den Prozeﬂ, in dem es definiert ist, wenn es
aktiviert wird.

BEISPIELE
enable 3 5
enable -a -p p1
enable -a stop
enable -a signal

SIEHE AUCH
change, delete, disable, events, onstop, Prozeﬂliste, signal,
stop, syscall
++


++ events
NAME
events - Listet Ereignisse auf.

SYNOPSIS
events [-p Prozeﬂliste] [Ereignisnummer ...]

BESCHREIBUNG
Ohne Argumente listet events alle Stopp-Ereignisse,
Signalaktionen, Systemaufrufaktionen und onstop Aktionen f¸r den
aktuellen Prozeﬂ auf. Mit der -p Option listet er die mit den
gegebenen Prozessen verbundenen Ereignisse auf.

Bei Angabe von einer oder mehreren Ereignisnummern zeigt "Ereignisse" eine vollst‰ndige Liste der angegebenen Ereignisse an. Die vollst‰ndige Liste enth‰lt alle Prozesse, bei denen das Ereignis eingestellt ist, und den vollst‰ndigen dazugehˆrigen Befehlsblock wenn vorhanden.

BEISPIELE
events
events -p p1,p2
events 3

SIEHE AUCH
change, delete, disable, enable, onstop, Prozeﬂliste, signal,
stop, syscall
++


++ grab
NAME
grab - ‹bernimmt die Steuerung des Lebensprozesses oder des Kernbildes.

SYNOPSIS
grab  [-f all|none|procs] [-l Datei_laden] lebendes_Objekt ...
grab -c Kerndatei Objektdatei

BESCHREIBUNG
Die erste Form benˆtigt eine oder mehrere Prozeﬂangaben; debug
versucht, die Steuerung jedes angegebenen Prozesses zu ¸bernehmen
(Steuerung wird gew‰hrt, wenn Sie die richtigen Genehmigungen
haben). Jeder Prozeﬂ wird entweder als /proc Pfadname oder
Prozeﬂ-Id angegeben.

Die Option -l gibt an, daﬂ eine alternative Objektdatei zum Laden der Symbole f¸r den Prozess verwendet werden soll; es kann nur ein Prozess angegeben werden.                                                    

Wird -f mit einem Argument von "none" angegeben, so wird der
Debugger den untergeordneten Prozessen von
analysierten Prozezessen mit Verzweigung nicht folgen.  Wird -f mit dem
Argument "all" oder "procs" angegeben, so werden alle
untergeordneten Prozessen von der Fehlerbehebungsfunktion
gesteuert (diese Prozesse kˆnnen von der Steuerung der
Fehlerbehebungsfunktion mit "release" freigegeben werden). Wird -f nicht angegeben, so regelt %follow den Debugger
(Alle Unterordnungen werden standardm‰ﬂig verfolgt).

Die zweite Form ˆffnet eine Kerndatei sowie die entsprechende
Objektdatei zur Pr¸fung. ‹bernommene Kernbilder kˆnnen mit allen
f¸r die Pr¸fung von Lebensprozessen zur Verf¸gung stehenden
Befehlen gepr¸ft, aber nicht ge‰ndert oder ausgef¸hrt werden.

‹bernommene Prozesse, wie erstellte, werden mit einem
Prozeﬂidentifikator f¸r Debugger versehen und kˆnnen entweder
mit diesem Identifikator oder mit der Prozeﬂ-ID des Systems oder mit dem
Namen des Programms, von dem sie abgeleitet sind, aufgerufen
werden. Der erste ¸bernommene Prozeﬂ wird zum aktuellen Prozeﬂ
(%proc).

BEISPIELE
grab 123
grab -f procs /proc/123 3455
grab -l myobject /proc/3455
grab -c core.save myobject                                                    

SIEHE AUCH
%follow, %proc, %program, create, Prozeﬂliste, release, rename
++


++ help
NAME
help - Ruft Hilfe auf.

SYNOPSIS
help [Thema]

BESCHREIBUNG
Das Argument 'Thema' kann ein beliebiges Alias, ein Befehlsname
oder ein Hilfethema sein. Wenn 'Thema' nicht angegeben ist, wird
die Liste der verf¸gbaren Befehle und Hilfethemen angezeigt.                                                    

BEISPIELE
help
help stop
help b
help Standort
++                                                    


++ if
NAME
if - Bedingte Verzweigung.

SYNOPSIS
if (Ausdruck) Befehl
if (Ausdruck) Befehl else Befehl

BESCHREIBUNG
"Ausdruck" wird in der aktuellen Sprache (%db_lang oder %lang) im
Kontext des aktuellen Prozesses (%proc) bewertet. Wird er als
wahr bewertet, so wird die "then" Anweisung ausgef¸hrt. Sonst
wird die "else" Anweisung (wenn vorhanden) ausgef¸hrt. "Befehl" kann
entweder ein einfacher Befehl oder Block sein.

BEISPIELE
stop  file.c@myfunc { if (x < 10) run; else print x }

SIEHE AUCH
%db_lang, %lang, Block, Ausdruck, Bereich, while
++


++ input
NAME
input - Sendet die Eingabe an einen Prozess.                                                    

SYNOPSIS
input [-p Prozeﬂname|-r Pseudo-tty] [-n] Zeichenkette

BESCHREIBUNG
Wenn ein Prozeﬂ mit 'create -r' erstellt wurde, werden dessen
Ein- und Ausgaben gemeinsam mit den E/A jeglicher anderer
Prozesse, die vom gleichen Programm abgeleitet wurden, an ein
Pseudo-Terminal umgeleitet. Um Eingaben an einen solchen Prozeﬂ
zu senden, muﬂ der Befehl 'input' verwendet werden.

'Pseudo-tty' ist der Name des Pseudo-Terminals, an den die
Eingaben umgeleitet werden sollen. Der Debugger bezeichnet alle
umgeleiteten Prozeﬂ-Ausgaben mit dem Namen des Pseudo-Terminals.
Alternativ kann ein Prozeﬂ- oder Programmname angegeben werden.
Wenn kein Prozeﬂ oder 'Pseudo-tty' angegeben ist, wird der dem
aktuellen Programm zugeteilte Pseudo-Terminal angenommen.

Die Eingabe 'Zeichenkette' wird an den angegebenen
Pseudo-Terminal oder den, dem angegebenen Prozeﬂ oder Programm
zugeteilten Pseudo-Terminal gesendet. An die Zeichenkette wird
ein 'CR/LF' angef¸gt, auﬂer wenn die Option -n angegeben ist.

BEISPIELE
input -r pts1 "Hier steht eine Zeichenkette"
input -p myprog "Hier steht eine weitere Zeichenkette"

SIEHE AUCH
%redir, create
++


++ jump
NAME
jump - Den Prozeﬂprogrammz‰hler ‰ndern.

SYNOPSIS
jump [-p Prozeﬂliste] Standort

BESCHREIBUNG
Ein Prozeﬂ muﬂ unterbrochen werden, bevor dieser Befehl
erfolgreich darauf angewandt werden kann.  jump setzt den
Programmz‰hler f¸r die benannten Prozesse (standardm‰ﬂig %proc)
auf die im "Standort" angegebene Adresse ein. Wenn der Prozeﬂ mit der
Ausf¸hrung weitermacht, f‰ngt er von dieser Adresse an.

Der Standort kann eine Adresse innerhalb des Textes des angegebenen Prozesses 
sein, aber seien Sie vorsichtig.  jump versucht nicht, den Prozeﬂstapel 
richtig einzustellen, wenn sich die Adresse auﬂerhalb der aktuellen Funktion
befindet. Vorsicht beim ‹berspringen des Codes, der mˆgliche Auswirkungen hat.

SYNOPSIS
jump 10
jump -p p2 main+8

SIEHE AUCH
Standort, Prozeﬂliste
++


++ kill
NAME
kill - ein Signal an einen Prozeﬂ senden.

SYNOPSIS
kill [-p Prozeﬂliste] [Signal]

BESCHREIBUNG
Die benannten Prozesse (Standard %proc) werden als "Signal"
gesandt. Signale werden mˆglicherweise durch Nummer oder Namen
angegeben. Ein Signalname wird u. U. mit oder ohne den Anfang
"SIG" gegeben. Klein-/Groﬂschreibung wird nicht ber¸cksichtigt.
Wird kein Signal gegeben, so verwendet kill SIGKILL.

BEISPIELE
kill -p all
kill sigfpe
kill -p p3 8

SIEHE AUCH
cancel, Prozeﬂliste, signal, signames
++


++ list
NAME
list - Zeigt die Ursprungszeilen an.

SYNOPSIS
list [-p Prozliste] [-c Anzahl] [Proz_id@][Dateiname@]Funktionname
list [-p Prozliste] [-c Anzahl] [Proz_id@][Dateiname@]Zeilennummer
list [-p Prozliste] [-c Anzahl] /norm_Ausdruck/
list [-p Prozliste] [-c Anzahl] ?norm_Ausdruck?
list [-p Prozliste] [-c Anzahl]

BESCHREIBUNG
list zeigt Ursprungszeilen f¸r den gegebenen Prozeﬂ/die gegebenen
Prozesse oder f¸r den aktuellen Prozeﬂ an, wenn kein Prozeﬂliste
angegeben ist.

Die ersten vier Formen geben die Anfangspunkte der Anzeige an.
Die ersten zwei Formen ermˆglichen die Angabe des Prozesses, der
Datei, der Funktion und der Zeilennummer. Wird ein Prozeﬂ
angegeben, so ¸bersteuert er die mit der -p Option angegebenen
Prozesse. Die dritte Form findet die n‰chste Zeile, die mit dem
normalen Ausdruck ed(1)-style ¸bereinstimmt. Die vierte Form
sucht r¸ckw‰rts von der aktuellen Zeile an. Der letzte
Schr‰gstrich/das letzte Fragezeichen muﬂ nur eingegeben werden,
wenn sich ein Befehl auf derselben Zeile befindet. Die letzte
Form f‰hrt mit der Anzeige von der Datei oder Zeile fort, bei der
der vorige "list"-Vorgang aufgehˆrt hat, oder von %file@%line nach einer
Ereignisauslˆsung oder beim Zur¸cksetzen von %frame.

Wenn das Argument 'Z‰hlung' angegeben ist, werden dementsprechend
viele Zeilen angezeigt, andernfalls werden %num_linies angezeigt.
%num_lines beginnt bei 10 und kann ge‰ndert werden.

Nachdem ein Zeilenblock angezeigt ist, wird %list_file auf den
Namen der angezeigten Datei und %list_line auf die Nummer der
zuletzt angezeigten Ursprungszeile gesetzt.

BEISPIELE
list -c 20
list myfile@1
list myfunc
list /x/
list ?foobar
list /

SIEHE AUCH
%file, %frame, %line, %list_file, %list_line, Standort,
print, Prozeﬂliste, norm_Ausdruck
++

++ map
NAME
map - Zeigt die virtuelle Adressenverteilung an.

SYNOPSIS
map [-p Prozeﬂliste]

BESCHREIBUNG
Anzeige der virtuellen Adreﬂzuordnung f¸r einen oder mehrere Prozesse.
Ohne Argument wird die Zuordnung f¸r den aktuellen Prozeﬂ (%proc)
angezeigt. Mit der -p Option wird die Zuordnung f¸r jeden Prozeﬂ,
der durch einen gegebenen Satz von Prozessen vertreten ist, angezeigt.

SIEHE AUCH
create, grab, Prozeﬂliste
++


++ symbols
NAME
symbols - Zeigt Symbolnamen, Werte und Typen an.                                                    

SYNOPSIS
symbols [-p Prozeﬂliste] [-o Objekt] [-n Dateiname] [-dfgltuv] [Muster]

BESCHREIBUNG
Anzeige der Liste von variablen Namen, die vom aktuellen Rahmen
(%frame) in den angegebenen Prozessen (Standard %proc) sichtbar
sind. Ohne Optionen (oder die -l Option) werden die lokalen Namen
in der aktuellen Funktion (%func) angezeigt. Die -f Option zeigt
nur die sichtbaren Namen an, die f¸r die aktuelle Datei (%file)
lokal ist. Wird ein "Dateiname" mit der -n Option angegeben, so
wird das Symbol dieser Datei angezeigt. Die -g Option zeigt nur
die sichtbaren globalen Namen, die im aktuellen Objekt angezeigt
werden (ausf¸hrbare Dateien oder gemeinsam benutzbare
Bibliotheken). Mit der -o Option zeigt die -g Option die in einem
Objekt angegebenen globalen Namen an. Die -d Option zeigt die
eingebauten Variablen des Debugger an. Die -u
Option zeigt die vom Debugger gewarteten
Benutzervariablen an.

Wenn ein Modell 'sh(1)-style' angegeben ist, wird die Anzeige
weiter eingeschr‰nkt und nur die Namen angezeigt, die diesem
Modell entsprechen.

Die -t Option zeigt Symboltypen und Namen an. Die -v Option zeigt
Symbolwerte an.  Beachten Sie, daﬂ symbols -v keine statischen
Klassenmitglieder anzeigt, wenn die aktuelle Sprache C++ ist.
Statische Klassenmitglieder kˆnnen u. U. durch Drucken des
Symbols angezeigt werden.

BEISPIELE
symbols -ftv
symbols -g -o libc.so.1 exec*

SIEHE AUCH
%file, %frame, %func, Muster, print, Prozeﬂliste
++


++ print
NAME
print - Druckt den Wert eines Ausdrucks aus.                                                    

SYNOPSIS
print [-p Prozeﬂliste] [-f Format] [-v] Ausdruck, ...

BESCHREIBUNG
Anzeige der Ergebnisse beim Auswerten einer Liste mit durch Komma
getrennten Ausdr¸cken. Die Ausdr¸cke werden im Kontext der
gegebenen Prozesse (Standard %proc) bewertet.  Die -f Option
erfordert ein Format mit see. Die Ausdr¸cke enthalten
mˆglicherweise Programmvariablen, eingebaute
Debugger-Variablen (z. B.: %line) und benutzerdefinierte
Variablen ($myvar, $HOME). Bei der Auswertung eines
Funktionsaufrufs erstellt der Debugger einen
Stapelrahmen f¸r diese Funktion und f¸hrt ihn aus.
Fehlerbehebungsergebnisse sind w‰hrend der Ausf¸hrung der
Funktion deaktiviert. Ausdr¸cke werden in der aktuellen Sprache
(%lang or %db_lang) bewertet. Ein Leerraum wird nach jedem
Ausdruck gedruckt, und eine neue Zeile wird am Ende hinzugef¸gt,
es sei denn ein Format ist angegeben.

Mit der Option -v werden detailliertere Informationen angezeigt.
Diese zus‰tzlichen Informationen enthalten Beispiele f¸r alle vom
Debugger w‰hrend der Bewertung des Ausdrucks aufgerufenen
Funktionen. Dies ist bei C++ n¸tzlich, um zu sehen, wie
¸berlastete Funktion gelˆst werden. Mit der Option -v werden auch
Elemente der Compiler-Struktur und -Gliederung angezeigt wie
Zeiger auf virtuelle Funktionstabellen.

Der Befehl 'set' kann auch zur Bewertung von Sprachausdr¸cken
verwendet werden. Aber bei 'set' wird das Ergebnis eines
Ausdruckes nicht ausgedruckt. Dieser Befehl wird haupts‰chlich
zur Bewertung eines Ausdrucks f¸r Nebenwirkungen wie Zuweisungen
verwendet.

BEISPIELE
print %line, %file, %func
print "a[i] == ", a[i]
print *ptr->next
print -f "0x%x\n" main
print -v myfunc(1, 2, 3)

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Format, Prozeﬂliste, Bereich, set
++

++ ps
NAME
ps - Prozess-Status.                                                    

SYNOPSIS
ps [-p Prozeﬂliste]

BESCHREIBUNG
Zeigt den Status der gesteuerten Prozesse an. Wenn die Option -p
nicht angegeben ist, wird der Status aller gesteuerten Prozesse
angezeigt. Der aktuelle Prozeﬂ (%proc) wird mit dem Sternzeichen
(*) gekennzeichnet.

SIEHE AUCH
Prozeﬂliste
++

++ pwd
NAME
pwd - Druckt das aktuelle Arbeitsverzeichnis aus.                                                    

SYNOPSIS
pwd                                                    

BESCHREIBUNG
Der Befehl 'pwd' druckt das aktuelle Arbeitsverzeichnis des Debuggers aus.

SIEHE AUCH
cd
++

++ quit
NAME
quit - Verl‰ﬂt den Debugger.

SYNOPSIS
quit

BESCHREIBUNG
Verl‰ﬂt den Debugger. Alle gesteuerten Prozesse werden gelˆscht
(wenn sie erstellt waren) oder freigegeben und ausgef¸hrt (wenn
sie ¸bernommen wurden).

SIEHE AUCH
release
++

++ release
NAME
release - Gibt einen oder mehrere gesteuerte Prozesse frei.

SYNOPSIS
release [-s] [-p Prozeﬂliste]

BESCHREIBUNG
Die angegebenen Prozesse (Standard: %thread oder %proc) werden nicht
mehr vom Debugger gesteuert oder kontrolliert. Ohne Option wird jeder
Prozeﬂ freigegeben und kann ausgef¸hrt werden. Mit der Option -s wird 
jeder im angehaltenen Zustand befindliche Prozeﬂ freigegeben. Die 
Option -s wird f¸r Ablaufstr‰nge ignoriert. Ein Prozeﬂ kann freigegeben 
werden, selbst wenn er nicht vom Debugger ¸bernommen wurde; das heiﬂt, 
erstellte Prozesse kˆnnen ebenfalls freigegeben werden.

BEISPIELE
release -p p1
release -s

SIEHE AUCH
Prozeﬂliste, quit
++

++ run
NAME
run - Definiert die Prozeﬂausf¸hrung.

SYNOPSIS
run [-p Prozeﬂliste] [-bfr] [-u Standort]

BESCHREIBUNG
Befiehlt die Ausf¸hrung der angegebenen Liste von Prozessen
(Standard: %thread oder %proc). Mit der Option -f wird der
Prozeﬂ vom Debugger im Vordergrund ausgef¸hrt, d.h. der Debugger
wartet, bis die Prozesse anhalten, bevor er die Steuerung an den
Benutzer ¸bergibt. Mit der Option -b wird die Ausf¸hrung im
Hintergrund bestimmt (kein Warten). Die Steuerung wird sofort an
den Benutzer ¸bergeben, und der Prozeﬂ wird gestartet. Wenn weder
-f noch -b angegeben sind wird der Standard durch den Wert der
Debugger-Variablen %wait bestimmt.

Mit der Option -r wird der Prozeﬂ ausgef¸hrt, bis die aktuelle
Funktion zur¸ckgibt. Mit der Option -u wird eine Stelle
angegeben, an der ausgef¸hrt werden soll.

BEISPIELE
run -p all -b
run -r
run -u 108

SIEHE AUCH
%wait, Standort, Prozeﬂliste, step
++

++ script
NAME
script - F¸hrt ein Befehlsskript des Debuggers aus.

SYNOPSIS
script [-q] fname

BESCHREIBUNG
Liest und f¸hrt Debuggerbefehle aus einer Datei aus. Befehle
werden auf dem Bildschirm angezeigt, bevor sie ausgef¸hrt werden,
auﬂer wenn die Option -q angegeben ist. Skripts kˆnnen
verschachtelt werden. ++

++ set
NAME
set - Eine Debugger- oder Programmvariable ‰ndern.

SYNOPSIS
set [-p Prozeﬂliste] [-v] debug_or_user_var [=] Ausdruck [,Ausdruck...]
set [-p Prozeﬂliste] [-v] Sprachenausdruck

BESCHREIBUNG
Der Befehl 'set' hat zwei Formen. Die erste Form wird f¸r die
Zuweisung eines neuen W f¸r eine integrierte oder erhaltene
Debugger-Variable verwendet (z.B. %lang oder $foo). Die normalen
Werte von 'Ausdruck' h‰ngen von der Variablen ab. Einige, wie %lang,
nehmen eine speziell definierte Reihe von Namen an. Andere kˆnnen
jeglichen Debugger- oder Sprachausdruck ¸bernehmen, der in einen
Zeichenkettenwert umgewandelt werden kann. Im Falle einer (durch
Komma getrennten) Liste von Zeichenketten und Benutzervariablen
werden die Zeichenkettenwerte dieser Ausdr¸cke zusammengezogen.
Siehe 'Hilfe' ¸ber jede Debugger-Variable f¸r die spezifischen,
Normalwerte.

In der zweiten Form kann der Befehl 'set' zur Bewertung
beliebiger Sprachausdr¸cke verwendet werden, obwohl die typische
Verwendung die Bewertung eines Zuweisungsausdrucks ist. Wenn mehr
als ein Prozeﬂ angegeben ist, wird der Befehl der Reihe nach im
Kontext jedes Prozesses bewertet.

Mit der Option -v werden Beispiele aller vom Debugger w‰hrend der
Bewertung des Ausdrucks aufgerufenen Befehl angezeigt. Dies ist
bei C++ n¸tzlich, um zu sehen, wie ¸berlastete Funktion gelˆst
werden.

BEISPIELE
set %global_path = %global_path, ":src/new/mydir"
set -p all %path = "mydir"
set %frame 2
set %eax = 0x3421
set x = 3
set -v myfunc(a, b)

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Prozeﬂliste, Bereich, Benutzervariablen
++


++ signal
NAME
signal - Setzt oder listet die Signalaktionen f¸r einen Prozeﬂ.

SYNOPSIS
signal [-p Prozeﬂliste] [-iq] [Signal ... [Befehl]]

BESCHREIBUNG
Wenn ein Signal an einen Prozeﬂ gesendet wird, f‰ngt der
Debugger das Signal ab und zeigt dessen Auftreten an. Dann kann
das Signal mit dem Befehl 'cancel' aufgehoben werden, oder der
Prozeﬂ kann weiterlaufen und das Signal empfangen. Wenn die
Option -i mit einem oder mehreren Signalnamen oder -nummern
angegeben wird (siehe 'kill'), bedeutet dies, daﬂ der Debugger
diese Signale ignorieren wird (nicht f¸r die unter 'Prozeﬂliste'
angegebene Liste von Prozessen abfangen wird). Ein Signalname
kann mit oder ohne den Initialen 'SIG' als Pr‰fix angegeben
werden. Groﬂ- oder Kleinschreibung ist unbedeutend. Wenn das
Signal ohne die Option -i angegeben ist, wird die Standard-Aktion
f¸r dieses Signal wiederhergestellt.

Wenn ein Befehl mit einem Satz von Signalen angegeben wird,
erstellt der Debugger ein Ereignis f¸r diesen Satz. Dieses
Ereignis kann gelˆscht, deaktiviert oder aktiviert werden und
kann ein Ereignis der Befehle 'stop', 'onstop' und 'syscall'
sein. Dem gleichen Signal kˆnnen mehrere Ereignisse zugewiesen
werden. Wenn alle Ereignisse f¸r ein gegebenen Signal gelˆscht
werden, wird die Standard-Aktion des Debuggers f¸r dieses Signal
jedoch nicht entfernt. Mit der Option -q wird das Signalereignis
nicht angek¸ndigt.

Ohne Argumente werden die Signalaktionen f¸r die unter 'Prozeﬂliste'
angegebenen Prozesse angezeigt.

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Befehls 'signal' f¸r alle vom aktuellen Programm (%program)
abgeleiteten Prozesse, wenn die Option -p nicht angegeben ist.

BEISPIELE
signal -i fpe emt
signal SIGFPE
signal 8 { if (x == 0) cancel 8; run }

SIEHE AUCH
assoccmd, cancel, delete, disable, enable, kill, Prozeﬂliste, signames
++

++ step
NAME
step - F¸hrt einen Prozess im Einzelschritt aus.                                                    

SYNOPSIS
step [-p Prozeﬂliste] [-ibfoq] [-c Z‰hlung]

BESCHREIBUNG
Die genannten Prozesse (Standard %proc) werden 'Z‰hlung' Mal
angehalten (Standard 1). Ein explizites 'Z‰hlung' von 0 bedeutet,
daﬂ schrittweise wiederholt wird bis von einem Ereignis
unterbrochen oder angehalten wird.                                                    

Mit der Option -i, Anleitungsschritt; andernfalls Anweisungsschritt.
Mit der Option -o, ‹bergehen von Funktionsaufrufen (behandelt
eine Subroutine als einen einzigen Befehl); andernfalls
schrittweises Durchgehen von Funktionsaufrufen.

Mit der Option -f wird der der Prozeﬂ vom Debugger im
Vordergrund ausgef¸hrt, d.h. der Debugger wartet, bis die
Prozesse anhalten, bevor er die Steuerung an den Benutzer
¸bergibt. Mit der Option -b wird die Ausf¸hrung im Hintergrund
bestimmt (kein Warten). Die Steuerung wird sofort an den Benutzer
¸bergeben, und der Prozeﬂ wird gestartet. Wenn weder -f noch -b
angegeben sind wird der Standard durch den Wert der
Debugger-Variablen %wait bestimmt.

Mit der Option -q zeigt der Debugger beim schrittweisen
Durchgehen nicht die Prozeﬂ-ID des Prozesses an und druckt auch
nicht die n‰chste Ursprungszeile.

BEISPIELE
step -io
step -b
step -p all -c 10

SIEHE AUCH
%verbose, %wait, Prozeﬂ, Prozeﬂliste, run
++


++ halt
NAME
halt - Einen Hintergrundprozeﬂ stoppen.                                                    

SYNOPSIS
halt [-p Prozeﬂliste]

BESCHREIBUNG
Der Debugger leitet jeden genannten Prozeﬂ (Standard, %thread or
%proc) so, daﬂ er sofort die Ausf¸hrung unterbricht. Der Antrag
kann aufgrund der Systemtr‰gheit und der Zeitplan‰nderungen
eventuell nicht sofort wirken.

Das Argument 'halt' ist f¸r Prozesse, die im Vordergrund
ausgef¸hrt werden, nicht n¸tzlich, da der Debugger die Steuerung
erst an den Benutzer ¸bergibt, wenn diese Prozesse anhalten. Um
einen im Vordergrund ausgef¸hrten Prozeﬂ anzuhalten, m¸ssen Sie
die Unterbrechungstaste dr¸cken (normalerweise die Taste 'Entf').

SIEHE AUCH
%wait, Prozeﬂliste, run, step
++

++ syscall
NAME
syscall - Definiert die Verfolgung von Systemaufrufen.

SYNOPSIS
syscall [-p Prozeﬂliste] [[-eqx] [-c Z‰hlung] Aufruf ... [Befehl]]                                                    

BESCHREIBUNG
Dieser Befehl definiert Aktionen, die zu unternehmen sind, wenn
ein ein Prozeﬂ einen Systemaufruf beginnt oder abschlieﬂt. Ohne
Argumente werden die aktuellen Aktionen f¸r Systemaufrufe f¸r den
genannten Prozeﬂ angezeigt.

Wenn ein oder mehrere Systemaufrufnamen oder -nummern angegeben
sind, unterbricht der Debugger den Prozeﬂ am Eingang (-e,
Standard) und/oder am Ausgang (-x) dieser Systemaufrufe. Das
Systemaufrufereignis wird angek¸ndigt und jeder dazugehˆrige
Befehl ausgef¸hrt.

Die Option -q bedeutet ein Unterdr¸cken der Anzeige - Das
Ereignis wird nicht angek¸ndigt. Die Option -c gibt an, daﬂ das
Ereignis 'Z‰hlung' Mal auslˆsen wird, bevor der Debugger den
Prozeﬂ unterbricht. Der Prozeﬂ wird nach jedem darauffolgenden
Auftreten unterbrochen.

Verwenden Sie 'help sysnames', um eine Liste der g¸ltigen
Systemaufrufnamen anzuzeigen. Groﬂ- oder Kleinschreibung ist
unbedeutend.                                                    

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Befehls 'syscall' f¸r alle Ablaufstr‰nge oder alle vom
aktuellen Programm (%program) abgeleiteten Einschritt-Prozesse,
wenn die Option -p nicht angegeben ist.

BEISPIELE
syscall -c 10 write { if (fd == 5) run }
syscall -qx read

SIEHE AUCH
%program, assoccmd, delete, disable, enable, events, Prozeﬂliste
++


++ regs
NAME
regs - Zeigt den Inhalt der Prozessorregister an.

SYNOPSIS
regs [-p Prozeﬂliste]

BESCHREIBUNG
Zeigt den Inhalt der Prozessorregister in hexadezimal f¸r  die
angegebenen Prozesse an (Standard %proc).

SIEHE AUCH
dis, dump, Prozeﬂliste
++


++ stack
NAME
stack - Zeigt die R¸ckverfolgung eines Funktionsaufrufes an.

SYNOPSIS
stack [-p Prozeﬂliste] [-f Rahmen] [-c Z‰hlung] [-a Adresse ] [ -s stack ]

BESCHREIBUNG
Zeigt die aktiven Funktionen f¸r die Liste von Ablaufstr‰ngen und
Prozessen (Standard, %thread or %proc) an. Die Funktionen werden
mit ihren Namen, Argumentnamen und Werten sowie der aktiven
Zeilennummer oder Adresse innerhalb der Funktion angezeigt.
Funktionsnamen, Argumentnamen und Zeilennummern kˆnnen nicht
verf¸gbar sein, wenn nicht ausreichend Symbolinformationen
vorliegen.

'Z‰hlung' gibt die Anzahl der anzuzeigenden Rahmen an. Wenn dieses
Argument nicht angegeben ist, wird der gesamte Stapel angezeigt.
Die Option -f gibt die Nummer des Rahmens an, mit dem die Anzeige
beginnen soll. Rahmen sind von 0 ab (Boden des Stapels,
Anfangsrahmen) numeriert.

Die Optionen -a und -s ermˆglichen die Angabe einer Startadresse
(Programmz‰hler) und/oder eines Startwertes f¸r den Stapelzeiger.
Dies ist manchmal n¸tzlich, wenn man eine Stapelverfolgung f¸r
einen Prozeﬂ durchf¸hren will, der an eine unerlaubte Adresse
gesprungen ist, oder dessen Stapelzeiger nicht mehr stimmt.

BEISPIELE
stack -p p2
stack -f 2 -c 3
stack -a 0x80494958 -s 0xbfff8004

SIEHE AUCH
Prozeﬂliste
++

++ while
NAME
while - Bedingte Schleife.

SYNOPSIS
while (Ausdruck) Befehl

BESCHREIBUNG
Der Ausdruck 'Ausdruck' wird in der aktuellen Sprache ((%db_lang oder
%lang) im Kontext des aktuellen Ablaufstranges oder
Einschritt-Prozesses bewertet. Wenn der Ausdruck wahr ist, wird
der Teil 'then' ausgef¸hrt. Andernfalls wird der Teil 'else'
ausgef¸hrt, wenn er vorhanden ist. Das Argument 'Befehl' kann
entweder ein einfacher Befehl oder ein Block sein.

BEISPIELE
while ($foo < 10) { print $foo, a[$foo]; set $foo = $foo + 1 }

SIEHE AUCH
%db_lang, %lang, Block, break, continue, Ausdruck, if, Bereich
++


++ cd
NAME
cd - Wechselt das aktuelle Arbeitsverzeichnis.

SYNOPSIS
cd [Phadname]

BESCHREIBUNG
Der Befehl 'cd' wechselt das aktuelle Arbeitsverzeichnis des
Debuggers auf das unter 'Phadname' angegebene Verzeichnis. Wenn
kein Pfadname angegeben ist, verwendet 'cd' das in der
Umgebungsvariablen HOME angegebene Verzeichnis.

SIEHE AUCH
pwd
++

++ change
NAME
change - ƒnderung eines bestehenden Ereignisses.                                                    

SYNOPSIS
change Ereignisnummer [-p Prozeﬂliste] [-evqx] [-c Z‰hlung]
        [Stopausdruck|Aufruf...|Signal...] [{Befehle}]

BESCHREIBUNG
Ereignisnummer muﬂ als erstes stehen und gibt die Ereignisnummer
eines bestehenden, g¸ltigen Ereignisses an. Die anderen Optionen
ermˆglichen die ƒnderung der verschiedenen Attribute dieses
Ereignisses: 
1) Die Liste der Ablaufstr‰nge und Prozesse, f¸r die es gilt (-p). 
2) die Anzeige (-q unterdr¸ckt die Ank¸ndigung eines Ereignisses, 
   -v gibt alle Informationen an), 
3) F¸r Systemaufrufe f¸r das Auftreten des Ereignisses am Anfang 
   oder am Ende oder zu beiden Zeitpunkten (-ex), 
4) F¸r Stopp- und Systemaufrufereignisse die Anzahl des Auftretens 
   des Ereignisses, bevor es angek¸ndigt wird (-c), 
5) Die zugehˆrigen Befehle (m¸ssen in geschweiften Klammern {} stehen), 
6) und der Ausdruck, die Systemaufrufliste oder die Signalliste in 
   Verbindung mit einem Ereignis.

BEISPIELE
change 3 -q
change 5 -p p2 -c 10
change 7 { print "x == ", x }
change 9 -x write

SIEHE AUCH
assoccmd, delete, disable, enable, events, onstop,
Prozeﬂliste, signal, stop, syscall
++

++ export
NAME
export - F¸gt der Umgebung ein Paar Name-Wert hinzu.                                                    

SYNOPSIS
export $username

BESCHREIBUNG
Exportiert eine f¸r den Debugger erhaltene, benutzerdefinierte
Variable f¸r die Umgebung. 'username' (und dessen aktueller Wert)
wird ein Teil der Umgebung, der von den mit Debugger erstellten
Prozessen empfangen wird. 'username' wird ohne das Pr‰fix '$'
exportiert.

SIEHE AUCH
Benutzervariablen
++

++ fc
NAME
fc - Sucht, bearbeitet und f¸hrt Befehle erneut aus.

SYNOPSIS
fc [-e ename] [-nlr] [first [last]]
fc -e - [old=new] [Befehl]

BESCHREIBUNG
'fc' ermˆglicht das Bearbeiten und Abrufen von Befehlen 'ksh(1)
style'. In der ersten Form wird eine Reihe von Befehlen von
'first' bis 'last' aus den zuletzt eingegebenen Befehlen HISTSIZE
gew‰hlt. Die Argumente 'first' und 'last' kˆnnen als Zahlen oder
als Zeichenketten angegeben werden. Eine Zeichenkette wird
verwendet, um den letzten Befehl, der mit dieser Zeichenkette
beginnt, zu finden. Eine negative Zahl wird als Offset f¸r die
aktuelle Befehlszahl verwendet.

Wenn die Option -l angegeben ist, werden die Befehle auf dem
Standard-Ausgabeger‰t aufgelistet. Andernfalls wird der
Programmeditor 'ename' f¸r eine tempor‰re Datei aufgerufen, die
die Befehle enth‰lt. Wenn 'ename' nicht angegeben ist, wird der
Wert der Umgebunsgvariablen FCEDIT (default /usr/bin/ed)
verwendet. Wenn die Bearbeitung beendet ist, werden die
bearbeiteten Befehle ausgef¸hrt.

Wenn 'first' nicht angegeben ist, wird als Standard der
vorhergehende Befehl f¸r die Bearbeitung und -16 f¸r die Liste
genommen. Die Option -r kehrt die Reihenfolge der Befehle um; die
Option -n unterdr¸ckt Befehlsnummern beim Auflisten.

In der zweiten Form wird der Befehl 'Befehl' nach dem Austausch
'old=new' erneut ausgef¸hrt. Wenn 'Befehl' nicht angegeben ist,
wird als Standard der vorhergehende Befehl verwendet.

SIEHE AUCH
%mode
++

++ logoff
NAME
logoff - Stoppt die Protokollierung von Sitzungen.

SYNOPSIS
logoff

BESCHREIBUNG
Schaltet die Protokollierung von Sitzungen ab.

SIEHE AUCH
logon
++


++ logon
NAME
logon - Startet die Protokollierung von Sitzungen.

SYNOPSIS
logon [Protokolldatei]

BESCHREIBUNG
Startet die Protokollierung von Sitzungen. Alle Debugger-Ausgaben werden an
'Protokolldatei' gesendet. Jede Ausgabezeile beginnt mit dem Zeichen #
(Kommentar). Debugger-Befehle werden ebenfalls an 'Protokolldatei'
gesendet, aber ohne vorstehendes #. Wenn keine 'Protokolldatei'
angegeben ist, wird die zuletzt in der aktuellen Debug-Sitzung
verwendete 'Protokolldatei' angenommen. Neue Befehle und Ausgaben
werden an dieser Datei angeh‰ngt. Die vom Debugger erstellten
Log-Dateien kˆnnen als Debuggers-Befehlsskripts verwendet werden.

SIEHE AUCH
logoff, script
++


++ onstop
NAME
onstop - Definiert die auszuf¸hrende Aktion, wenn der Prozeﬂ
anh‰lt.

SYNOPSIS
onstop [-p Prozeﬂliste] [Befehl]

BESCHREIBUNG
Ohne Argument 'Befehl' werden die aktuellen Aktionen des Befehls
'onstop' f¸r die Liste der in 'Prozeﬂliste' angegebenen Prozesse
angezeigt.

'Befehl' kann ein einzelner Befehl oder ein Befehlsblock sein.
Wenn ein Befehl oder ein Befehlsblock angegeben ist, werden
jedesmal, wenn ein angegebener Prozeﬂ anh‰lt, die Befehle
ausgef¸hrt (im Kontext mit diesem Prozeﬂ). Das Anhalten
enth‰lt einzelne Schritte sowie das Anhalten f¸r ein anderes
Debugger-Ereignis (signal, syscall, stop).

Im Gegensatz zu den meisten anderen Befehlen gelten die Aktionen
des Stopp-Befehls f¸r alle vom aktuellen Programm (%program)
abgeleiteten Prozesse, wenn die Option -p nicht angegeben ist.

BEISPIELE
onstop -p p2
onstop { print i, x[i] }

SIEHE AUCH
%program, delete, disable, enable, events, signal,
stop, syscall
++

++ rename
NAME
rename - ƒndert den Namen, unter dem ein Programm bekannt ist.

SYNOPSIS
rename Programmname Name

BESCHREIBUNG
Wenn ein Prozeﬂ ¸bernommen oder erstellt wird, kann der Name des
ausf¸hrbaren Programms f¸r den Bezug auf alle von diesem
ausf¸hrbaren Programm abgeleiteten Prozesse in jedem Argument
'Prozeﬂliste' verwendet werden, von dem der Prozeﬂ abgeleitet
wurde. Umbenennen gibt einen neuen Namen f¸r die Verwendung mit dem Programm an.

SIEHE AUCH
create, grab, Prozeﬂliste
++

++ %file
NAME
%file - Die aktuelle Ursprungsdatei.

BESCHREIBUNG
%file wird auf den Namen der Ursprungsdatei gesetzt, die mit dem
aktuellen Rahmen verbunden ist, wenn er bekannt ist, sobald ein
Prozeﬂ anh‰lt oder %frame ge‰ndert wird. Jeder Prozeﬂ hat seine
eigene Variable %file. Der erste Befehl 'list' nach Definition
von %frame zeigt den Ursprungsstart ab Zeile %line an, wenn keine
Stelle angegeben ist. Sie kˆnnen %line nicht explizit ‰ndern.

SIEHE AUCH
%frame, %line, %list_file, %list_line, list
++

++ %follow
NAME
%follow - Soll der Debugger untergeordnete Prozesse verfolgen?

BESCHREIBUNG
Der Debugger steuert Prozesse f¸r den Benutzer, die entweder vom
Debugger als Ergebnis eines Befehls 'create' erstellt wurden,
oder w‰hrend einer Ausf¸hrung als ein Ergebnis des Befehls 'grab'
¸bernommen wurden. Wenn '%follow' entweder auf 'all' oder 'procs'
gesetzt wird, ¸bernimmt der Debugger auch die Steuerung der
untergeordneten Prozesse aller gesteuerten Prozesse mit Verzweigung. Wenn
'%follow' auf 'none' gesetzt ist, werden keine untergeordneten Prozesse
gesteuert. Die mit %follow gesetzte, globale Betriebsart kann
durch einen individuellen Befehl 'create' oder 'grab'
¸berschrieben werden. Alle gesteuerten Prozesse kˆnnen mit dem
Befehl 'release' aus der Steuerung freigegeben werden.

Der Standardwert f¸r %follow ist 'all'.

SIEHE AUCH
create, grab, release, set
++

++ %frame
NAME
%frame - Die aktuelle Rahmennummer im Aufrufstapel.

SYNOPSIS
Das Standard-Ziel f¸r Ursprungslisten, Symboldurchsicht,
Disassemblierung und Bewertung von Ausdr¸cken. '%frame' ist auf
die Zahl des obersten Rahmens (Numerierung ab 0 f¸r den
Anfangsrahmen) definiert, wenn ein Prozeﬂ anh‰lt. Jeder Prozeﬂ
hat seinen eigenen %frame. Sie m¸ssen %frame explizit mit dem
Befehl 'set' definieren. Die Definition von %frame wird auch die
damit verbundenen Variablen %db_lang, %file, %func, %line,
%list_file, %list_line und %loc zur¸cksetzen, um einen ‹berblick
¸ber den aktuellen Kontext zu erhalten.

SIEHE AUCH
%db_lang, %file, %func, %line, %loc
++


++ %func
NAME
%func - Die aktuelle Funktion.

BESCHREIBUNG
%func ist auf den Namen der dem aktuellen Rahmen (%frame)
entsprechenden Funktion gesetzt, wenn ein Prozeﬂ anh‰lt oder
%frame ge‰ndert wird. Sie kˆnnen %frame explizit mit dem Befehl
'set' definieren, aber nur f¸r eine Funktion mit einem aktiven
Rahmen im Stapel: %frame (und die dazugehˆrigen Variablen
%db_lang, %file, %func, %line und %loc) werden ebenfalls
aktualisiert, um den neuen Kontext wiederzugeben.

SIEHE AUCH
%frame
++


++ %lang
NAME
%lang - Die aktuelle Programmiersprache.

BESCHREIBUNG
Die aktuelle Sprache. Wenn sie gesetzt ist, ¸berschreibt sie den Wert 
von %db_lang. G¸ltige Zeichenketten zur Zuweisung von %lang sind:
        C       ANSI C
        C++     C++ Release 2
Wenn %lang nicht gesetzt ist, oder mit einer Nullkette ('') definiert 
ist, verwendet der Debugger %db_lang als aktuelle Sprache. Befehle, 
die %lang zur Bewertung von Ausdr¸cken verwenden, umfassen if, 
print, set, stop, while

SIEHE AUCH
%db_lang, Ausdruck
++

++ %loc
NAME
%loc - Die aktuelle Stelle.  

BESCHREIBUNG
Der aktuelle Ausf¸hrungspunkt, %loc, wird f¸r den aktuellen
Rahmen auf den Inhalt des Programmz‰hlers gesetzt, sobald ein
Prozeﬂ anh‰lt oder %frame ge‰ndert wird. Jeder Prozeﬂ hat sein
eigenes Argument '%loc'. Sie kˆnnen %loc nicht explizit ‰ndern.
Der erste Befehl 'dis', nachdem der Rahmen (%frame) definiert
ist, wird Befehle ab der Adresse %loc disassemblieren, wenn keine
Stelle explizit angegeben wurde.

SIEHE AUCH
%frame, dis
++

++ %list_file
NAME
%list_file - Der Name der zuletzt aufgelisteten Datei.                                                    

BESCHREIBUNG
Der Befehl '%list_file' speichert Spuren der zuletzt mit dem
Befehl 'list' angezeigten Datei. %list_file ‰ndert sich, sobald
der Befehl 'list' ausgef¸hrt wird, und wird auf den Namen der
Datei zur¸ckgesetzt, die die aktuelle Stelle (%loc) im aktuellen
Rahmen (%frame) enth‰lt, sobald ein Prozeﬂ anh‰lt oder %frame 
ge‰ndert wird. Jeder Prozeﬂ hat sein eigenes Argument '%list_file'.

SIEHE AUCH
%file, %frame, %line, %list_line, list
++

++ %list_line
NAME
%list_line - Die zuletzt aufgelistete Zeilennummer.

BESCHREIBUNG
%list_line notiert die vom list Befehl letzt angezeigte Zeile.
%list_line ‰ndert sich, wenn der list Befehl ausgef¸hrt wird, und
wird auch auf die Zeilennummer mit dem aktuellen Standort (%loc)
im aktuellen Rahmen (%frame) zur¸ckgesetzt, wenn ein Prozeﬂ
stoppt oder %frame sich ‰ndert. Jeder Prozeﬂ hat seinen eigenen
%list_line.

SIEHE AUCH
%file, %frame, %line, %list_file, list
++

++ %line
NAME
%line - Die aktuelle Zeilennummer.

BESCHREIBUNG
'%line ist auf die Zeilennummer gesetzt, die die aktuelle Stelle
(%loc) im aktuellen Rahmen (%frame) enth‰lt, sobald ein Prozeﬂ
anh‰lt oder %frame ge‰ndert wird. Der erste Befehl 'list' nach
Definition von %frame zeigt den Ursprungsstart ab Zeile %line an,
wenn keine Stelle angegeben ist. Sie kˆnnen %line nicht explizit
definieren.

SIEHE AUCH
%frame, %file, %list_file, %list_line, list
++

++ %mode
NAME
%mode - Die aktuelle Zeilenbearbeitungsart.                                                    

BESCHREIBUNG
Debug unterst¸tzt die Aufzeichnung und die Bearbeitung von
Befehlen 'ksh(1) style'. '%mode ist die f¸r die Bearbeitung der
Befehlszeile verwendete Bearbeitungsart. %mode wird beim Starten
auf den Wert der Umgebungsvariablen VISUAL gesetzt, oder, wenn
sie nicht existiert, auf den Wert der Umgebungsvariablen EDITOR.
Sie kann jederzeit mit dem Befehl 'set' zur¸ckgesetzt werden.
G¸ltige Werte sind 'vi' und 'emacs'. Das Setzen von %mode auf
einen anderen Wert bricht die Befehlsbearbeitung ab.

SIEHE AUCH
fc
++

++ %path
NAME
%path - Der lokale Suchpfad f¸r Ursprungsdateien.

BESCHREIBUNG
Jedes Programm hat sein eigenes Argument %path. Der Wert von
%path muﬂ eine durch Komma getrennte Liste von Verzeichnisnamen
sein. Wenn der Debugger versucht, die Ursprungszeilen einer Datei
anzuzeigen, wird er die in %path angegebenen Verzeichnisse nach
einer Datei dieses Namens durchsuchen. Nach der Suche im lokalen
Pfad wird das angegebene Programm angezeigt und der Debugger
sucht seine globale Pfadliste (%global_path).

SIEHE AUCH
%global_path
++

++ %proc
NAME
%proc - Der aktuelle Prozeﬂ.

BESCHREIBUNG
Diese Variable enth‰lt den Prozeﬂnamen des aktuellen Prozesses.
Sie kann explizit mit dem Befehl 'set' oder implizit mit
'create', 'grab', or 'release' definiert werden. Die Definition
von %proc definiert implizit %program und %frame.

SIEHE AUCH
%frame, %program, Prozeﬂliste
++

++ %program
NAME
%program - Das aktuelle Programm.

BESCHREIBUNG
Diese Variable enth‰lt den Programmnamen des Programms, das den
aktuellen Prozess (%proc) enth‰lt. Sie kˆnnen es explizit mit dem
Befehl 'set' oder implizit mit 'create', 'grab' oder 'release'
definieren. Programme werden von der ausf¸hrbaren Datei benannt,
von der sie abgeleitet wurden und kˆnnen mit dem Befehl 'rename'
umbenannt werden. Die Definition von %program bestimmt auch
implizit %proc, %thread und %frame.

SIEHE AUCH
%proc, Prozeﬂliste
++

++ %prompt
NAME
%prompt - Die Bereitschaftszeichenkette des Debuggers.

BESCHREIBUNG
Das Bereitschaftszeichen des Debuggers fordert den Benutzer zur
Eingabe auf, indem der Wert des Bereitschaftszeichens (%prompt)
ausgedruckt wird. Der Standard-Wert ist 'debug>'. Sie kˆnnen
%prompt mit dem Befehl 'set' ‰ndern. ++

++ %thisevent
NAME
%thisevent - Die Nummer des derzeit behandelten Ereignisses.

BESCHREIBUNG
Innerhalb eines zugehˆrigen Befehls enth‰lt %thisevent die
Ereignisnummer des Ereignisses, zu dem die Befehle gehˆren. Den
Wert von %thisevent kˆnnen Sie nicht explizit ‰ndern.                                                    

SIEHE AUCH
%lastevent, assoccmd
++


++ %lastevent
NAME
%lastevent - Die Nummer des zuletzt erstellten Ereignisses.

BESCHREIBUNG
Nach einem Befehl, der eine Ereignissnummer zuteilt (stop, signal, syscall, oder onstop), enth‰lt %thisevent die gerade zugeteilte Ereignisnummer. Den Wert von %lastevent kˆnnen Sie nicht explizit ‰ndern.

SIEHE AUCH
%thisevent
++


++ assoccmd
NAME
assoccmd - Ein Debugger-Befehl oder Befehlsblock.                                                    

BESCHREIBUNG
Verschiedeme Befehle verwenden einen optional zugeteilten Befehl
oder einen Befehlsblock. Dieser muﬂ als letzter in der
Argumentliste erscheinen und kann Befehle mit eigenen,
zugeteilten Befehlen enthlaten, d.h. zugeteilte Befehle kˆnnen
verschachtelt sein. Die Befehle werden ausgef¸hrt, sobald das
betreffende Ereignis (stop, signal, usw.) auftritt. Innerhalb
eines zugeteilten Befehls enth‰lt %thisevent die Ereignisnummer
des zu behandelnden Ereignisses. Der Ablaufstrang oder Prozeﬂ,
der dieses Ereignis angetroffen hat, wird vor¸bergehend als
aktuell deklariert, w‰hrend die Befehle ausgef¸hrt werden.

SIEHE AUCH
%thisevent, Block, onstop, signal, stop, syscall
++

++ Block
NAME
Block - Eine Liste von Befehlen.

BESCHREIBUNG
Ein Befehl oder eine Liste mit durch Komma getrennten Befhlen in
geschweiften Klammern. Blˆcke kˆnnen als zugeteilte Befehle
verwendet werden oder unabh‰ngig von anderen Befehlen erscheinen.
Blˆcke kˆnnen f¸r die Zusammenfassung von Befehlen zur Umleitung
deren Ausgabe mit einer einzigen Umleitung verwendet werden.

BEISPIELE
{ if (i) print *ptr; else print *mptr } > myfile

SIEHE AUCH
assoccmd, Umleitung
++

++ Format
NAME
Format - Die Form der Ausgabe f¸r den Befehl 'print'.

BESCHREIBUNG
Das Format ist eine Zeichenkette ‰hnlich wie die Zeichenketten
f¸r den C-Befehl 'printf'. Jede Spezifikation eines Formates kann
wie folgt angegeben werden:
        %[flags][width][.[precision]][conversion_character]format_character
 Alle Felder haben die gleiche Bedeutung wie beimn Befehl
'printf'. Breite und Pr‰zision sind auf 1024 begrenzt. Die
Positionsparameter von printf und das Formatzeichen von 'printf'
'n' werden nicht akzeptiert. Jede Formatangabe entspricht einem
der im Befehl 'print' angegebenen Ausdr¸cke in der Reihenfolge,
in der sie stehen. Zeichen, die nicht zum Format gehˆren werden
wie angegeben ausgedruckt. Formatzeichen haben folgende
Bedeutungen (Elemente, die mit einem Sternchen (*) versehen sind
kˆnnen nicht auf allen Systemen zur Verf¸gung stehen):
        a*,A*   Gleitpunkt in hexadezimal mit dezimalem Exponent (als
                Zweierpotenz)
        b*,B*   Bin‰re Ganzzahl ohne Vorzeichen 
        C*      Breites Zeichen c Zeichen ohne Vorzeichen
        d,i     Dezimale Ganzzahl mit Vorzeichen
        e,E     Gleitpunkt in 'style [-]d.ddde+/-dd'
        f       Gleitpunkt in 'style [-]ddd.dddd'
        g,G     Gleitpunkt in einem der obigen Formate
        o       Oktalzahl ohne Vorzeichen
        p       ung¸ltig * (gemeiner Zeiger; hexadezimale Adresse)
        S*      Breite Zeichenkette
        s       Zeichenkette
        u       Dezimale Ganzzahl ohne Vorzeichen
        x,X     Hexadezimale Ganzzahl ohne Vorzeichen
        z       Standard-Format des Debuggers f¸r
                den Ausdruck
        %       %

SIEHE AUCH
print
++

++ Standort
NAME
Standort - Eine Adresse in einem Prozeﬂ.

BESCHREIBUNG
Die Syntax f¸r einen Stellenidentifikator lautet:
        Adresse[+-Konstante]
        [Prozeﬂname@][Dateiname@]line
        [Prozeﬂname@][Dateiname@]Funktion[+-Konstante]
wobei 'Adresse' eine oktale oder hexadezimale Programmadresse 
ist und 'Konstante' eine dezimale Ganzzahl.

BEISPIELE
17              eine Zeilennummer in der aktuellen Datei (%file)
foo.c@17        eine Zeilennummer in einer anderen Datei
0x80801234      eine Adresse
main            ein Funktionsname oder ein Etikett
main+3          drei Byte nach dem Etikett
p1.2@main       ein Funktionsname in einem angegebenen Ablaufstrang
%loc            die aktuelle Stelle
%line           die aktuelle Datei- und Zeilennummer
%r0             ein Register
%r0+80          ein Register plus Offset
%pc-4           ein Register minus Offset
$myvar          eine benutzerdefinierte Variable

SIEHE AUCH
%file, %line, %loc, Prozeﬂliste, Bereich, Benutzervariablen
++

++ Prozeﬂliste
NAME
Prozeﬂliste - Liste mit Prozeﬂnamen.

BESCHREIBUNG
Eine durch Komma getrennte Liste von 'Prozeﬂnamen'. Die meisten
Befehle akzeptieren eine 'Prozeﬂliste' mit der Option -p. Eine
Prozeﬂliste darf keine Leerzeichen enthalten.

Ein Prozeﬂname kann aus folgenden Elementen bestehen:
1)  dem Schl¸sselwort 'all', zur Bezeichnung aller gesteuerten Prozesse,
2)  ein vom Anwender angegebenen oder vom Debugger erstellten Programmnamen, der alle von diesem Programm
        abgeleitete Prozesse bezeichnet,
3)  eine vom Debugger erstellte Prozeﬂ-ID in der Form pn (z.B. p1, p2),
4)  die Debugger-Variable %program, die alle vom aktuellen Programm abgeleuteten Prozesse bezeichnet,
5)   die Debugger-Variable %proc, die den aktuellen Prozeﬂ bezeichnet,
6)  eine dezimale Ganzzahl, die der Systemprozeﬂ-ID eines
        gesteuerten Prozesses entspricht,
7)  jegliche benutzerdefinierte Variable (z.B. $foo), die einen Ganzzahlwert enth‰lt,
        und als Systemprozeﬂ-ID ausgelegt wird,
8) jegliche benutzerdefinierte Variable, die einen Zeichenkettenwert enth‰lt, der
        als eine der o.a. Formen oder als eine Liste ausgelegt werden kann.

SIEHE AUCH
Prozeﬂliste, %proc, %program, rename, Benutzervariablen
++

++ Umleitung
NAME
Umleitung - ƒnderung des Ziels f¸r die Debugger-Ausgabe.                                                    

BESCHREIBUNG
Hinter jedem Befehl oder jedem Block kann das Zeichen '>' und ein
Dateiname oder ein '|' und eine Befehlszeile der UNIX (r)-Shell
stehen. Dies veranlaﬂt die Umleitung der Ausgabe des Befehls in
die Datei oder die Umleitung in den Shell-Befehl. Sie kˆnnen auch
'>> Dateiname' verwenden, wobei die Ausgabe an die Datei
angeh‰ngt wird und nicht den aktuellen Inhalt der Datei
¸berschreibt.

BEISPIELE
stack > save.stack
symbols -gtv | grep int | pg

SIEHE AUCH
Block
++

++ Muster
NAME
Muster - ein reul‰rer Ausdruck 'sh(1) style'.                                                    

BESCHREIBUNG
Ein Modell zur Filterung der Ausgabe des Befehls 'symbols'.
        *       Steht f¸r jede Zeichenkette, einschlieﬂlich Nullkette
        ?       Steht f¸r ein einzelnen Zeichen
        [...]   Steht f¸r jedes der in Klammern stehenden Zeichen,
                        Bereiche sind zul‰ssig, und ! als erstes Zeichen gibt
                        eine Negation an

SIEHE AUCH
symbols
++

++ norm_Ausdruck
NAME
norm_Ausdruck - ein regul‰rer Ausdruck 'ed(1) style'.

BESCHREIBUNG
Ein regul‰rer Ausdruck, der zur Suche eines Modells in einer Ursprungsdatei mit dem Befehl 'list' verwendet wird.
        .       Steht f¸r ein beliebiges zeichen auﬂer CR/LF
        [...]   Steht f¸r jedes der Zeichen in Klammer,
                        Bereiche sind zul‰ssig, und ^ bedeutet eine Negation
        *       bedeutet Null oder mehr der vorhergehenden RE
        ^       Steht f¸r eine Nullkette am Anfang einer Zeile
        $       Steht f¸r eine Nullkette am Ende einer Zeile
        \{m\}   Gibt genau m Auftreten des vorhergehenden RE an
        \{m,\}  Gibt mindestens m Auftreten des vorhergehenden RE an
        \{m,n\} Bedeutet n zu n, inklusive, Auftreten
        \(...\) Steht f¸r das gleiche wie ... 
        \digit  Steht f¸r die n'te RE in Klammer im gleichen Ausdruck
        \<      Steht f¸r eine Nullkette am Anfang eines Wortes
        \>      Steht f¸r eine Nullkette am Ende eines Wortes

SIEHE AUCH
list
++

++ Benutzervariablen
NAME
Benutzervariablen - benutzerdefinierte oder vom Debugger gewartete Variablen.

BESCHREIBUNG
Namen, die mit einem Dollarzeichen ($) beginnen, sind f¸r den
Debugger-Benutzer reserviert. Beim Starten importiert der
Debugger die Shell-Umgebung als einen Ausgangssatz von
benutzerdefinierten Variablen. Sie kˆnnen mit dem Befehl 'set'
eine neue Variable erstellen. Benutzerdefinierte Variablen sind
Zeichenketten und werden, wo erforderlich, mit
'strtol(3)' in einen Zahlenwert umgewandelt.

SIEHE AUCH
export, set
++

++ %db_lang
NAME
%db_lang - Die interne Notierung des Debuggers f¸r die aktuelle Sprache.

BESCHREIBUNG
'%db_lang' ist die Sprache des aktuellen Objektes und wird vom
Debugger zur Bewertung von Sprachausdr¸cken verwendet. Es wird
vom Debugger basierend auf den in der Objektdatei enthaltenen
Informationen definiert. Wenn der Debugger nicht die Sprache des
aktuellen Objektes bestimmen kann, wird der Standardwert von
%db_lang, C, angenommen. Ein explizites Definieren von %lang
¸berschreibt die Sprache des aktuellen Objektes. Befehle, die
%db_lang zur Bewertung von Ausdr¸cken verwenden, umfassen if,
print, set, stop, whatis, und while

SIEHE AUCH
%lang, C++, Ausdruck
++

++ %global_path
NAME
%global_path - Der globale Suchpfad des Debuggers.

BESCHREIBUNG
Der Wert von %global_path muﬂ eine durch Komma getrennte Liste
von Verzeichnisnamen sein. Wenn der Debugger versucht, die
Ursprungszeilen einer Datei anzuzeigen, wird er die im lokalen %path
angegebenen Verzeichnisse nach einer Datei dieses Namens
durchsuchen. Nach der Suche im lokalen Pfad wird das angegebene
Programm angezeigt und der Debugger sucht seine globale Pfadliste
(%global_path). '%global_path' kann auch von der Befehlszeile des
Debugger aus mit der Option -s gesetzt werden.

SIEHE AUCH
%path
++

++ %num_bytes
NAME
%num_bytes - Standard-Anzahl der auszugebenden Byte.

BESCHREIBUNG
Wenn der Befehl 'dump' ohne die Option -c angegeben wird, werden
%num_bytes angezeigt. Der Ausgangswert von %num_bytes betr‰gt 256
und kann mit dem Befehl 'set' ge‰ndert werden.

SIEHE AUCH
dump
++

++ %num_lines
NAME
%num_lines -- Anzahl anzuzeigender Zeilen

BESCHREIBUNG
Wenn der Befehl 'dis' oder 'list' ohne die Option -c angegeben
wird, werden jeweils %num_lines Zeilen angezeigt. Der
Ausgangswert von %num_lines betr‰gt 10 und kann mit dem Befehl
'set' ge‰ndert werden.

SIEHE AUCH
dis, list
++

++ %result
NAME
%result - Ausf¸hrungs-Status der Debugger-Befehle.

BESCHREIBUNG
Nach der Ausf¸hrung jedes Debugger-Befehls, wird dessen Status in
der Variablen %result gespeichert. 0 bedeutet erfolgreiche
Ausf¸hrung. Ungleich Null bedeutet einen Ausf¸hrungsfehler. ++

++ %verbose
NAME
%verbose - Detail der Informationen f¸r Debugger-Ereignisse.

BESCHREIBUNG
Wenn ein vom Debugger gesteuerter Prozeﬂ anh‰lt, druckt der
Debugger normalerweise eine Meldung aus, um den Grund f¸r das
Anhalten, die Prozeﬂ-ID und die n‰chste Ursprungszeile, wenn
vorhanden, oder die n‰chste Zeile des disassemblierten Textes
anzugeben.'%verbose' kann zur Steuerung dieser Ausgabe verwendet
werden. G¸ltige Werte sind:
        quiet es erfolgt keien Ausgabe, wenn
           ein Prozeﬂ anh‰lt source es wird nur die n‰chste Zeile
           mit Ursprungstext oder mit disassembliertem Text angezeigt
        events wenn ein Ereignis das Anhalten ausgelˆst hat, wird
        auch dieses Ereignis angezeigt (dies betrifft nicht die
                angeforderten Stopps (Stop oder Einzelschritt))
        reason Grund f¸r das Anhalten, einschlieﬂlich Ereignisse
        und angeforderte Stopps all hˆchste Detailstufe (derzeit
        gleich mit 'reason')

Die Standard-Betriebsart ist 'reason'. Die Betriebsart 'quiet'
kann auch als Option -q bei bestimmten Debugger-Befehlen
verwendet werden. Diese individuellen Optionen -q ¸berschreiben
die Betriebsart %verbose.

SIEHE AUCH
change, signal, step, stop, syscall
++

++ %wait
NAME
%wait - Synchrone oder asynchrone Befehlsausf¸hrung.

BESCHREIBUNG
Wenn der Debugger einen Prozeﬂ startet, wartet er normalerweise,
bis der Prozeﬂ anh‰lt, bevor er die Steuerung an den Benutzer
¸bergibt. Wenn %wait auf 'background', 0 oder 'no' gesetzt wird,
geht der Debugger in die asynchrone Betriebsart ¸ber. In dieser
Betriebsart ¸bergeben Befehle, die einen Prozeﬂ starten, die
Steuerung sofort an den Benutzer, ohne auf das Anhalten des
Prozesses zu warten. Wenn %wait auf 'foreground', 1 oder 'yes'
gesetzt wird, geht der Debugger wieder in die
Standard-Betriebsart zur¸ck. Die globale Variable %wait kann mit
dem Optionen -f oder -b der Befehle 'run' und 'step'
¸berschrieben werden.

SIEHE AUCH
run, step
++

++ Stopausdruck
NAME
Stopausdruck - Prozeﬂ Adresse Leertaste Ereignis Ausdr¸cke

BESCHREIBUNG
'Stopausdrucke' sind besondere Ausdr¸cke, die vom
Stoppbefehl akzeptiert werden. Ein Stopausdrucke
besteht aus einem oder mehreren Stoppereignissen, die mit dem
Zeichen '&&' (und) oder '||' (oder) zusammengef¸hrt wurden. Diese
Operatoren sind linkszuordnend, aber der Debugger kann nicht die
Reihenfolge gew‰hrleisten, in der die Operatoren bewertet werden.
Jedes Stoppereignis kann sein:
         Standort 
         ( Ausdruck )
         *lvalue

Jeder Typ eines Stoppereignisses hat eine bestimmte Aktion,
wodurch das Ereignis vom Debugger bemerkt wird. Wenn eine
derartige Aktion auftritt, wird der gesamte Stoppausdruck auf
'wahr' bewertet. Wenn er wahr ist, lˆst das Ereignis normal aus
(der Debugger informiert den Benutzer ¸ber das Ereignis und f¸hrt
jeden dazugehˆrigen Befehl aus).

Eine Stelle ('Standort') ist eine Adresse im Text des Prozesses,
an der der Debugger einen Breakpoint setzen kann. Wenn der
Prozeﬂ die angegebene Stelle erreicht, bemerkt der Debugger das
Ereignis. F¸r Stoppereignisse, die sich auf Funktionsnamen
beziehen, ist der Ausdruck wahr, solange diese Funktion aktiv
ist. F¸r Stoppereignisse, die f¸r eine besondere Adresse oder
Zeilennummer gelten, ist der Ausdruck nur wahr, wenn sich der
Ablaufstrang oder Prozeﬂ an dieser Adresse oder Zeile befindet.
Geben Sie 'help Standort' ein, um die komplette Syntax dieses
Befehls einzusehen. Wenn die aktuelle Sprache C++ ist, kˆnnen
Stoppereignisse auch die spezifischen Funktionen von C++
verwenden. Geben 'help C++' f¸r n‰here Einzelheiten ein.

'Ausdruck' kann jeder beliebige, g¸ltige Ausdruck in der aktuellen
Sprache (%lang oder %db_lang) sein. Der Debugger bemerkt das
Stoppereignis, wenn ein beliebiger Identifikator im Ausdruck den
Wert ‰ndert. Dann wird der gesamte Ausdruck erneut im
Kontext der aktuellen Sprache bewertet.

'lvalue' kann jeder beliebige Ausdruck in der aktuellen Sprache
sein, der auf der linken Seite einer Zuweisung in dieser Sprache
g¸ltig w‰re. Der Debugger nemerkt dieses Ereignis, wenn sich der
Inhalt der Variablen 'Standort' ‰ndert. Die ƒnderung an sich
macht diese Art von Stoppereignis wahr.

Es kˆnnen noch umfangreichere Stoppausdr¸cke durch Kombinieren mit 
Stoppereignissen erstellt werden, indem man den Operator && (und) 
verwendet. Um zum Beispiel in der Funktion a nur anzuhalten, wenn 
die Funktion b auch aktiv ist, geben Sie 'stop a &&b' ein. Um 
anzuhalten, wenn der Wert eines Ausdruckes x innerhalb einer 
Funktion y wahr wird, geben Sie 'stop y && (x)' ein.

BEISPIELE
stop myfile.c@230
stop *bar
stop (x == 5)
stop foo && (a > 7)
stop (a == 4) || (b == 7)                                                    

SIEHE AUCH
%db_lang, %lang, C++, Ausdruck, Standort, Bereich, stop
++

++ %redir
NAME
%redir - Sollen die E/A des Prozesses umgeleitet werden?

BESCHREIBUNG
'%redir' steuert das Verhalten des Befehls 'create'. Als Standard
werden die E/A des Prozesses bei 'create' nicht umgeleitet, auﬂer
wenn die Option -r angegeben ist. Wenn %redir auf 1 oder 'yes'
gesetzt ist, wird 'create' die E/A des Prozesses umleiten, auﬂer
wenn die Option -n angegeben ist. Das Standard-Verhalten kann
durch Setzen von %redir auf 0 oder 'no' wiederhergestellt
werden.

SIEHE AUCH
create, grab, input
++


++ Ausdruck
NAME
Ausdruck - Debugger-Ausdruck

BESCHREIBUNG
Debugger-Ausdr¸cke haben die gleiche Syntax wie die aktuelle
Sprache (%lang oder %db_lang). Der Debugger akzeptiert Ausdr¸cke,
die jegliche Kombination von Programmvariablen oder Funktionen,
qualifizierten Namen, integrierten Debugger-Variablen und
benutzerdefinierten Variablen enthalten. Ein qualifizierter Name
gibt einen Programmidentifikator an, der im aktuellen
Kontext nicht sichtbar sein kann. Die Syntax lautet:
          [[Ablaufstrang-ID]@][[Quelledatei]@][[Funktion]@][[Zeilennummer]@]Identifikator
     oder [[Ablaufstrang-ID]@]Rahmennummer@Identifikator 
     oder [[Ablaufstrang-ID]@]Objektname@[Quelledatei@]Identifikator

Der qualifizierte Name wird von links nach rechts bewertet und
kann durch Verwendung von '@' verdeutlicht werden. 'Rahmennummer'
und 'Funktion' m¸ssen sich auf Funktionen beziehen, die derzeit
aktiv sind. 'Objektname' bezieht sich auf jedes Objekt
(ausf¸hrbare Datei oder geteilte Bibliothek), das im Prozeﬂ
enthalten ist.

Wenn die aktuelle Sprache C ist, unterst¸tzt 'debug' die
Bewertung aller legalen ANSI C Ausdr¸cke, auﬂer denen, die eine
Makro-Erweiterung oder Struktur, Verbindung oder Aufz‰hlung
erfordern. Ein Beispiel f¸r eine Typendeklaration in einem
Ausdruck lautet:
        ((struct { int i; char c; } *)p)->c = 'a';

Wenn die aktuelle Sprache C++ ist, akzeptiert 'debug' einen
Nebensatz von C++-Ausdr¸cken. Siehe C++ f¸r n‰here Einzelheiten.

Ausdr¸cke, die mit einem Bindestrich (-) beginnen oder
Zeichenfolgen mit besonderer Bedeutung f¸r den Debugger
enthalten, m¸ssen in runden, eckigen oder geschweiften Klammern
eingeschlossen werden. Spezielle Zeichenfolgen sind: >, >>, |,
||, &&, #, Komma, Strichpunkt, LF.

SIEHE AUCH
%db_lang, %lang, C++, if, print, Bereich, set, stop, Stopausdruck,
Benutzervariablen, while
++

++ Bereich
NAME
Bereich - Die Sichtbarkeit eines Programmidentifikators

BESCHREIBUNG
Debugger-Befehle, die Stellen oder Ausdr¸cke akzeptieren kˆnnen
sich auf Identifikatoren in gesteuerten Programmen beziehen:
Funktionen, Parameter, Variablen, Etiketten, Typen, Struktur und
Verbindungen sowie Mitgliedsnamen und Aufz‰hlungen. Stellen
kˆnnen sich auch auf Ursprungszeilennummern beziehen. Ob ein Name f¸r
den Debugger jederzeit sichtbar ist, h‰ngt vom Status des
Programms zu diesem Zeitpunkt ab (Kontext) und von der Menge
der Debug-Informationen, die das Programm an den Debugger
liefert.

Ursprungszeilennummern, Namen von lokalen Variablen f¸r eine
spezifische Funktion, Parameternamen, Typennamen, Struktur und
Verbindung sowie Mitgliedsnamen und Aufz‰hlungen sind nur
verf¸gbar, wenn die Datei, in der sie sich befinden, mit der
Option -g kompiliert wurde. Namen von globalen und
dateistatischen Funktionen und Variablen sind verf¸gbar, wenn die
Datei, die sie definiert, mit der Option -g kompiliert wurde oder
die Symboltabelle des Programms nicht abgelegt wurde.

Ursprungszeilennummern und dateistatische Funktionen und Variablen
sind nur sichtbar, wenn der aktuelle Kontext sich in dieser
Datei befindet, d.h., wenn das Programm irgendwo in dem von
dieser Datei erstellten Code angehalten ist. Funktionsparameter
sind nur sichtbar, wenn der aktuelle Kontext sich in dieser
Funktion befindet. Lokale Variablen sind nur sichtbar, wenn der
aktuelle Kontext sich innerhalb deren Definitionsblock
befindet.

Identifikatoren, die nicht im aktuellen Kontext sichtbar
sind, kˆnnen oft noch in Stellen oder Ausdr¸cken erfaﬂt werden,
wenn man deren qualifizierten Namen verwendet. Siehe 'Ausdruck' und
'Standort' f¸r die komplette Syntax.                                                    

Symbole, die in geteilten Bibliotheken definiert sind, sind nicht
sichtbar, bis diese Bibliotheken vom dynamischen Linker geladen
werden. Wenn ein Programm das erste Mal startet, sind nur die
Symbole sichtbar, die im Programm selbst definiert wurden sowie
die, die in libc.so definiert wurden. Nach dem Durchgehen des
Programms bis _start oder darunter, sind andere Bibliotheken
verf¸gbar. Symbole von geteilten Bibliotheken, die mit Aufrufen
dlopen(3X) geladen wurden, sind nur nach dem Aufruf dlopen
verf¸gbar.

SIEHE AUCH
%frame, %func, %line, Ausdruck, Standort
++

++ whatis
NAME
whatis - Zeigt den Typ eines Ausdrucks an.

SYNOPSIS
whatis [-p Prozeﬂliste] Ausdruck

BESCHREIBUNG
'whatis' zeigt den Typ des Ausdrucks im aktuellen Kontext
(%frame) an. Wenn 'Prozeﬂliste' angegeben ist, wird der Typ des
Ausdrucks im Kontext jedes Prozesses in der Liste
bewertet.'Ausdruck' kann jeglicher Ausdruck in der aktuellen Sprache
sein.

Wenn eine Variable ein Struktur- oder Klassentyp ist, zeigt
'whatis Variable' den Namen der Struktur oder Klasse an. 'whatis
structure_tag_name' oder 'whatis type_name' zeigt ale bekannten
Informationen ¸ber diesen Typ an, einschlieﬂlich der
Strukturelemente oder Aufz‰hlungen.

Wenn ein Zeiger f¸r ein Basisklassenobjekt mit virtuellen Funktionen
gegeben ist, und wenn die Fehlerbehebungsfunktion feststellen
kann, daﬂ der Objekttyp von der Basisklasse abgeleitet ist,
wird whatis sowohl die Basisklasse als auch die abgeleitete
Klasse anzeigen.                                                    

BEISPIELE
whatis i
whatis main
whatis (i + 1) * 2.0
whatis struct foobar

SIEHE AUCH
%db_lang, C++, Ausdruck
++

++ C++
NAME
C++ - C++-spezifisches Verhalten

BESCHREIBUNG
Die Fehlerbehebungsfunktion erkennt die Objektdateien, die mit dem
C++ Compilation System 2.0 oder C++ Translator, cfront (Version 2.1 oder 3.0)
kompiliert wurden. Die aktuelle Sprache (%db_lang) wird auf C++ eingestellt.  
Namen werden als C++ Quelle und nicht wie in Objektdatei angezeigt.

Ist C++ die aktuelle Sprache, akzeptiert das Testhilfeprogramm eine
Untermenge von C++ Ausdr¸cken, darunter folgende:

    o  alle Ausdr¸cke, die akzeptiert werden, wenn C die aktuelle
       Sprache ist
    o  Aufrufe von Mitgliederfunktionen einschlieﬂlich
       virtueller und statischer Mitgliederfunktionen
    o  Aufrufe von ¸bergeladenen Funktionen
    o  Ausdr¸cke, bei denen Typennamen als Typendefinitionen
       (typedefs) verwendet werden
    o  Ausdr¸cke mit ¸bergeladenen Operatorenfunktionen
    o  Ausdr¸cke, die auf Klassenmitglieder mit einem
       impliziten "this"-Zeiger zugreifen, wenn der Prozeﬂ oder
       Ablaufstrang in einer Funktion gestoppt wurde, die
       Klassenmitglied ist

Die print- und set-Befehle haben eine Verbose-Option (-v), die weitere
Informationen einschlieﬂlich der von der Fehlerbehebungsfunktion w‰hrend der
Auswertung des Ausdrucks aufgerufenen Funktionsprototypen aller Funktionen druckt.
Mit dieser Option erhalten Sie Informationen ¸ber Ausdr¸cke w‰hrend
¸berlasteter Funktionen oder Operationen. Die print -v Option zeigt auﬂerdem
Compiler-erstellte Struktur und Klassenmitglieder (Beispiel: Zeiger und
virtuelle Funktionstabellen).

Wenn ein Zeiger f¸r ein Basisklassenobjekt mit virtuellen Funktionen
gegeben ist, und wenn der Debugger feststellen
kann, daﬂ der Objekttyp von der Basisklasse abgeleitet ist,
wird whatis sowohl die Basisklasse als auch die abgeleitete
Klasse anzeigen. Der print Befehl wird auch das Objekt im Hinblick
auf den abgeleiteten Typ anzeigen.

Beim Drucken vom Inhalt einer Struktur oder Klasse wird der Print
Befehl statische Klassenmitglieder mit der Bemerkung, daﬂ sie
statisch sind, anzeigen. Beachten Sie, daﬂ symbols -v keine
statischen Mitglieder anzeigt. Beachten Sie auch, daﬂ die vom
Compiler erstellten Mitglieder nur mit print -v angezeigt werden.

Anhaltepunkte (Stoppereignisse) sind mˆglicherweise eingestellt auf:

     o  Klassenmitgliederfunktionen einschlieﬂlich Konstruktoren und Destruktoren
        und Konvertierungsfunktionen
     o  ¸bergeladene Operatorenfunktionen und  
     o  ¸bergeladene Funktionen, die den kompletten Prototyp verwenden oder 
     o  ¸bergeladene Funktionen ohne Prototypeninformationen
        In diesem Fall zeigt das Testhilfeprogramm eine Liste der Funktionen an
        und fordert Sie auf, eine oder alle Mˆglichkeiten zu w‰hlen.

Ein Stoppereignis kann auch f¸r eine spezifische Objekt- und
Funktionskombination erstellt werden, indem man die Syntax 'stop
Zeiger->Funktion' oder 'stop Objekt.Funktion' verwendet. 'debug'
stoppt den Prozeﬂ bei Eingabe der Funktion nur, wenn der Zeiger
'this' mit dem angegebenen Objekt ¸bereinstimmt. Wenn die
Funktion eine virtuelle Funktion ist, setzt 'debug' den
Breakpoint auf die geeignete, ¸berschreibende Funktion.

BEISPIELE
print *this
print -v ptr->overloaded_f(1, 2)
whatis ptr_to_base
stop C::f(int)
stop C::C
stop C::~C
stop C::operator int()
stop C::operator+
stop ptr->f(char *)

SIEHE AUCH
%db_lang, Ausdruck, print, set, stop, whatis
++
