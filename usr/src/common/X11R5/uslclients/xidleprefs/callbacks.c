/*	Copyright (c) 1990, 1991, 1992, 1993, 1994 Novell, Inc. All Rights Reserved.	*/
/*	Copyright (c) 1993 Novell, Inc. All Rights Reserved.	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Novell Inc.	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#pragma	ident	"@(#)xidleprefs:callbacks.c	1.3"
/*
 * Generated by the ICS Application Builder (xab).
 *
 *
 * Application Builder 2.5 Beta.
 *
 */

/*
 * Required Olit Include Files
 */
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xol/OpenLook.h>
#include <Xol/Flat.h>
#include <DnD/OlDnDVCX.h>
#include <Xol/ScrolledWi.h>
#include <Xol/StepField.h>
#include <Xol/FooterPane.h>
#include <Xol/Caption.h>
#include <Xol/ControlAre.h>
#include <Xol/PopupWindo.h>
#include <Xol/Slider.h>
#include <Xol/Scrollbar.h>
#include <Xol/StaticText.h>
#include <Xol/FButtons.h>
#include <Xol/FList.h>
#include <Dt/Desktop.h>


#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <xidleprefs.h>

#ifdef DEBUG
#define PRINT_DEBUG_MSG(x,a,b)	fprintf(stderr, x,a,b); fflush(stderr)
#else
#define PRINT_DEBUG_MSG(x,a,b)
#endif

void Verify(widget, clientData, callData)
Widget widget;
XtPointer clientData;
Boolean *callData;
{
	*callData = FALSE;
}

void SelectItemCB(widget, clientData, callData)
Widget widget;
caddr_t clientData;
OlFlatCallData *callData;
{
	mode_index = callData->item_index;
	PRINT_DEBUG_MSG("callData->item_index = %d\n",callData->item_index,0);
    PRINT_DEBUG_MSG("Called SelectItemCB .\n",0,0);
}

char command[256];
doit(Widget widget)
{
	system(command);
    return(TRUE);
}

void ApplyCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	char	buf[8];
	struct stat sbuf;
    extern XtAppContext	app_con;


    InitializeResourceBuffer ();
	/*
	 * XLock preferences
	 */
	PRINT_DEBUG_MSG("mode = %s .\n",xlock_modes[mode_index].real_name,0);
    PRINT_DEBUG_MSG("enablesaver = %x \n",enablesaver,0);
    PRINT_DEBUG_MSG("nolock = %x \n",passwd,0);

    AppendToResourceBuffer ("","xlock.mode", xlock_modes[mode_index].real_name);
	if ( enablesaver == False )
    	AppendToResourceBuffer ("", "xlock.enablesaver", "false");
	else
    	AppendToResourceBuffer ("", "xlock.enablesaver", "true");
	if ( passwd == False )
    	AppendToResourceBuffer ("", "xlock.nolock", "true");
	else
    	AppendToResourceBuffer ("", "xlock.nolock", "false");
	/*
	 * XIdlelock preferences
	 */
    PRINT_DEBUG_MSG("timeout = %d \n",timeout,0);
    PRINT_DEBUG_MSG("notify = %x \n",notify,0);

	if ( timeout == 0 )
		sprintf(buf,"%d",timeout);
	else
		sprintf(buf,"%2.0d",timeout);
    AppendToResourceBuffer ("", "xidlelock.timeout", buf);
	if ( notify == False )
    	AppendToResourceBuffer ("", "xidlelock.notify", "false");
	else
    	AppendToResourceBuffer ("", "xidlelock.notify", "true");

    SendResourceBuffer (dp, XtWindow (widget), 0, APPNAME);

	if ( stat("/usr/X/bin/xlock",&sbuf) != 0 )
	{
		
		EXIT_CODE=FALSE;
		Error (widget, GetStr (TXT_FileExecError));
	}
	sprintf(command,"/usr/X/bin/xidlelock&");
	XtAppAddWorkProc(app_con,(XtWorkProc)doit,widget);
}

void HelpCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
    DtRequest     request;
    long          serial;
	extern Display*  dp; 


	/*
	 * Using relative path name so that XtResolvePathname will be
	 * used to locate help file in the standard paths.  ( Hopefully
	 * this means in the paths based on locale )
	 */
	memset(&request,0,sizeof(request));
    request.header.rqtype = DT_DISPLAY_HELP;
    request.display_help.app_name = APP_NAME;
    request.display_help.icon_file = ICON_NAME;
    request.display_help.title = GetStr(TXT_title);
    request.display_help.file_name = HELP_FILE_NAME;
    request.display_help.source_type = DT_SECTION_HELP /* DT_OPEN_HELPDESK*/;

    serial = DtEnqueueRequest( XtScreen( widget ),
                               _HELP_QUEUE( dp ),
                               _HELP_QUEUE( dp ),
                               XtWindow( widget ),
                               &request );
}

void PreviewCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
    extern XtAppContext	app_con;
	struct stat sbuf;

	if ( stat("/usr/X/bin/xlock",&sbuf) != 0 )
	{
		
		EXIT_CODE=FALSE;
		Error (widget, GetStr (TXT_FileError));
    	return;
	}

	/*
	 * XLock preferences
	 */
	

    InitializeResourceBuffer ();

	sprintf(command,"/usr/X/bin/xlock -mode %s -nolock",xlock_modes[mode_index].real_name);

    PRINT_DEBUG_MSG("Called previewCB command = %s \n",command,0);

	XtAppAddWorkProc(app_con,(XtWorkProc)doit,widget);
    return;
	
}

int	currentInterval = 0;
char *intervalMins[] = {
	TXT_off,	/*  This "OFF" string is internationalized.	*/
				/*  The rest of the number strings are not	*/
	"  2",		/*  internationalized since we must use them	*/
	"  3",		/*  to create the times for the cron entry.	*/
	"  4", "  5", "  6", "  7", "  8", "  9",
	" 10", " 11", " 12", " 13", " 14", " 15", " 16", " 17", " 18", " 19",
	" 20", " 21", " 22", " 23", " 24", " 25", " 26", " 27", " 28", " 29",
	" 30", " 31", " 32", " 33", " 34", " 35", " 36", " 37", " 38", " 39",
	" 40", " 41", " 42", " 43", " 44", " 45", " 46", " 47", " 48", " 49",
	" 50", " 51", " 52", " 53", " 54", " 55", " 56", " 57", " 58", " 59",
	" 60"
};

void
SteppedCB (w, client_data,  call_data)
Widget w;
XtPointer client_data;
XtPointer call_data;
{
	OlTextFieldStepped *stepped = (OlTextFieldStepped *)call_data;
    Arg arg;
	int wrapper = 60;
	extern Widget	stepField;

	if (stepped->reason == OlSteppedIncrement)  {
		currentInterval = currentInterval + stepped->count;
		if (currentInterval >= wrapper)
			currentInterval = currentInterval - wrapper;
	}
	else {  /* OlSteppedDecrement */
		currentInterval = currentInterval - stepped->count;
		if (currentInterval < 0)
			currentInterval = wrapper + currentInterval;
	}
	timeout = 0;
	if (currentInterval != 0 )
    	timeout = atoi(intervalMins[currentInterval]);

	XtVaSetValues(w, XtNstring, intervalMins[currentInterval],
			 XtNuserData, currentInterval,
			 (String) 0);
}  /* end of SteppedCB() */
/*
 * Callback to ensure that the stupid edit cursor CAN'T be moved.
 * I can't find a way to disable display of it, but I can stop the
 * the user from moving it.
 */
void
MovedCB (w, client_data,  call_data)
Widget w;
XtPointer client_data;
XtPointer call_data;
{
    Arg arg;
	extern Widget	stepField;
	OlTextMotionCallDataPointer  motion;

	motion = (OlTextMotionCallDataPointer )call_data;
	motion->ok = FALSE;
}  /* end of MovedCB() */


void EnablesaverCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	enablesaver = False;
    PRINT_DEBUG_MSG("Called EnablesaverCB enablesaver = %x\n",enablesaver,0);
}

void enablesaverCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	enablesaver = True;
    PRINT_DEBUG_MSG("Called enablesaverCB enablesaver = %x\n",enablesaver,0);
}

void PasswdCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	passwd = False;
    PRINT_DEBUG_MSG("Called PasswdCB passwd = %x\n",passwd,0);
}
void passwdCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	passwd = True;
    PRINT_DEBUG_MSG("Called passwdCB passwd = %x\n",passwd,0);
}

void NotifyCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	notify = False;
    PRINT_DEBUG_MSG("Called NotifyCB notify = %x\n",notify,0);
}
void notifyCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
	notify = True;
    PRINT_DEBUG_MSG("Called notifyCB notify = %x\n",notify,0);
}


void CancelCB(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
    PRINT_DEBUG_MSG("Called cancel button callback.\n",0,0);
    exit(0);
}

void Cancelcallback(widget, clientData, callData)
Widget widget;
caddr_t clientData, callData;
{
    PRINT_DEBUG_MSG("Called quit button callback.\n",0,0);
    exit(0);
}

