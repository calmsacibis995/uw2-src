/*	Copyright (c) 1990, 1991, 1992, 1993, 1994 Novell, Inc. All Rights Reserved.	*/
/*	Copyright (c) 1993 Novell, Inc. All Rights Reserved.	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Novell Inc.	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#pragma	ident	"@(#)xidleprefs:creation.c	1.3"
/*
 * Generated by the ICS Application Builder (xab).
 *
 *
 * Application Builder 2.5 Beta.
 *
 */

/*
 * Required Olit Include Files
 */
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <Xol/OpenLook.h>
#include <Xol/Flat.h>
#include <DnD/OlDnDVCX.h>
#include <Xol/ScrolledWi.h>
#include <Xol/StepField.h>
#include <Xol/FooterPane.h>
#include <Xol/Caption.h>
#include <Xol/ControlAre.h>
#include <Xol/PopupWindo.h>
#include <Xol/Slider.h>
#include <Xol/StaticText.h>
#include <Xol/FButtons.h>
#include <Xol/FList.h>
#include <Dt/Desktop.h>

/*
 * User supplied include files.
 */
#include <xidleprefs.h>



/*
 * Global widget declarations.
 *        - first remove definition of EXTERNAL
 */
#ifdef EXTERNAL
#undef EXTERNAL
#endif
#define EXTERNAL


/*
 * Globals that are set by callbacks
 */

int enablesaver;
int passwd;
int notify;
int timeout;
int mode_index;

/*
 * Translated name to xlock argument translation table
 */

struct modes xlock_modes[] = {
	{ TXT_hop   , FALSE, "hop"   },
	{ TXT_qix   , FALSE, "qix"   },
	{ TXT_image , FALSE, "image" },
	{ TXT_life  , FALSE, "life"  },
	{ TXT_swarm , FALSE, "swarm" },
	{ TXT_rotor , FALSE, "rotor" },
	{ TXT_pyro  , FALSE, "pyro"  },
	{ TXT_flame , FALSE, "flame" },
	{ TXT_worm  , FALSE, "worm"  },
	{ TXT_blank , FALSE, "blank" },
	{ TXT_random, FALSE, "random"},
};
#define NUM_OF_MODES 11

/*
 * Flat widget data declarations.
 */

XtArgVal  flatArgs[30];

String pushButtonS_itemFields[] = {
   XtNlabel,
   XtNmnemonic,
   XtNselectProc,
};
#define NUM_pushButtonS_ITEM_FIELDS 3

typedef struct _pushButtonS_Item {
    XtArgVal label;
    XtArgVal mnemonic;
    XtArgVal selectProc;
} pushButtonS_Item;

pushButtonS_Item pushButtonS_items[] = {
 {(XtArgVal) NULL, (XtArgVal) NULL, (XtArgVal) NULL,    },
 {(XtArgVal) NULL, (XtArgVal) NULL, (XtArgVal) NULL,    },
 {(XtArgVal) NULL, (XtArgVal) NULL, (XtArgVal) NULL,    },
 {(XtArgVal) NULL, (XtArgVal) NULL, (XtArgVal) NULL,  },
};
#define NUM_pushButtonS_ITEMS 4

String list1_itemFields[] = {
   XtNlabel,
   XtNset,
};
#define NUM_list1_ITEM_FIELDS 2

typedef struct _list1_Item {
    XtArgVal label;
    XtArgVal set;
} list1_Item;

list1_Item list1_items[] = {
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
 {(XtArgVal) NULL, (XtArgVal) NULL,   },
};
#define NUM_list1_ITEMS 11

String checkBoxS2_itemFields[] = {
   XtNlabel,
   XtNselectProc,
   XtNunselectProc,
   XtNset,
};
#define NUM_checkBoxS2_ITEM_FIELDS 4

typedef struct _checkBoxS2_Item {
    XtArgVal label;
    XtArgVal select;
    XtArgVal unselect;
    XtArgVal set;
} checkBoxS2_Item;

checkBoxS2_Item checkBoxS2_items[] = {
 {(XtArgVal) NULL,(XtArgVal) NULL,(XtArgVal) NULL,  (XtArgVal) NULL,   },
};
#define NUM_checkBoxS2_ITEMS 1

String checkBoxS1_itemFields[] = {
   XtNlabel,
   XtNselectProc,
   XtNunselectProc,
   XtNset,
};
#define NUM_checkBoxS1_ITEM_FIELDS 4

typedef struct _checkBoxS1_Item {
    XtArgVal label;
    XtArgVal select;
    XtArgVal unselect;
    XtArgVal set;
} checkBoxS1_Item;

checkBoxS1_Item checkBoxS1_items[] = {
 {(XtArgVal) NULL,(XtArgVal) NULL,(XtArgVal) NULL,  (XtArgVal) NULL,   },
};
#define NUM_checkBoxS1_ITEMS 1

String checkBoxS_itemFields[] = {
   XtNlabel,
   XtNselectProc,
   XtNunselectProc,
   XtNset,
};
#define NUM_checkBoxS_ITEM_FIELDS 4

typedef struct _checkBoxS_Item {
    XtArgVal label;
    XtArgVal select;
    XtArgVal unselect;
    XtArgVal set;
} checkBoxS_Item;

checkBoxS_Item checkBoxS_items[] = {
 {(XtArgVal) NULL,(XtArgVal) NULL,(XtArgVal) NULL,  (XtArgVal) NULL,   },
};
#define NUM_checkBoxS_ITEMS 1

Widget	stepField; 			/* stepField callback needs to modify it */

static XtCallbackRec verifycalls[] = {
	{ Verify, NULL },
	{ NULL, NULL },
};

Widget
CreatepopupWindowShell(parent)
Widget parent;
{
    Arg    	args[512];
    Cardinal   	argcnt;
    Boolean   	argok;
    Widget 	retval;
    Widget	popupWindowShell;
    Widget	footerPanelArea;
    Widget	pushButtonS;
    Widget	lowerControlArea;
    Widget	upperControlArea;
    Widget	scrolledWindow;
    Widget	list1;
    Widget	caption;
    Widget	caption1;
    Widget	caption2;
    Widget	caption3;
	extern char *intervalMins[];
	extern int	currentInterval;
	Widget	checkBoxS2;
	Widget	checkBoxS1;
	Widget	checkBoxS;
	char	buf[32];
	int		i;
	Boolean	xidle = False;
	int		firstEvent;
	int		firstError;

	/* If the server doesn't have the idle extension then don't
	 * let the user see the interval time or the notify lock choice.
	 */
	if (XidleQueryExtension(XtDisplay(parent),&firstEvent,&firstError) != 0) {
		xidle = True;
	}

    XtInitializeWidgetClass(popupWindowShellWidgetClass);
	/*
	 * This callback is used to keep push buttons in the lower
	 * control area from exitting. ( Found this after moving 
	 * all pushbuttons to the footer )
	 */
    argcnt = 1;
	XtSetArg (args[0], XtNverify, (XtArgVal) verifycalls);
    popupWindowShell = XtCreatePopupShell(GetStr(TXT_title),
		popupWindowShellWidgetClass,
		parent,
		args,
		argcnt);

    retval = popupWindowShell;

    argcnt = 0;
    XtSetArg(args[argcnt], XtNupperControlArea, &upperControlArea); argcnt++;
    XtGetValues(popupWindowShell, args, argcnt);
    argcnt = 0;
    XtSetArg(args[argcnt], XtNalignCaptions, True); argcnt++;
    XtSetValues(upperControlArea, args, argcnt);

    argcnt = 0;
    XtSetArg(args[argcnt], XtNlowerControlArea, &lowerControlArea); argcnt++;
    XtGetValues(popupWindowShell, args, argcnt);
    argcnt = 0;
    XtSetArg(args[argcnt], XtNheight, 10); argcnt++;
    XtSetArg(args[argcnt], XtNheight, 10); argcnt++;
    XtSetValues(lowerControlArea, args, argcnt);

    argcnt = 0;
    XtSetArg(args[argcnt], XtNfooterPanel, &footerPanelArea); argcnt++;
    XtGetValues(popupWindowShell, args, argcnt);
    argcnt = 0;
    XtSetValues(footerPanelArea, args, argcnt);

    XtInitializeWidgetClass(flatButtonsWidgetClass);
    pushButtonS_items[0].label = (XtArgVal) GetStr (TXT_apply);
    pushButtonS_items[0].mnemonic = (XtArgVal) *(GetStr ( MNEM_apply));
    pushButtonS_items[0].selectProc = (XtArgVal) ApplyCB; 

    pushButtonS_items[1].label = (XtArgVal) GetStr (TXT_preview);
    pushButtonS_items[1].mnemonic = (XtArgVal) *(GetStr ( MNEM_preview));
    pushButtonS_items[1].selectProc = (XtArgVal) PreviewCB;

    pushButtonS_items[2].label = (XtArgVal) GetStr (TXT_cancel);
    pushButtonS_items[2].mnemonic = (XtArgVal) *(GetStr ( MNEM_cancel));
    pushButtonS_items[2].selectProc = (XtArgVal) CancelCB;

    pushButtonS_items[3].label = (XtArgVal) GetStr(TXT_help);
    pushButtonS_items[3].mnemonic = (XtArgVal) *(GetStr ( MNEM_help));
    pushButtonS_items[3].selectProc = (XtArgVal) HelpCB;

    argcnt = 0;
    XtSetArg(args[argcnt], XtNitemFields, pushButtonS_itemFields); argcnt++;
    XtSetArg(args[argcnt], XtNitems, pushButtonS_items); argcnt++;
    XtSetArg(args[argcnt], XtNnumItemFields, NUM_pushButtonS_ITEM_FIELDS); argcnt++;
    XtSetArg(args[argcnt], XtNnumItems, NUM_pushButtonS_ITEMS); argcnt++;
    pushButtonS = XtCreateWidget("pushButtonS",
		flatButtonsWidgetClass,
		footerPanelArea,
		args,
		argcnt);

    XtManageChild(pushButtonS);


#define MAX  60
#define MIN  0
	if ( Xidlelockdata.timeout > MAX )
		Xidlelockdata.timeout = MAX;
	else if ( Xidlelockdata.timeout < MIN )
		Xidlelockdata.timeout = MIN;
    PRINT_DEBUG_MSG("Xidlelockdata.timeout = %d \n",Xidlelockdata.timeout,0);

	if (xidle == True) {
    	XtInitializeWidgetClass(captionWidgetClass);
		argcnt = 0;
		XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
		XtSetArg(args[argcnt], XtNlabel, GetStr(TXT_minutes)); argcnt++;
		XtSetArg(args[argcnt], XtNspace, 6); argcnt++;
		caption2 = XtCreateWidget("caption2",
			captionWidgetClass,
			upperControlArea,
			args,
			argcnt);

		XtManageChild(caption2);
		/*
		* Set up the internationalized string for 'OFF'
		*/
		intervalMins[OFF_POSITION] = GetStr (intervalMins[OFF_POSITION]);
		timeout = Xidlelockdata.timeout;
		if ( Xidlelockdata.timeout)
		{
			currentInterval = timeout - 1;
		}
		else
		{
			currentInterval = timeout;
		}

		XtInitializeWidgetClass(stepFieldWidgetClass);
		argcnt = 0;
		XtSetArg(args[argcnt], XtNblinkRate, 0); argcnt++;
		XtSetArg(args[argcnt], XtNeditType, OL_TEXT_READ); argcnt++;
		XtSetArg(args[argcnt], XtNcharsVisible, 
			 ((strlen(intervalMins[currentInterval] + 1) > 4) ?  
					strlen(intervalMins[currentInterval] + 1) : 4)); argcnt++;
		XtSetArg(args[argcnt], XtNstring, intervalMins[currentInterval]); argcnt++;
		XtSetArg(args[argcnt], XtNcanIncrement, True); argcnt++;
		XtSetArg(args[argcnt], XtNcanDecrement, True); argcnt++;
		stepField = XtCreateWidget("stepField",
			stepFieldWidgetClass,
			caption2,
			args,
			argcnt);

		XtAddCallback(stepField, XtNstepped, SteppedCB, (XtPointer)0);
		XtAddCallback(stepField, XtNmotionVerification, MovedCB, (XtPointer)0);
		XtManageChild(stepField);
	}


    XtInitializeWidgetClass(captionWidgetClass);
    argcnt = 0;
    XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    XtSetArg(args[argcnt], XtNlabel,GetStr(TXT_password)); argcnt++;
    XtSetArg(args[argcnt], XtNspace, 10); argcnt++;
    caption1 = XtCreateWidget("caption1",
		captionWidgetClass,
		upperControlArea,
		args,
		argcnt);

    XtManageChild(caption1);

    XtInitializeWidgetClass(captionWidgetClass);
    argcnt = 0;
    XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    XtSetArg(args[argcnt], XtNlabel,GetStr(TXT_screensaver)); argcnt++;
    XtSetArg(args[argcnt], XtNspace, 10); argcnt++;
    caption = XtCreateWidget("caption",
		captionWidgetClass,
		upperControlArea,
		args,
		argcnt);

    XtManageChild(caption);

	if (xidle == True) {
    	XtInitializeWidgetClass(captionWidgetClass);
    	argcnt = 0;
    	XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    	XtSetArg(args[argcnt], XtNlabel,GetStr(TXT_notify)); argcnt++;
    	XtSetArg(args[argcnt], XtNspace, 10); argcnt++;
    	caption3 = XtCreateWidget("caption3",
			captionWidgetClass,
			upperControlArea,
			args,
			argcnt);

    	XtManageChild(caption3);
	}

    XtInitializeWidgetClass(scrolledWindowWidgetClass);
    argcnt = 0;
    XtSetArg(args[argcnt], XtNrecomputeWidth, True); argcnt++;
    XtSetArg(args[argcnt], XtNrecomputeHeight, True); argcnt++;
    scrolledWindow = XtCreateWidget("scrolledWindow",
		scrolledWindowWidgetClass,
		upperControlArea,
		args,
		argcnt);

    XtManageChild(scrolledWindow);


    XtInitializeWidgetClass(flatButtonsWidgetClass);
    checkBoxS_items[0].label = (XtArgVal) "";
    checkBoxS_items[0].select = (XtArgVal) passwdCB;
    checkBoxS_items[0].unselect = (XtArgVal) PasswdCB;
    passwd = checkBoxS_items[0].set = (XtArgVal) 
							( XLockdata.nolock == FALSE ) ? TRUE: FALSE;

    argcnt = 0;
    XtSetArg(args[argcnt], XtNexclusives, False); argcnt++;
    XtSetArg(args[argcnt], XtNbuttonType, OL_CHECKBOX); argcnt++;
    XtSetArg(args[argcnt], XtNitemFields, checkBoxS_itemFields); argcnt++;
    XtSetArg(args[argcnt], XtNitems, checkBoxS_items); argcnt++;
    XtSetArg(args[argcnt], XtNnumItemFields, NUM_checkBoxS_ITEM_FIELDS); argcnt++;
    XtSetArg(args[argcnt], XtNnumItems, NUM_checkBoxS_ITEMS); argcnt++;
    XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    checkBoxS = XtCreateWidget("checkBoxS",
		flatButtonsWidgetClass,
		caption1,
		args,
		argcnt);

    XtManageChild(checkBoxS);


    XtInitializeWidgetClass(flatButtonsWidgetClass);
    checkBoxS1_items[0].label = (XtArgVal) "";
    checkBoxS1_items[0].select = (XtArgVal) enablesaverCB;
    checkBoxS1_items[0].unselect = (XtArgVal) EnablesaverCB;
    checkBoxS1_items[0].set = (XtArgVal) XLockdata.enablesaver;
	enablesaver= (XtArgVal) XLockdata.enablesaver;

    argcnt = 0;
    XtSetArg(args[argcnt], XtNexclusives, False); argcnt++;
    XtSetArg(args[argcnt], XtNbuttonType, OL_CHECKBOX); argcnt++;
    XtSetArg(args[argcnt], XtNitemFields, checkBoxS1_itemFields); argcnt++;
    XtSetArg(args[argcnt], XtNitems, checkBoxS1_items); argcnt++;
    XtSetArg(args[argcnt], XtNnumItemFields, NUM_checkBoxS1_ITEM_FIELDS); argcnt++;
    XtSetArg(args[argcnt], XtNnumItems, NUM_checkBoxS1_ITEMS); argcnt++;
    XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    checkBoxS1 = XtCreateWidget("checkBoxS1",
		flatButtonsWidgetClass,
		caption,
		args,
		argcnt);

    XtManageChild(checkBoxS1);


	if (xidle) {
    	XtInitializeWidgetClass(flatButtonsWidgetClass);
    	checkBoxS2_items[0].label = (XtArgVal) "";
    	checkBoxS2_items[0].select = (XtArgVal) notifyCB;
    	checkBoxS2_items[0].unselect = (XtArgVal) NotifyCB;
    	checkBoxS2_items[0].set = (XtArgVal) Xidlelockdata.notify;
		notify = (XtArgVal) Xidlelockdata.notify;

    	argcnt = 0;
		XtSetArg(args[argcnt], XtNexclusives,False); argcnt++;
    	XtSetArg(args[argcnt], XtNbuttonType, OL_CHECKBOX); argcnt++;
    	XtSetArg(args[argcnt], XtNitemFields, checkBoxS2_itemFields); argcnt++;
    	XtSetArg(args[argcnt], XtNitems, checkBoxS2_items); argcnt++;
    	XtSetArg(args[argcnt], XtNnumItemFields, NUM_checkBoxS2_ITEM_FIELDS); argcnt++;
    	XtSetArg(args[argcnt], XtNnumItems, NUM_checkBoxS2_ITEMS); argcnt++;
    	XtSetArg(args[argcnt], XtNheight, 20); argcnt++;
    	checkBoxS2 = XtCreateWidget("checkBoxS2",
			flatButtonsWidgetClass,
			caption3,
			args,
			argcnt);
	
    	XtManageChild(checkBoxS2);
	}



    XtInitializeWidgetClass(flatListWidgetClass);

	for (mode_index = i = 0; i < NUM_OF_MODES; i++ )
	{
		if ( strcmp(XLockdata.mode,xlock_modes[i].real_name ) == 0 )
		{
			xlock_modes[i].set = TRUE;
			mode_index = i;
		}
		list1_items[i].label = (XtArgVal) GetStr(xlock_modes[i].string_name);
		list1_items[i].set = (XtArgVal) xlock_modes[i].set;
	}

    argcnt = 0;
    XtSetArg(args[argcnt], XtNitemFields, list1_itemFields); argcnt++;
    XtSetArg(args[argcnt], XtNitems, list1_items); argcnt++;
    XtSetArg(args[argcnt], XtNnumItemFields, NUM_list1_ITEM_FIELDS); argcnt++;
    XtSetArg(args[argcnt], XtNnumItems, NUM_list1_ITEMS); argcnt++;
    XtSetArg(args[argcnt], XtNheight, 100); argcnt++;
    XtSetArg(args[argcnt], XtNselectProc, SelectItemCB); argcnt++;
    list1 = XtCreateWidget("list1",
		flatListWidgetClass,
		scrolledWindow,
		args,
		argcnt);

    XtManageChild(list1);



    XtInitializeWidgetClass(staticTextWidgetClass);

    return( retval );
}

extern char  	*gettxt ();
/* GetStr
 *
 * Get an internationalized string.  String id's contain both the filename:id
 * and default string, separated by the FS_CHR character.
 */
char *
GetStr (char *idstr)
{
    char	*sep;
    char	*str;

    sep = strchr (idstr, FS_CHR);
    *sep = 0;
    str = gettxt (idstr, sep + 1);
    *sep = FS_CHR;

    return (str);
}	/* End of GetStr () */

/************************************************************
		error
**************************************************************/
#include <Xol/Modal.h>
#include <Xol/StaticText.h>
#include <Xol/FButtons.h>


void ErrorPopdownCB (Widget , XtPointer , XtPointer );
void ErrorSelectCB (Widget , XtPointer , XtPointer );
int EXIT_CODE = FALSE;

/* Lower Control Area buttons */
static String	LcaFields [] = {
    XtNlabel,
};

static struct {
    XtArgVal	lbl;
} LcaItems [1];

/* Error Notification
 *
 * Display a notice box with an error message.  The only button is a
 * "continue" button.
 */

void
Error (Widget widget, char *errorMsg)
{
    Widget		notice;
    static Boolean	first = True;

    if (first)
    {
	first = False;
	LcaItems [0].lbl = (XtArgVal) GetStr (TXT_continue);
    }

    notice = XtVaCreatePopupShell ("Message", modalShellWidgetClass, widget,
				   0);

    /* Add the error message text */
    XtVaCreateManagedWidget ("errorTxt", staticTextWidgetClass, notice,
		XtNstring,		(XtArgVal) errorMsg,
		XtNalignment,		(XtArgVal) OL_CENTER,
    		XtNfont,		(XtArgVal) _OlGetDefaultFont (widget,
							OlDefaultNoticeFont),
		0);

    /* Add the continue button to the bottom */
    (void) XtVaCreateManagedWidget ("lcaButton",
		flatButtonsWidgetClass, notice,
		XtNclientData,		(XtArgVal) notice,
		XtNselectProc,		(XtArgVal) ErrorSelectCB,
		XtNitemFields,		(XtArgVal) LcaFields,
		XtNnumItemFields,	(XtArgVal) XtNumber (LcaFields),
		XtNitems,		(XtArgVal) LcaItems,
		XtNnumItems,		(XtArgVal) XtNumber (LcaItems),
		0);

    XtAddCallback (notice, XtNpopdownCallback, ErrorPopdownCB,
		   (XtPointer) 0);

    XtPopup (notice, XtGrabExclusive);
} /* End of Error () */

/* ErrorPopdownCB
 *
 * Destroy Error notice on popdown
 */
void
ErrorPopdownCB (Widget widget, XtPointer client_data, XtPointer call_data)
{
    	XtDestroyWidget (widget);
	if (EXIT_CODE == True)
		exit (1);
} /* End of ErrorPopdownCB () */

/* ErrorSelectCB
 *
 * When a button is pressed in the lower control area, popdown the notice.
 * The notice is given an client_data.
 */
static void
ErrorSelectCB (Widget widget, XtPointer client_data, XtPointer call_data)
{
    XtPopdown ((Widget) client_data);
} /* End of ErrorSelectCB () */

